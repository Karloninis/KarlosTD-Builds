<!DOCTYPE html>
<html lang="en">
<!--
    KARLO'S TD - VERSION 5 COMPLETE FIX
    
    FIXES APPLIED:
    ✅ Cryo Tower: Fixed slow and stun mechanics (projectiles now carry stun parameters)
    ✅ XP Level Bar: Moved to top with maximum z-index, always visible, clickable for Trophy Road (menu only)
    ✅ Menu Buttons: Multiplayer, Skill Tree, Daily Challenges now functional
    ✅ Tower Upgrades: Only last 2 tiers (branch upgrades) locked, shows required level
    ✅ Farm Tower: Now unlocks at level 20 (last tower)
    ✅ Tower Unlocks: Fixed progression, proper level gating
    ✅ Level Up Popups: Shows rewards and what you unlocked
    ✅ Tower UI: Refreshes after level up to show newly unlocked content
    ✅ Tower Destroys: Properly tracked and displayed in inspect panel
    ✅ Pause Menu: Added Daily Challenges button
    ✅ Trophy Road: Shows level requirements for all unlocks
    ✅ Initial State: Players start with only 3 basic towers
-->
<head>
    <!-- CrazyGames SDK v2 -->
    <script src="https://sdk.crazygames.com/crazygames-sdk-v2.js"></script>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Karlo's TD</title>
    <style>
        :root { 
            --primary: #e67e22; 
            --secondary: #3498db;
            --accent: #e74c3c;
            --success: #2ecc71;
            --dark: #0a0e27; 
            --panel-bg: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(10, 14, 39, 0.98));
            --glow-primary: 0 0 20px rgba(230, 126, 34, 0.5);
            --glow-secondary: 0 0 20px rgba(52, 152, 219, 0.5);
        }
        
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Orbitron', sans-serif; 
            background: radial-gradient(ellipse at bottom, #0a0e27 0%, #000000 100%);
            user-select: none;
        }
        
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }

	<!-- ============================================
     CSS START - Add this to your <style> section
     ============================================ -->

/* Player Level & XP Bar (Top Left - Above HP/Wave/Gold) */
#player-level-container {
    position: fixed;
    top: 10px;
    left: 10px;
    background: var(--panel-bg);
    padding: 6px 15px;
    border-radius: 20px;
    border: 2px solid var(--primary);
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
    pointer-events: auto;
    display: flex !important;
    visibility: visible !important;
    opacity: 1 !important;
    align-items: center;
    gap: 10px;
    z-index: 1000001;  /* Maximum z-index to be always on top */
    cursor: pointer;  /* Make it clickable */
    backdrop-filter: blur(5px);
}

#player-level-badge {
    background: linear-gradient(135deg, var(--primary), var(--accent));
    color: #fff;
    font-size: 14px;
    font-weight: 900;
    padding: 4px 10px;
    border-radius: 10px;
    text-shadow: 0 2px 5px rgba(0,0,0,0.5);
    min-width: 45px;
    text-align: center;
}

#xp-bar-container {
    width: 180px;
    height: 18px;
    background: rgba(0,0,0,0.5);
    border-radius: 10px;
    overflow: hidden;
    border: 2px solid rgba(255,255,255,0.2);
    position: relative;
}

#xp-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--secondary), var(--primary));
    width: 0%;
    transition: width 0.5s ease;
    box-shadow: 0 0 15px rgba(52, 152, 219, 0.8);
}

#xp-bar-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    color: #fff;
    font-size: 9px;
    font-weight: bold;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
    pointer-events: none;
}

/* Skill Points Notification */
#skill-points-notify {
    position: absolute;
    top: 10px;
    right: 10px;
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
    color: #fff;
    padding: 8px 15px;
    border-radius: 15px;
    font-size: 12px;
    font-weight: bold;
    border: 2px solid #fff;
    box-shadow: 0 4px 20px rgba(155, 89, 182, 0.8);
    cursor: pointer;
    pointer-events: auto;
    display: none;
    animation: pulse 1.5s infinite;
    z-index: 99;
}

@keyframes pulse {
    0%, 100% { transform: scale(1); box-shadow: 0 4px 20px rgba(155, 89, 182, 0.8); }
    50% { transform: scale(1.05); box-shadow: 0 6px 25px rgba(155, 89, 182, 1); }
}

/* Ability Bar (Bottom Center) */
#ability-bar {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    display: none;
    gap: 15px;
    pointer-events: auto;
    z-index: 50;
}

.ability-btn {
    width: 70px;
    height: 70px;
    background: var(--panel-bg);
    border: 3px solid var(--primary);
    border-radius: 12px;
    cursor: pointer;
    position: relative;
    transition: all 0.3s;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.5);
}

.ability-btn:hover:not(.cooldown) {
    transform: translateY(-5px);
    box-shadow: 0 8px 25px rgba(230, 126, 34, 0.8);
}

.ability-btn.cooldown {
    opacity: 0.5;
    cursor: not-allowed;
    border-color: #555;
}

.ability-icon {
    font-size: 28px;
    margin-bottom: 3px;
}

.ability-key {
    font-size: 10px;
    color: #aaa;
    font-weight: bold;
}

.ability-cooldown {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.7);
    display: none;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    font-weight: 900;
    color: #fff;
    border-radius: 9px;
}

/* Achievement Popup */
#achievement-popup {
    top: 15%; /* Achievements appear at the top, not center */
    width: 400px;
    border-color: #f1c40f; /* Gold border */
}

#achievement-popup.show {
    right: 20px;
}

.achievement-icon { font-size: 40px; margin-bottom: 10px; }
.achievement-title { font-size: 24px; color: #f1c40f; font-weight: 900; }
.achievement-desc { color: #ccc; font-size: 14px; }
.achievement-reward { 
    background: rgba(241, 196, 15, 0.2); 
    color: #f1c40f; 
    padding: 5px 15px; 
    border-radius: 10px; 
    margin-top: 10px; 
    font-weight: bold;
}

/* Level Up Popup (Center Screen) */
#level-up-popup, #achievement-popup {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%) scale(0.8);
    background: rgba(15, 23, 42, 0.95);
    border: 3px solid var(--primary);
    border-radius: 20px;
    padding: 30px;
    box-shadow: 0 0 50px rgba(0,0,0,0.8);
    text-align: center;
    z-index: 20000; /* Must be higher than UI Layer (100) */
    
    /* DEFAULT STATE: Hidden & Non-blocking */
    opacity: 0;
    pointer-events: none;
    display: none; /* Critical: actually remove it from layout */
    
    transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
}

#level-up-popup.show, #achievement-popup.show {
    opacity: 1;
    pointer-events: auto;
    transform: translate(-50%, -50%) scale(1);
    display: flex !important; /* FORCE IT VISIBLE */
    flex-direction: column;
    align-items: center;
    gap: 15px;
}

.levelup-header {
    text-align: center;
    margin-bottom: 25px;
}

.levelup-title {
    font-size: 32px;
    font-weight: 900;
    color: #fff;
    text-transform: uppercase;
    text-shadow: 0 4px 10px rgba(0,0,0,0.5);
    margin-bottom: 10px;
    letter-spacing: 3px;
}

.levelup-subtitle {
    font-size: 18px;
    color: #f1c40f;
    font-weight: bold;
}

#levelup-rewards {
    background: rgba(0,0,0,0.3);
    border-radius: 15px;
    padding: 20px;
    margin-bottom: 20px;
    max-height: 300px;
    overflow-y: auto;
}

.reward-item {
    background: rgba(255,255,255,0.1);
    padding: 12px 15px;
    border-radius: 10px;
    margin-bottom: 10px;
    font-size: 16px;
    color: #fff;
    display: flex;
    align-items: center;
    gap: 10px;
    border-left: 4px solid #f1c40f;
    transition: all 0.3s;
}

.reward-item:hover {
    background: rgba(255,255,255,0.2);
    transform: translateX(5px);
}

.reward-item strong {
    color: #f1c40f;
}

.levelup-close-btn {
    width: 100%;
    padding: 15px;
    background: linear-gradient(135deg, #27ae60, #229954);
    border: none;
    border-radius: 12px;
    color: #fff;
    font-size: 18px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 2px;
}

.levelup-close-btn:hover {
    background: linear-gradient(135deg, #2ecc71, #27ae60);
    transform: translateY(-2px);
    box-shadow: 0 8px 20px rgba(46, 204, 113, 0.4);
}

/* Stats Panel (Bottom Left) */
#stats-panel {
    position: absolute;
    bottom: 15px;
    left: 15px;
    background: var(--panel-bg);
    border: 2px solid var(--secondary);
    border-radius: 15px;
    padding: 15px;
    min-width: 200px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.6);
    pointer-events: auto;
    display: none;
}

.stat-row {
    display: flex;
    justify-content: space-between;
    margin: 5px 0;
    color: #fff;
    font-size: 13px;
}

.stat-label {
    color: #aaa;
}

.stat-value {
    color: var(--primary);
    font-weight: bold;
}

/* Skill Tree Modal */
#skill-tree-modal {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9998;
    pointer-events: auto;
}

.skill-tree-content {
    background: var(--panel-bg);
    border: 3px solid var(--primary);
    border-radius: 20px;
    padding: 30px;
    width: 90%;
    max-width: 900px;
    max-height: 85vh;
    overflow-y: auto;
    box-shadow: 0 10px 50px rgba(0,0,0,0.9);
}

.skill-tree-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 30px;
    border-bottom: 2px solid var(--primary);
    padding-bottom: 15px;
}

.skill-tree-title {
    font-size: 32px;
    font-weight: 900;
    color: var(--primary);
    text-shadow: 0 0 15px rgba(230, 126, 34, 0.8);
}

.skill-points-display {
    font-size: 20px;
    color: #fff;
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
    padding: 10px 20px;
    border-radius: 15px;
    font-weight: bold;
}

.skill-category {
    margin-bottom: 30px;
}

.skill-category-title {
    font-size: 22px;
    color: var(--secondary);
    margin-bottom: 15px;
    font-weight: bold;
}

.skill-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 15px;
}

.skill-item {
    background: rgba(255, 255, 255, 0.05);
    border: 2px solid rgba(255, 255, 255, 0.2);
    border-radius: 12px;
    padding: 15px;
    cursor: pointer;
    transition: all 0.3s;
}

.skill-item:hover:not(.skill-locked):not(.skill-maxed) {
    transform: translateY(-3px);
    border-color: var(--primary);
    box-shadow: 0 5px 20px rgba(230, 126, 34, 0.5);
}

.skill-item.skill-locked {
    opacity: 0.5;
    cursor: not-allowed;
}

.skill-item.skill-maxed {
    border-color: var(--success);
    background: rgba(46, 204, 113, 0.1);
}

.skill-name {
    font-size: 16px;
    font-weight: bold;
    color: #fff;
    margin-bottom: 8px;
}

.skill-desc {
    font-size: 12px;
    color: #aaa;
    margin-bottom: 10px;
    line-height: 1.4;
}

.skill-level {
    font-size: 11px;
    color: var(--primary);
    font-weight: bold;
}

.skill-cost {
    font-size: 11px;
    color: #9b59b6;
    font-weight: bold;
    margin-top: 5px;
}

/* Daily Challenges Panel */
#challenges-panel {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.95);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9997;
    pointer-events: auto;
}

.challenges-content {
    background: var(--panel-bg);
    border: 3px solid var(--secondary);
    border-radius: 20px;
    padding: 30px;
    width: 90%;
    max-width: 700px;
    max-height: 85vh;
    overflow-y: auto;
    box-shadow: 0 10px 50px rgba(0,0,0,0.9);
}

.challenge-item {
    background: rgba(255, 255, 255, 0.05);
    border-left: 4px solid var(--secondary);
    padding: 20px;
    margin: 15px 0;
    border-radius: 8px;
    transition: all 0.3s;
}

.challenge-item:hover {
    background: rgba(255, 255, 255, 0.1);
    transform: translateX(5px);
}

.challenge-item.completed {
    border-left-color: var(--success);
    background: rgba(46, 204, 113, 0.1);
}

.challenge-name {
    font-size: 18px;
    font-weight: bold;
    color: #fff;
    margin-bottom: 10px;
}

.challenge-desc {
    font-size: 14px;
    color: #aaa;
    margin-bottom: 15px;
}

.challenge-progress {
    background: rgba(0,0,0,0.3);
    height: 20px;
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 10px;
    position: relative;
}

.challenge-progress-bar {
    height: 100%;
    background: linear-gradient(90deg, var(--secondary), var(--primary));
    transition: width 0.5s ease;
}

.challenge-progress-text {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 11px;
    font-weight: bold;
    color: #fff;
    text-shadow: 0 1px 3px rgba(0,0,0,0.8);
}

.challenge-reward {
    font-size: 13px;
    color: #f1c40f;
    font-weight: bold;
}

/* Responsive adjustments */
@media (max-width: 768px) {
    #player-level-container {
        top: 10px;
        padding: 8px 15px;
    }

    #xp-bar-container {
        width: 150px;
        height: 20px;
    }

    .ability-btn {
        width: 60px;
        height: 60px;
    }

    #stats-panel {
        bottom: 80px;
        left: 15px;
    }
}

<!-- CSS END -->

        /* Performance Stats */
        #performance-stats {
            position: absolute;
            bottom: 15px;
            left: 15px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
            z-index: 100;
        }

        .perf-stat {
            background: var(--panel-bg);
            color: #fff;
            padding: 4px 10px;
            border-radius: 12px;
            border: 2px solid;
            border-image: linear-gradient(90deg, var(--primary), var(--secondary)) 1;
            font-size: 10px;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            display: inline-block;
        }

        .perf-stat.warning {
            border-color: #f1c40f;
            animation: pulseWarning 1s infinite;
        }

        .perf-stat.critical {
            border-color: #e74c3c;
            animation: pulseCritical 0.5s infinite;
        }

        @keyframes pulseWarning {
            0%, 100% { box-shadow: 0 4px 15px rgba(241, 196, 15, 0.5); }
            50% { box-shadow: 0 4px 25px rgba(241, 196, 15, 0.9); }
        }

        @keyframes pulseCritical {
            0%, 100% { box-shadow: 0 4px 15px rgba(231, 76, 60, 0.7); }
            50% { box-shadow: 0 4px 30px rgba(231, 76, 60, 1); }
        }

        /* Lag Warning Banner */
        #lag-warning {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(231, 76, 60, 0.95);
            color: #fff;
            padding: 20px 40px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            border: 3px solid #c0392b;
            box-shadow: 0 8px 30px rgba(0,0,0,0.8);
            display: none;
            pointer-events: none;
            animation: shake 0.5s infinite;
            text-align: center;
            z-index: 10000;
        }

        @keyframes shake {
            0%, 100% { transform: translate(-50%, -50%) translateX(0); }
            25% { transform: translate(-50%, -50%) translateX(-5px); }
            75% { transform: translate(-50%, -50%) translateX(5px); }
        }

        /* MP Warning Modal */
        #mp-warning-modal {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            pointer-events: auto;
        }

        .mp-warning-content {
            background: var(--panel-bg);
            border: 3px solid var(--primary);
            border-radius: 15px;
            padding: 30px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 50px rgba(0,0,0,0.8);
            animation: slideInDown 0.5s ease-out;
        }

        @keyframes slideInDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .mp-warning-title {
            color: var(--accent);
            font-size: 28px;
            font-weight: 900;
            text-align: center;
            margin-bottom: 20px;
            text-transform: uppercase;
            text-shadow: 0 0 20px rgba(231, 76, 60, 0.8);
        }

        .mp-warning-text {
            color: #fff;
            font-size: 16px;
            line-height: 1.6;
            margin-bottom: 15px;
        }

        .mp-warning-section {
            background: rgba(255, 255, 255, 0.05);
            border-left: 4px solid var(--secondary);
            padding: 15px;
            margin: 15px 0;
            border-radius: 5px;
        }

        .mp-warning-section h3 {
            color: var(--secondary);
            margin: 0 0 10px 0;
            font-size: 18px;
        }

        .mp-warning-section ul {
            margin: 5px 0;
            padding-left: 20px;
            color: #ccc;
        }

        .mp-warning-section li {
            margin: 5px 0;
        }

        .mp-warning-highlight {
            color: var(--primary);
            font-weight: bold;
        }

        /* Modern Animated Buttons */
        .btn {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.2), rgba(230, 126, 34, 0.1));
            border: 2px solid;
            border-image: linear-gradient(45deg, var(--primary), var(--secondary)) 1;
            color: #fff; 
            padding: 15px 30px;
            font-size: 18px; 
            font-weight: bold; 
            border-radius: 8px; 
            cursor: pointer; 
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            text-transform: uppercase; 
            letter-spacing: 2px;
            position: relative; 
            overflow: hidden;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4), var(--glow-primary);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover { 
            transform: translateY(-3px) scale(1.05); 
            box-shadow: 0 6px 25px rgba(230, 126, 34, 0.6), var(--glow-primary);
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
            border-image: linear-gradient(45deg, var(--secondary), var(--primary)) 1;
        }

        /* Animated Game Info Panel */
        #game-info-panel {
            position: absolute; 
            top: 70px; right: 20px;
            background: var(--panel-bg);
            border: 2px solid;
            border-image: linear-gradient(180deg, rgba(230, 126, 34, 0.6), rgba(52, 152, 219, 0.6)) 1;
            border-radius: 12px; 
            padding: 15px; 
            color: #ccc; 
            font-size: 12px; 
            width: 200px;
            pointer-events: none;
            display: none;
            backdrop-filter: blur(10px);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6), inset 0 0 20px rgba(230, 126, 34, 0.1);
            animation: slideInRight 0.5s ease-out;
        }
        
        @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        @keyframes slideInLeft {
            from { transform: translateX(-100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .info-header { 
            color: var(--primary); 
            font-weight: bold; 
            border-bottom: 2px solid;
            border-image: linear-gradient(90deg, var(--primary), transparent) 1;
            padding-bottom: 8px; 
            margin-bottom: 10px; 
            text-align: center;
            text-transform: uppercase;
            text-shadow: 0 0 10px rgba(230, 126, 34, 0.8);
            font-size: 14px;
        }
        
        .info-row { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 5px;
            padding: 3px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .player-row { 
            display: flex; 
            justify-content: space-between; 
            margin-top: 4px; 
            color: #fff;
            font-weight: bold;
            padding: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 4px;
            transition: all 0.3s;
        }
        
        .player-row:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .btn:active { transform: translateY(-1px) scale(0.98); }
        
        .btn-primary { 
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.9), rgba(211, 84, 0, 0.9));
            border-color: #d35400;
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.4);
        }
        
        .btn-primary:hover { 
            background: linear-gradient(135deg, #e67e22, #d35400);
            box-shadow: 0 6px 30px rgba(230, 126, 34, 0.8);
        }
        
        .btn:disabled {
            background: linear-gradient(135deg, #555, #444);
            border-color: #666; 
            color: #aaa;
            cursor: not-allowed; 
            transform: none !important;
            box-shadow: none !important;
            opacity: 0.5;
        }
        
        /* Live Player Counter */
        #live-player-counter {
            position: absolute;
            left: calc(100% + 15px); /* 15px gap from button */
            top: 50%;
            transform: translateY(-50%);
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.2), rgba(39, 174, 96, 0.2));
            border: 2px solid #2ecc71;
            border-radius: 20px;
            padding: 8px 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 0 20px rgba(46, 204, 113, 0.3);
            animation: pulseGlow 2s infinite;
            white-space: nowrap;
        }
        
        @keyframes pulseGlow {
            0%, 100% { box-shadow: 0 0 20px rgba(46, 204, 113, 0.3); }
            50% { box-shadow: 0 0 30px rgba(46, 204, 113, 0.6); }
        }
        
        #live-player-counter .pulse-dot {
            width: 10px;
            height: 10px;
            background: #2ecc71;
            border-radius: 50%;
            box-shadow: 0 0 10px #2ecc71;
            animation: pulse 1.5s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.3); opacity: 0.7; }
        }
        
        #live-player-counter .player-count-text {
            color: #2ecc71;
            font-weight: bold;
            font-size: 14px;
            text-shadow: 0 0 10px rgba(46, 204, 113, 0.5);
        }
        
        #live-player-counter .player-count-number {
            color: #fff;
            font-weight: 900;
            font-size: 18px;
            min-width: 30px;
            text-align: center;
            transition: transform 0.2s ease;
        }
        
        /* Futuristic Stats Bar */
        #stats-bar {
            position: absolute; top: 60px; left: 15px;
            display: flex; gap: 12px; pointer-events: auto; display: none;
        }
        
        .stat-pill {
            background: var(--panel-bg);
            color: #fff; 
            padding: 10px 20px;
            border-radius: 25px; 
            border: 2px solid;
            border-image: linear-gradient(90deg, var(--primary), var(--secondary)) 1;
            font-weight: bold;
            display: flex; 
            align-items: center; 
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5), inset 0 0 10px rgba(230, 126, 34, 0.2);
            transition: all 0.3s;
            animation: fadeIn 0.5s ease-out;
        }
        
        .stat-pill:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(230, 126, 34, 0.4);
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        /* Wave Controls */
        #wave-controls {
            position: absolute; top: 15px; left: 50%; transform: translateX(-50%);
            pointer-events: auto; display: flex; flex-direction: column; align-items: center; gap: 8px;
            display: none;
        }
        
        #wave-info { 
            background: var(--panel-bg);
            color: #fff; 
            padding: 8px 20px; 
            border-radius: 20px; 
            font-size: 13px; 
            margin-bottom: 5px;
            border: 2px solid;
            border-image: linear-gradient(90deg, var(--primary), var(--secondary)) 1;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            animation: pulse 2s ease-in-out infinite;
        }
        
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
            50% { transform: scale(1.05); box-shadow: 0 6px 20px rgba(230, 126, 34, 0.6); }
        }

        /* Epic Tower Dock */
        #tower-dock {
            position: absolute;
            bottom: 20px;
            right: 0; /* Aligned to right edge */
            left: auto; /* Remove centering */
            transform: none; /* Remove centering transform */
            
            display: none;
            flex-direction: row; /* Button on Left, Panel on Right */
            align-items: flex-end; /* Align bottom */
            
            pointer-events: auto;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            z-index: 1000;
        }
        
        /* 2. TOGGLE BUTTON (Vertical Tab on the Left) */
        #dock-toggle {
            background: var(--panel-bg);
            color: var(--primary); 
            border: 2px solid var(--primary);
            border-right: none; /* Connect to panel */
            
            width: 30px;
            height: 80px; /* Tall vertical tab */
            padding: 0;
            
            border-radius: 10px 0 0 10px; /* Round left corners */
            cursor: pointer; 
            
            display: flex;
            align-items: center;
            justify-content: center;
            
            box-shadow: -5px 5px 15px rgba(0,0,0,0.5);
            margin-right: -2px; /* Overlap border slightly */
            
            /* Vertical Text */
            writing-mode: vertical-rl;
            text-orientation: mixed;
            font-size: 12px;
            font-weight: bold;
            letter-spacing: 2px;
        }
        
        #dock-toggle:hover {
            background: var(--primary);
            color: #000;
        }
        
        /* ========================================
           MODERN TOWER SELECTION UI - REDESIGNED
           ======================================== */
        
        /* 3. THE PANEL (Slim Portrait Mode) */
        #tower-panel {
            position: relative; /* Sit inside the flex dock */
            width: 280px;       /* SLIM WIDTH (Portrait) */
            height: 500px;      /* TALL HEIGHT */
            max-height: 60vh;
            
            background: var(--panel-bg);
            padding: 15px;
            
            /* Connected borders */
            border: 2px solid;
            border-image: linear-gradient(135deg, var(--primary), var(--secondary)) 1;
            border-right: none; /* Flush with screen edge */
            border-radius: 10px 0 0 10px;
            
            box-shadow: -10px 10px 40px rgba(0,0,0,0.8);
            backdrop-filter: blur(15px);
            
            display: flex;
            flex-direction: column;
            margin-top: 0;
            animation: none; /* Remove slide-up animation */
        }
        
        @keyframes slideUpIn {
            from { transform: translateX(-50%) translateY(100px); opacity: 0; }
            to { transform: translateX(-50%) translateY(0); opacity: 1; }
        }
        
        /* Tower Panel Header */
        #tower-panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid rgba(230, 126, 34, 0.3);
        }
        
        #tower-panel-title {
            font-size: 18px;
            font-weight: 900;
            color: var(--primary);
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(230, 126, 34, 0.6);
        }
        
        /* Category Tabs */
        #tower-categories {
            display: flex;
            gap: 8px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .category-tab {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 20px;
            color: #ccc;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .category-tab:hover {
            background: rgba(230, 126, 34, 0.2);
            border-color: var(--primary);
            color: #fff;
            transform: translateY(-2px);
        }
        
        .category-tab.active {
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.4), rgba(211, 84, 0, 0.4));
            border-color: var(--primary);
            color: #fff;
            box-shadow: 0 0 15px rgba(230, 126, 34, 0.5);
        }
        
        /* Search Bar */
        #tower-search-container {
            margin-bottom: 15px;
        }
        
        #tower-search {
            width: 100%;
            padding: 12px 40px 12px 15px;
            background: rgba(0, 0, 0, 0.3);
            border: 2px solid rgba(230, 126, 34, 0.3);
            border-radius: 25px;
            color: #fff;
            font-family: 'Orbitron', sans-serif;
            font-size: 14px;
            outline: none;
            transition: all 0.3s;
        }
        
        #tower-search:focus {
            border-color: var(--primary);
            box-shadow: 0 0 20px rgba(230, 126, 34, 0.4);
            background: rgba(0, 0, 0, 0.5);
        }
        
        #tower-search::placeholder {
            color: #888;
        }
        
        /* Tower Grid Container */
        #tower-grid-container {
            max-height: 300px;
            overflow-y: auto;
            overflow-x: hidden;
            padding-right: 5px;
        }
        
        /* Custom Scrollbar */
        #tower-grid-container::-webkit-scrollbar {
            width: 8px;
        }
        
        #tower-grid-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }
        
        #tower-grid-container::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--primary), var(--secondary));
            border-radius: 10px;
        }
        
        #tower-grid-container::-webkit-scrollbar-thumb:hover {
            background: var(--primary);
        }
        
        /* 4. ADJUST GRID FOR SLIM WIDTH */
        #tower-grid {
            grid-template-columns: repeat(3, 1fr); /* 3 Columns only */
            gap: 8px;
        }
        
        /* Tower Button Card */
        /* Smaller buttons to fit 3 in a row */
        .tower-btn {
            min-height: 90px;
            min-width: 0; 
        }
        
        .tower-btn::before {
    	content: '';
    	position: absolute;
    	top: -50%;
    	left: 3000%; /* Change -50% to -150% to hide it completely */
    	width: 200%;
    	height: 200%;
    	background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
    	transform: rotate(45deg); /* This is the "rotated" part you saw */
    	transition: all 0.6s;
    	pointer-events: none;
	}
        
        .tower-btn:hover::before {
            left: 100%;
        }
        
        .tower-btn:hover {
            background: linear-gradient(135deg, rgba(60, 60, 80, 0.9), rgba(40, 40, 60, 1));
            transform: translateY(-5px) scale(1.05);
            border-color: var(--primary);
            box-shadow: 0 8px 25px rgba(230, 126, 34, 0.5);
            z-index: 10;
        }
        
        .tower-btn.selected {
            border-color: var(--primary);
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.3), rgba(211, 84, 0, 0.3));
            box-shadow: 0 0 25px rgba(230, 126, 34, 0.8), inset 0 0 20px rgba(230, 126, 34, 0.2);
            transform: scale(1.08);
            z-index: 11;
        }
        
        .tower-btn.disabled {
            opacity: 0.4;
            cursor: not-allowed;
            filter: grayscale(1);
        }
        
        .tower-btn.disabled:hover {
            transform: none;
            border-color: rgba(230, 126, 34, 0.3);
            box-shadow: none;
        }
        
        /* Tower Icon */
        .tower-preview {
            width: 45px;
            height: 45px;
        }
        
        /* Tower Info */
        .tower-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 4px;
            width: 100%;
        }
        
        .tower-name { font-size: 10px; }
        
        .tower-cost {
            font-size: 13px;
            color: var(--success);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(46, 204, 113, 0.8);
        }
        
        .tower-cost.expensive {
            color: var(--accent);
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.8);
        }
        
        /* Tower Category Badge */
        .tower-category-badge {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 8px;
            padding: 2px 6px;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 10px;
            color: #fff;
            text-transform: uppercase;
            font-weight: bold;
        }
        
        /* Tower Hotkey Badge */
        .tower-hotkey {
            position: absolute;
            top: 5px;
            left: 5px;
            font-size: 10px;
            padding: 3px 6px;
            background: rgba(52, 152, 219, 0.8);
            border-radius: 5px;
            color: #fff;
            font-weight: bold;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        
        /* Empty State */
        #tower-empty-state {
            text-align: center;
            padding: 40px 20px;
            color: #888;
            font-size: 14px;
            display: none;
        }
        
        #tower-empty-state i {
            font-size: 48px;
            margin-bottom: 10px;
            display: block;
            opacity: 0.3;
        }

        /* Modern Inspection Panel */
        #inspect-panel {
            position: absolute; right: 20px; top: 50%; transform: translateY(-50%);
            width: 260px; 
            background: var(--panel-bg);
            padding: 25px; 
            border-radius: 20px; 
            border: 2px solid;
            border-image: linear-gradient(135deg, var(--primary), var(--secondary)) 1;
            color: white; 
            pointer-events: auto; 
            display: none;
            box-shadow: -10px 10px 40px rgba(0,0,0,0.8), inset 0 0 30px rgba(230, 126, 34, 0.1);
            backdrop-filter: blur(15px);
            animation: slideInRight 0.4s ease-out;
        }
        
        #ins-header { 
            border-bottom: 2px solid;
            border-image: linear-gradient(90deg, var(--primary), transparent) 1;
            padding-bottom: 12px; 
            margin-bottom: 18px;
        }
        
        .stat-row { 
            display: flex; 
            justify-content: space-between; 
            margin-bottom: 10px; 
            font-size: 13px; 
            color: #ccc;
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-val { 
            color: var(--primary);
            font-weight: bold;
            text-shadow: 0 0 10px rgba(230, 126, 34, 0.5);
        }
        
        .action-group { 
            display: flex; 
            gap: 12px; 
            margin-top: 18px;
        }
        
        .action-btn { 
            flex: 1; 
            padding: 12px; 
            border: none; 
            border-radius: 10px; 
            font-weight: bold; 
            cursor: pointer; 
            color: white; 
            transition: all 0.3s;
            font-size: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        
        .btn-up { 
            background: linear-gradient(135deg, #27ae60, #229954);
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.4);
        }
        
        .btn-up:hover { 
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 6px 20px rgba(46, 204, 113, 0.6);
            transform: translateY(-2px);
        }
        
        .btn-up:disabled { 
            background: linear-gradient(135deg, #555, #444);
            color: #888; 
            cursor: default;
            box-shadow: none;
            opacity: 0.5;
        }
        
        .btn-sell { 
            background: linear-gradient(135deg, #c0392b, #a93226);
            box-shadow: 0 4px 15px rgba(192, 57, 43, 0.4);
        }
        
        .btn-sell:hover { 
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.6);
            transform: translateY(-2px);
        }

        /* Epic Fullscreen Modals */
        .fullscreen-modal {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, rgba(10, 14, 39, 0.95), rgba(0, 0, 0, 0.98));
            backdrop-filter: blur(15px);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: white; pointer-events: auto; z-index: 100;
            animation: fadeIn 0.5s ease-out;
        }
        
        /* Neon Animated Title */
        h1.title-text { 
            font-size: 90px; 
            margin: 0 0 40px 0; 
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 8px;
            text-shadow: 
                0 0 10px rgba(230, 126, 34, 1),
                0 0 20px rgba(230, 126, 34, 0.8),
                0 0 40px rgba(230, 126, 34, 0.6),
                0 0 80px rgba(230, 126, 34, 0.4),
                0 0 120px rgba(230, 126, 34, 0.2);
            text-align: center;
            font-weight: 900;
            animation: titleGlow 3s ease-in-out infinite, floatTitle 4s ease-in-out infinite;
            background: linear-gradient(45deg, #e67e22, #f39c12, #e67e22);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        @keyframes titleGlow {
            0%, 100% {
                text-shadow: 
                    0 0 10px rgba(230, 126, 34, 1),
                    0 0 20px rgba(230, 126, 34, 0.8),
                    0 0 40px rgba(230, 126, 34, 0.6);
            }
            50% {
                text-shadow: 
                    0 0 20px rgba(230, 126, 34, 1),
                    0 0 40px rgba(230, 126, 34, 1),
                    0 0 80px rgba(230, 126, 34, 0.8),
                    0 0 120px rgba(230, 126, 34, 0.6);
            }
        }
        
        @keyframes floatTitle {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }
        
        /* Modern Map Cards */
        .map-container { 
            display: flex; 
            gap: 25px; 
            margin-top: 30px auto 0 auto;
            flex-wrap: wrap; 
            justify-content: center;
	    max-width: 100%;
        }
        
        .map-card {
            background: var(--panel-bg);
            border: 2px solid;
            border-image: linear-gradient(135deg, var(--primary), var(--secondary)) 1;
            width: 240px; 
            padding: 25px;
            border-radius: 16px; 
            cursor: pointer; 
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            box-shadow: 0 8px 30px rgba(0,0,0,0.6);
            position: relative;
            overflow: hidden;
        }
        
        .map-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s;
        }
        
        .map-card:hover::before {
            left: 100%;
        }
        
        .map-card:hover { 
            transform: translateY(-10px) scale(1.05);
            border-image: linear-gradient(135deg, var(--secondary), var(--primary)) 1;
            box-shadow: 0 15px 50px rgba(230, 126, 34, 0.5);
        }
        
        .map-title { 
            font-size: 22px; 
            font-weight: bold; 
            color: var(--primary);
            display: block; 
            margin-bottom: 15px;
            text-shadow: 0 0 10px rgba(230, 126, 34, 0.8);
        }
        
        .map-desc { 
            font-size: 13px; 
            color: #bbb;
            line-height: 1.6;
        }

        /* Settings Rows */
        .settings-tabs { display: flex; gap: 10px; margin-bottom: 20px; }
        
        .tab-btn {
            background: #222; color: #888; border: 1px solid #444;
            padding: 10px 20px; font-family: 'Orbitron', sans-serif;
            font-weight: bold; cursor: pointer; border-radius: 5px;
            transition: all 0.2s; text-transform: uppercase;
            flex: 1; /* Make tabs equal width */
            text-align: center;
        }
        .tab-btn:hover { background: #333; color: #fff; }
        .tab-btn.active {
            background: var(--primary); color: #fff; border-color: #fff;
            box-shadow: 0 0 15px var(--primary);
        }

        /* The Main Box - Fixed Size to prevent jumping */
        .settings-content {
            background: rgba(0,0,0,0.6); 
            padding: 30px; 
            border-radius: 12px;
            border: 1px solid #444; 
            width: 400px;        /* Fixed Width */
            height: 320px;       /* Fixed Height */
            display: flex; 
            flex-direction: column; 
            align-items: center;
            justify-content: flex-start; /* Start from top */
            backdrop-filter: blur(10px);
        }

        /* Perfect Alignment for Rows */
        .setting-row { 
            display: flex; 
            justify-content: space-between; /* Push Label Left, Control Right */
            align-items: center;
            width: 100%;         /* Fill the box */
            margin-bottom: 15px; 
            height: 40px;        /* Fixed row height */
        }
        
        .setting-label { 
            color: #fff; 
            font-weight: bold; 
            font-size: 16px;
            text-align: left;
        }

        /* Force Controls (Sliders & Buttons) to align */
        .settings-content input[type=range] { 
            width: 140px !important; 
            margin: 0;
        }
        
        /* Special class for Settings Buttons to make them match sliders */
        .settings-content .btn {
            width: 140px !important;  /* Match slider width */
            padding: 8px 0 !important; /* Slimmer vertical padding */
            font-size: 14px;
            text-align: center;
            display: flex; justify-content: center; align-items: center;
            margin: 0 !important; /* Remove defaults */
        }
        
        /* Sliders */
        input[type=range] { width: 150px; cursor: pointer; }

        /* In-Game Menu Button */
        #menu-btn {
            position: absolute; top: 20px; right: 20px;
            background: var(--panel-bg);
            border: 2px solid var(--primary);
            color: var(--primary);
            padding: 12px 20px; 
            border-radius: 12px;
            cursor: pointer; 
            pointer-events: auto; 
            font-weight: bold; 
            display: none;
            box-shadow: 0 4px 15px rgba(230, 126, 34, 0.4);
            transition: all 0.3s;
        }
        
        #menu-btn:hover { 
            background: linear-gradient(135deg, rgba(230, 126, 34, 0.3), rgba(52, 152, 219, 0.3));
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(230, 126, 34, 0.6);
        }

        /* Pause Menu */
        .pause-menu-content {
            background: var(--panel-bg);
            padding: 50px; 
            border-radius: 20px; 
            border: 2px solid;
            border-image: linear-gradient(135deg, var(--primary), var(--secondary)) 1;
            display: flex; 
            flex-direction: column; 
            gap: 20px; 
            width: 350px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.8), inset 0 0 40px rgba(230, 126, 34, 0.1);
        }

        #author-tag {
            position: absolute; bottom: 15px; right: 15px;
            font-size: 14px; color: rgba(255,255,255,0.4);
            pointer-events: none; font-weight: bold; z-index: 1000;
        }

        #controls-hint { position: absolute; bottom: 20px; right: 20px; color: #777; font-size: 12px; pointer-events: none; display: none;}

        /* Modern Almanac */
        .almanac-tabs { 
            display: flex; 
            gap: 15px; 
            margin-bottom: 25px;
        }
        
        .almanac-grid { 
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            gap: 15px; 
            max-height: 450px; 
            overflow-y: auto; 
            padding: 15px;
            background: var(--panel-bg);
            border-radius: 12px; 
            width: 650px;
            border: 2px solid;
            border-image: linear-gradient(135deg, var(--primary), var(--secondary)) 1;
            box-shadow: inset 0 0 30px rgba(230, 126, 34, 0.1);
        }
        
        .almanac-item { 
            background: linear-gradient(135deg, rgba(40, 40, 60, 0.8), rgba(20, 20, 40, 0.9));
            padding: 12px; 
            border-radius: 12px; 
            cursor: pointer; 
            text-align: center; 
            border: 2px solid rgba(230, 126, 34, 0.3);
            display: flex; 
            flex-direction: column; 
            align-items: center;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }
        
        .almanac-item::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transform: rotate(45deg);
            transition: all 0.6s;
        }
        
        .almanac-item:hover::before {
            left: 100%;
        }
        
        .almanac-item:hover { 
            background: linear-gradient(135deg, rgba(60, 60, 80, 0.9), rgba(40, 40, 60, 1));
            border-color: var(--primary);
            transform: translateY(-5px) scale(1.05);
            box-shadow: 0 10px 30px rgba(230, 126, 34, 0.4);
        }
        
        .almanac-item.locked { 
            opacity: 0.4; 
            cursor: default;
            filter: grayscale(1);
        }
        
        .almanac-item.locked:hover {
            transform: none;
            border-color: rgba(230, 126, 34, 0.3);
        }
        
        .almanac-details {
            margin-top: 25px; 
            padding: 25px; 
            background: var(--panel-bg);
            border: 2px solid;
            border-image: linear-gradient(135deg, var(--primary), var(--secondary)) 1;
            border-radius: 12px; 
            width: 650px; 
            display: none; 
            max-height: 250px; 
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0,0,0,0.6), inset 0 0 30px rgba(230, 126, 34, 0.1);
        }
        
        /* Custom Scrollbar */
        .almanac-grid::-webkit-scrollbar,
        .almanac-details::-webkit-scrollbar {
            width: 10px;
        }
        
        .almanac-grid::-webkit-scrollbar-track,
        .almanac-details::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
        }
        
        .almanac-grid::-webkit-scrollbar-thumb,
        .almanac-details::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, var(--primary), var(--secondary));
            border-radius: 10px;
        }
        
        .almanac-grid::-webkit-scrollbar-thumb:hover,
        .almanac-details::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, var(--secondary), var(--primary));
        }

        /* ========== MOBILE FIXES ========== */
        @media (max-width: 768px) {
            /* Fix title size */
            h1.title-text {
                font-size: 48px;
            }

            /* Fix button sizes */
            .btn {
                font-size: 16px;
                padding: 14px 24px;
                min-height: 50px;
            }

            /* Fix map cards */
            .map-card {
                width: 85vw;
                max-width: 320px;
            }

            /* Fix tower dock */
            #tower-dock {
                bottom: 10px;
            }

            #tower-panel {
                padding: 12px;
                gap: 8px;
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }

            .tower-btn {
                min-width: 70px;
                width: 70px;
                height: 90px;
                flex-shrink: 0;
            }

            .tower-preview {
                width: 50px;
                height: 50px;
            }

            .tower-name {
                font-size: 9px;
            }

            .tower-cost {
                font-size: 11px;
            }

            /* Fix stats bar */
            #stats-bar {
                flex-wrap: wrap;
                max-width: 65vw;
            }

            .stat-pill {
                font-size: 12px;
                padding: 8px 16px;
            }

            /* Fix inspect panel */
            #inspect-panel {
                width: 85vw;
                max-width: 300px;
                left: 50%;
                right: auto;
                transform: translateX(-50%) translateY(-50%);
                font-size: 12px;
            }

            .stat-row {
                font-size: 12px;
            }

            .action-btn {
                font-size: 12px;
                padding: 12px;
            }

            /* Fix game info panel */
            #game-info-panel {
                width: 180px;
                font-size: 11px;
                top: 65px;
            }

            .info-header {
                font-size: 13px;
            }

            /* Better modal content */
            .fullscreen-modal {
                padding: 20px;
            }

            h2 {
                font-size: 24px;
            }

            /* Almanac */
            .almanac-item {
                width: 100px !important;
                height: 120px !important;
            }
        }

        @media (max-width: 480px) {
            h1.title-text {
                font-size: 36px;
            }

            .btn {
                font-size: 14px;
                padding: 12px 20px;
            }

            .tower-btn {
                width: 65px;
                min-width: 65px;
                height: 85px;
            }

            .tower-preview {
                width: 45px;
                height: 45px;
            }

            #game-info-panel {
                width: 160px;
                font-size: 10px;
            }

            .stat-pill {
                font-size: 11px;
                padding: 7px 14px;
            }
        }

        /* Landscape mode fixes */
        @media (max-height: 600px) and (orientation: landscape) {
            h1.title-text {
                font-size: 32px;
                margin-bottom: 15px;
            }

            .btn {
                padding: 10px 20px;
                min-height: 42px;
            }

            #inspect-panel {
                bottom: 100px;
            }

            .fullscreen-modal {
                padding-top: 20px;
            }
        }
	/* --- FIX FOR WHITE IMAGES / GHOSTING --- */
	.tower-preview {
    	/* 1. Force the background to be dark (failsafe) */
    	background-color: #222 !important;
    
    	/* 2. Make the image ignore all mouse events */
    	/* This stops you from dragging it or highlighting it */
    	pointer-events: none !important;
    	user-select: none !important;
    	-webkit-user-drag: none !important;
    
    	/* 3. Ensure it fits the box perfectly */
    	border-radius: 6px !important;
    	object-fit: cover !important;
	}

	/* If the image is broken (404), hide the ugly white broken-image icon */
	.tower-preview:not([src]), .tower-preview[src=""] {
   	opacity: 0;
	}
    

/* --- BRAWL STARS STYLE TROPHY ROAD --- */

#trophy-road-modal {
    position: fixed;
    top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0, 0, 0, 0.85);
    backdrop-filter: blur(8px);
    z-index: 20000; /* Above everything */
    display: none; /* Hidden by default */
    justify-content: center;
    align-items: center;
    font-family: 'Orbitron', sans-serif;
    pointer-events: auto;
}

.trophy-road-content {
    width: 90%;
    max-width: 600px;
    height: 80vh;
    background: linear-gradient(180deg, #1e3c72 0%, #152a55 100%); /* Deep Blue */
    border: 4px solid #000;
    border-radius: 20px;
    box-shadow: 
        inset 0 0 0 4px #4a90e2, /* Inner Light Blue Border */
        0 0 0 4px #000, 
        0 10px 30px rgba(0,0,0,0.5);
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
}

/* Header with that Yellow/Orange Gradient Text */
.trophy-road-header {
    background: #0d1b3a;
    padding: 20px;
    text-align: center;
    border-bottom: 4px solid #000;
    box-shadow: 0 4px 0 rgba(0,0,0,0.2);
    z-index: 2;
}

.trophy-road-title {
    font-size: 32px;
    font-weight: 900;
    color: #fff;
    text-transform: uppercase;
    /* The Brawl Stars Text Stroke Effect */
    text-shadow: 
        2px 2px 0 #000,
        -1px -1px 0 #000,  
        1px -1px 0 #000,
        -1px 1px 0 #000,
        1px 1px 0 #000;
    letter-spacing: 2px;
    background: linear-gradient(to bottom, #ffe259, #ffa751);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    filter: drop-shadow(0 4px 0 #000);
}

.trophy-road-subtitle {
    color: #4a90e2;
    font-size: 12px;
    margin-top: 5px;
    font-weight: 700;
    letter-spacing: 1px;
}

/* Scrolling Container */
#trophy-road-container {
    flex: 1;
    overflow-y: auto;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 15px;
    /* Custom Scrollbar */
    scrollbar-width: thin;
    scrollbar-color: #f1c40f #152a55;
}

/* Individual Milestones */
.trophy-milestone {
    display: flex;
    align-items: center;
    background: #2c3e50;
    border-radius: 12px;
    padding: 0;
    position: relative;
    border: 3px solid #000;
    transition: transform 0.2s;
    height: 80px;
    opacity: 0.7; /* Dimmed if locked */
    filter: grayscale(0.8);
}

/* THE CONNECTING LINE */
.trophy-milestone::before {
    content: '';
    position: absolute;
    top: -20px;
    left: 40px; /* Center of the badge */
    width: 6px;
    height: 20px;
    background: #000;
    z-index: -1;
}
.trophy-milestone:first-child::before { display: none; }

/* Unlocked State (Bright & Colorful) */
.trophy-milestone.unlocked {
    background: linear-gradient(135deg, #2980b9, #2c3e50);
    border-color: #000;
    opacity: 1;
    filter: none;
    box-shadow: 0 4px 0 #000;
    transform: translateY(-2px);
}

/* Current Level Highlight */
.trophy-milestone.unlocked:last-of-type {
    border: 3px solid #f1c40f;
    box-shadow: 0 0 15px #f1c40f, 0 4px 0 #000;
}

/* Level Badge (Left Side) */
.milestone-level {
    width: 80px;
    height: 100%;
    background: #152a55;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    font-weight: 900;
    font-size: 20px;
    border-right: 3px solid #000;
    position: relative;
}

.trophy-milestone.unlocked .milestone-level {
    background: #f1c40f; /* Yellow for unlocked */
    color: #000;
    text-shadow: none;
}

/* Rewards Section (Right Side) */
.milestone-rewards {
    flex: 1;
    padding: 0 20px;
    font-size: 14px;
    color: #fff;
    font-weight: 700;
    display: flex;
    align-items: center;
    gap: 10px;
}

/* Icon styling in text */
.milestone-rewards span {
    color: #f1c40f;
}

    /* Ensure menu buttons are never covered */
#main-menu .btn {
    position: relative;
    z-index: 5000;
    pointer-events: auto !important;
}



/* Map Category Tabs */
.category-tab {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid rgba(255, 255, 255, 0.3);
    color: #fff;
    padding: 10px 20px;
    font-size: 14px;
    font-weight: bold;
    border-radius: 20px;
    cursor: pointer;
    transition: all 0.3s;
    font-family: 'Orbitron', sans-serif;
    text-transform: uppercase;
}

.category-tab:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: var(--primary);
}

.category-tab.active {
    background: linear-gradient(135deg, var(--primary), var(--secondary));
    border-color: var(--primary);
    box-shadow: 0 4px 15px rgba(230, 126, 34, 0.5);
}

/* Map difficulty label */
.map-difficulty {
    display: block;
    font-size: 12px;
    font-weight: bold;
    margin-top: 8px;
    text-transform: uppercase;
}

/* Map credit label */
.map-credit {
    display: block;
    font-size: 10px;
    color: #aaa;
    margin-top: 5px;
    font-style: italic;
}

</style>
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <style>
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
    </style>
    </head>

	<!-- LZ-String for compression -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/lz-string/1.4.4/lz-string.min.js"></script>

<!-- Map Creator System -->
<script src="map-creator-system.js"></script>
<script src="map-editor-integration.js"></script>

	<!-- ============================================================================
MAP EDITOR UI COMPONENTS
Add this to your index.html inside the <body> tag
============================================================================ -->

<style>

/* Region Selector Styles */
.region-item {
    background: rgba(255, 255, 255, 0.03);
    border: 2px solid rgba(255, 255, 255, 0.1);
    border-radius: 12px;
    padding: 18px 20px;
    cursor: pointer;
    transition: all 0.3s ease;
    user-select: none;
}

.region-item:hover {
    background: rgba(255, 255, 255, 0.08);
    border-color: rgba(0, 255, 136, 0.5);
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(0, 255, 136, 0.2);
}

.region-item.region-selected {
    background: rgba(0, 255, 136, 0.15);
    border-color: #00ff88;
    box-shadow: 0 5px 25px rgba(0, 255, 136, 0.4);
}

.region-header {
    display: flex;
    align-items: center;
    gap: 15px;
}

.region-status-dot {
    width: 14px;
    height: 14px;
    border-radius: 50%;
    background: #666;
    box-shadow: 0 0 5px #666;
    transition: all 0.3s ease;
    flex-shrink: 0;
}

.region-info {
    flex: 1;
    text-align: left;
}

.region-name {
    font-size: 18px;
    font-weight: bold;
    color: white;
    margin-bottom: 3px;
}

.region-description {
    font-size: 13px;
    color: #888;
}

.region-ping {
    font-size: 18px;
    font-weight: bold;
    color: #aaa;
    min-width: 90px;
    text-align: right;
    flex-shrink: 0;
}

/* Pulsing animation for selected region */
.region-item.region-selected .region-status-dot {
    animation: region-pulse 2s infinite;
}

@keyframes region-pulse {
    0%, 100% {
        box-shadow: 0 0 10px rgba(0, 255, 136, 0.6);
    }
    50% {
        box-shadow: 0 0 20px rgba(0, 255, 136, 1);
    }
}

/* Toast slide-down animation */
@keyframes slideDown {
    from {
        transform: translateX(-50%) translateY(-100px);
        opacity: 0;
    }
    to {
        transform: translateX(-50%) translateY(0);
        opacity: 1;
    }
}

/* Server status dot in lobby (connected state) */
.server-status-dot-connected {
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: #00ff00;
    box-shadow: 0 0 12px #00ff00;
    animation: server-connected-pulse 2s infinite;
}

@keyframes server-connected-pulse {
    0%, 100% {
        box-shadow: 0 0 12px rgba(0, 255, 0, 0.8);
    }
    50% {
        box-shadow: 0 0 18px rgba(0, 255, 0, 1);
    }
}

/* Responsive design for smaller screens */
@media (max-width: 768px) {
    .region-item {
        padding: 15px;
    }
    
    .region-name {
        font-size: 16px;
    }
    
    .region-description {
        font-size: 12px;
    }
    
    .region-ping {
        font-size: 16px;
        min-width: 70px;
    }
}

/* Map Editor Container */
#map-editor-ui {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none; /* Hidden by default */
    pointer-events: none;
    z-index: 5000;
    font-family: Arial, sans-serif;
}

#map-editor-ui.active {
    display: block;
}

#map-editor-ui * {
    pointer-events: auto;
}

/* Toolbar (Top) */
.editor-toolbar {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid #00ff88;
    border-radius: 12px;
    padding: 15px 20px;
    display: flex;
    gap: 15px;
    align-items: center;
}

.editor-toolbar h2 {
    margin: 0;
    color: #00ff88;
    font-size: 18px;
    font-weight: bold;
}

.editor-toolbar button {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    padding: 10px 20px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 14px;
    font-weight: bold;
    transition: all 0.3s;
}

.editor-toolbar button:hover {
    transform: scale(1.05);
    box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
}

.editor-toolbar button.active {
    background: #00ff88;
    color: #000;
}

.editor-toolbar button.danger {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
}

/* Left Panel (Tools & Objects) */
.editor-left-panel {
    position: absolute;
    left: 20px;
    top: 100px;
    width: 280px;
    max-height: calc(100vh - 120px);
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ff88;
    border-radius: 12px;
    overflow-y: auto;
}

.panel-section {
    padding: 15px;
    border-bottom: 1px solid #333;
}

.panel-section h3 {
    margin: 0 0 10px 0;
    color: #00ff88;
    font-size: 14px;
    text-transform: uppercase;
}

.tool-grid {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: 10px;
}

.tool-button {
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid transparent;
    border-radius: 8px;
    padding: 15px;
    cursor: pointer;
    text-align: center;
    transition: all 0.3s;
    color: white;
}

.tool-button:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #00ff88;
}

.tool-button.selected {
    background: rgba(0, 255, 136, 0.3);
    border-color: #00ff88;
}

.tool-button .icon {
    font-size: 32px;
    margin-bottom: 5px;
}

.tool-button .label {
    font-size: 12px;
}

.decoration-grid {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
}

.deco-item {
    aspect-ratio: 1;
    background: rgba(255, 255, 255, 0.1);
    border: 2px solid transparent;
    border-radius: 6px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.3s;
}

.deco-item:hover {
    background: rgba(255, 255, 255, 0.2);
    border-color: #00ff88;
}

.deco-item.selected {
    background: rgba(0, 255, 136, 0.3);
    border-color: #00ff88;
}

.deco-item .emoji {
    font-size: 24px;
}

.deco-item .name {
    font-size: 10px;
    color: #aaa;
    margin-top: 4px;
}

/* Right Panel (Settings) */
.editor-right-panel {
    position: absolute;
    right: 20px;
    top: 100px;
    width: 300px;
    max-height: calc(100vh - 120px);
    background: rgba(0, 0, 0, 0.9);
    border: 2px solid #00ff88;
    border-radius: 12px;
    overflow-y: auto;
}

.settings-item {
    padding: 12px;
    border-bottom: 1px solid #333;
}

.settings-item label {
    display: block;
    color: #aaa;
    font-size: 12px;
    margin-bottom: 5px;
}

.settings-item input[type="text"],
.settings-item input[type="color"] {
    width: 100%;
    padding: 8px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid #444;
    border-radius: 6px;
    color: white;
    font-size: 14px;
}

.settings-item input[type="range"] {
    width: 100%;
}

.settings-item input[type="color"] {
    height: 40px;
    cursor: pointer;
}

.color-presets {
    display: flex;
    gap: 5px;
    margin-top: 5px;
}

.color-preset {
    width: 30px;
    height: 30px;
    border-radius: 6px;
    border: 2px solid transparent;
    cursor: pointer;
    transition: all 0.3s;
}

.color-preset:hover {
    border-color: #00ff88;
    transform: scale(1.1);
}

.settings-value {
    display: inline-block;
    margin-left: 10px;
    color: #00ff88;
    font-weight: bold;
}

/* Bottom Panel (Actions) */
.editor-bottom-panel {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid #00ff88;
    border-radius: 12px;
    padding: 15px 20px;
    display: flex;
    gap: 15px;
}

.editor-bottom-panel button {
    padding: 12px 24px;
    font-size: 14px;
    font-weight: bold;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.3s;
}

.btn-test {
    background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    color: white;
}

.btn-save {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
}

.btn-load {
    background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
    color: #333;
}

.btn-share {
    background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    color: white;
}

.btn-exit {
    background: rgba(255, 0, 0, 0.3);
    color: white;
    border: 2px solid #ff0000;
}

/* Info Panel (Top Right) */
.editor-info {
    position: absolute;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid #00ff88;
    border-radius: 12px;
    padding: 15px;
    min-width: 200px;
}

.info-stat {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
    font-size: 13px;
}

.info-stat .label {
    color: #aaa;
}

.info-stat .value {
    color: #00ff88;
    font-weight: bold;
}

/* Modal for Share Code */
.editor-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.9);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 10000;
}

.editor-modal.active {
    display: flex;
}

.modal-content {
    background: #1a1a1a;
    border: 2px solid #00ff88;
    border-radius: 12px;
    padding: 30px;
    max-width: 600px;
    width: 90%;
}

.modal-content h2 {
    margin: 0 0 20px 0;
    color: #00ff88;
}

.modal-content textarea {
    width: 100%;
    height: 150px;
    background: rgba(255, 255, 255, 0.1);
    border: 1px solid #444;
    border-radius: 6px;
    padding: 10px;
    color: white;
    font-family: monospace;
    font-size: 12px;
    resize: none;
}

.modal-actions {
    margin-top: 20px;
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

.modal-actions button {
    padding: 10px 20px;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-weight: bold;
}

/* Scrollbar styling */
.editor-left-panel::-webkit-scrollbar,
.editor-right-panel::-webkit-scrollbar {
    width: 8px;
}

.editor-left-panel::-webkit-scrollbar-track,
.editor-right-panel::-webkit-scrollbar-track {
    background: rgba(0, 0, 0, 0.5);
}

.editor-left-panel::-webkit-scrollbar-thumb,
.editor-right-panel::-webkit-scrollbar-thumb {
    background: #00ff88;
    border-radius: 4px;
}

/* Shortcuts Help */
.shortcuts-help {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid #00ff88;
    border-radius: 12px;
    padding: 15px;
    font-size: 12px;
    color: #aaa;
}

.shortcuts-help h4 {
    margin: 0 0 10px 0;
    color: #00ff88;
    font-size: 14px;
}

.shortcuts-help .shortcut {
    margin-bottom: 5px;
}

.shortcuts-help kbd {
    background: rgba(255, 255, 255, 0.1);
    padding: 2px 6px;
    border-radius: 3px;
    color: white;
    font-family: monospace;
}

/* Toggle button for shortcuts */
.toggle-shortcuts {
    position: absolute;
    bottom: 20px;
    left: 20px;
    background: rgba(0, 0, 0, 0.85);
    border: 2px solid #00ff88;
    border-radius: 50%;
    width: 50px;
    height: 50px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 24px;
    transition: all 0.3s;
}

.toggle-shortcuts:hover {
    transform: scale(1.1);
    background: rgba(0, 255, 136, 0.3);
}
</style>

<!-- Map Editor UI Container -->
<div id="map-editor-ui">
    <!-- Top Toolbar -->
    <div class="editor-toolbar">
        <h2>🗺️ MAP CREATOR</h2>
        <button id="btn-editor-path" class="active" onclick="setEditorTool('path')">
            🛤️ PATH
        </button>
        <button id="btn-editor-deco" onclick="setEditorTool('decoration')">
            🌳 DECORATIONS
        </button>
        <button id="btn-editor-delete" onclick="setEditorTool('delete')">
            🗑️ DELETE
        </button>
        <button id="btn-symmetry" onclick="toggleSymmetry()">
            🔄 SYMMETRY: OFF
        </button>
        <button id="btn-clear-all" class="danger" onclick="clearAllMap()">
            ❌ CLEAR ALL
        </button>
    </div>
    
    <!-- Info Panel -->
    <div class="editor-info">
        <div class="info-stat">
            <span class="label">Path Length:</span>
            <span class="value" id="info-path-length">0</span>
        </div>
        <div class="info-stat">
            <span class="label">Decorations:</span>
            <span class="value" id="info-deco-count">0</span>
        </div>
        <div class="info-stat">
            <span class="label">Symmetry:</span>
            <span class="value" id="info-symmetry">OFF</span>
        </div>
        <div class="info-stat">
            <span class="label">Valid:</span>
            <span class="value" id="info-valid">❌</span>
        </div>
    </div>
    
    <!-- Left Panel (Tools & Objects) -->
    <div class="editor-left-panel">
        <div class="panel-section">
            <h3>📦 DECORATIONS</h3>
            <div class="decoration-grid">
                <div class="deco-item" onclick="selectDecoration('tree')">
                    <div class="emoji">🌲</div>
                    <div class="name">Tree</div>
                </div>
                <div class="deco-item" onclick="selectDecoration('rock')">
                    <div class="emoji">🪨</div>
                    <div class="name">Rock</div>
                </div>
                <div class="deco-item" onclick="selectDecoration('crystal')">
                    <div class="emoji">💎</div>
                    <div class="name">Crystal</div>
                </div>
                <div class="deco-item" onclick="selectDecoration('bush')">
                    <div class="emoji">🌿</div>
                    <div class="name">Bush</div>
                </div>
                <div class="deco-item" onclick="selectDecoration('flower')">
                    <div class="emoji">🌸</div>
                    <div class="name">Flower</div>
                </div>
                <div class="deco-item" onclick="selectDecoration('mushroom')">
                    <div class="emoji">🍄</div>
                    <div class="name">Mushroom</div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Right Panel (Environment Settings) -->
    <div class="editor-right-panel">
        <div class="panel-section">
            <h3>🎨 ENVIRONMENT</h3>
            
            <div class="settings-item">
                <label>Map Name:</label>
                <input type="text" id="setting-map-name" value="My Custom Map" onchange="updateMapName(this.value)">
            </div>
            
            <div class="settings-item">
                <label>Background Color:</label>
                <input type="color" id="setting-bg-color" value="#0a0a1a" onchange="updateBgColor(this.value)">
                <div class="color-presets" id="bg-presets"></div>
            </div>
            
            <div class="settings-item">
                <label>Floor Color:</label>
                <input type="color" id="setting-floor-color" value="#1e272e" onchange="updateFloorColor(this.value)">
            </div>
            
            <div class="settings-item">
                <label>Track Color:</label>
                <input type="color" id="setting-track-color" value="#808080" onchange="updateTrackColor(this.value)">
            </div>
            
            <div class="settings-item">
                <label>Particle Color:</label>
                <input type="color" id="setting-particle-color" value="#ffffff" onchange="updateParticleColor(this.value)">
            </div>
            
            <div class="settings-item">
                <label>
                    Particle Density:
                    <span class="settings-value" id="value-particle-density">50%</span>
                </label>
                <input type="range" id="setting-particle-density" min="0" max="100" value="50" 
                       oninput="updateParticleDensity(this.value)">
            </div>
            
            <div class="settings-item">
                <label>
                    Particle Speed:
                    <span class="settings-value" id="value-particle-speed">30%</span>
                </label>
                <input type="range" id="setting-particle-speed" min="0" max="100" value="30" 
                       oninput="updateParticleSpeed(this.value)">
            </div>
            
            <div class="settings-item">
                <label>Fog Color:</label>
                <input type="color" id="setting-fog-color" value="#000000" onchange="updateFogColor(this.value)">
            </div>
            
            <div class="settings-item">
                <label>
                    Fog Density:
                    <span class="settings-value" id="value-fog-density">30%</span>
                </label>
                <input type="range" id="setting-fog-density" min="0" max="100" value="30" 
                       oninput="updateFogDensity(this.value)">
            </div>
        </div>
    </div>
    
    <!-- Bottom Actions -->
    <div class="editor-bottom-panel">
        <button class="btn-test" onclick="testMap()">
            ▶️ TEST MAP
        </button>
        <button class="btn-save" onclick="saveMap()">
            💾 SAVE
        </button>
        <button class="btn-load" onclick="loadMap()">
            📂 LOAD
        </button>
        <button class="btn-share" onclick="shareMap()">
            🔗 SHARE CODE
        </button>
        <button class="btn-exit" onclick="exitEditor()">
            🚪 EXIT EDITOR
        </button>
    </div>
    
    <!-- Shortcuts Help (Collapsible) -->
    <div class="toggle-shortcuts" onclick="toggleShortcutsHelp()">
        ❓
    </div>
    
    <div class="shortcuts-help" id="shortcuts-panel" style="display: none;">
        <h4>⌨️ KEYBOARD SHORTCUTS</h4>
        <div class="shortcut"><kbd>Click</kbd> Place tile/decoration</div>
        <div class="shortcut"><kbd>Right Click</kbd> Delete</div>
        <div class="shortcut"><kbd>Ctrl+Z</kbd> Undo</div>
        <div class="shortcut"><kbd>Ctrl+Y</kbd> Redo</div>
        <div class="shortcut"><kbd>S</kbd> Toggle symmetry</div>
        <div class="shortcut"><kbd>Delete</kbd> Remove last tile</div>
    </div>
</div>

<!-- Share Code Modal -->
<div class="editor-modal" id="share-modal">
    <div class="modal-content">
        <h2>🔗 Share Your Map</h2>
        <p style="color: #aaa; font-size: 14px;">Copy this code and share it with friends!</p>
        <textarea id="share-code-input" readonly></textarea>
        <div class="modal-actions">
            <button onclick="copyShareCode()" style="background: #00ff88; color: #000;">
                📋 COPY
            </button>
            <button onclick="closeShareModal()" style="background: #666; color: white;">
                CLOSE
            </button>
        </div>
    </div>
</div>

<!-- Load Code Modal -->
<div class="editor-modal" id="load-modal">
    <div class="modal-content">
        <h2>📂 Load Map from Code</h2>
        <p style="color: #aaa; font-size: 14px;">Paste a share code to load a map:</p>
        <textarea id="load-code-input" placeholder="Paste share code here..."></textarea>
        <div class="modal-actions">
            <button onclick="loadFromCode()" style="background: #00ff88; color: #000;">
                ✅ LOAD
            </button>
            <button onclick="clearInterval(pingLoop); document.getElementById('region-selector-screen').style.display='none'; document.getElementById('menu').style.display='flex';" style="margin-top: 15px; background: transparent; border: 1px solid #444; color: #888; padding: 10px 30px; cursor: pointer;">
    	    CANCEL
	    </button>
        </div>
    </div>
</div>

<script>

// ============================================================================
// PART 1: GAME JOLT INITIALIZATION
// ============================================================================

// Game Jolt Credentials
const GAMEJOLT_GAME_ID = '1049499';
const GAMEJOLT_PRIVATE_KEY = 'e3a9ac5cee4e774548bbc80f2b184cd6';

// Initialize Game Jolt API
window.initGameJolt = function() {
    console.log('🎮 Initializing Game Jolt API...');
    
    // Check if GJAPI is loaded
    if (typeof GJAPI === 'undefined') {
        console.warn('⚠️ Game Jolt API not loaded. Skipping initialization.');
        return;
    }

    // Initialize with credentials
    GJAPI.init(GAMEJOLT_GAME_ID, GAMEJOLT_PRIVATE_KEY, '1.0', function(result) {
        if (result === 'SUCCESS') {
            console.log('✅ Game Jolt API initialized successfully');
            
            // Auto-login if user is on Game Jolt
            GJAPI.GetAutoLogin(function(username, token) {
                if (username && token) {
                    GJAPI.VerifyUser(username, token, function(loginResult) {
                        if (loginResult === 'SUCCESS') {
                            console.log(`✅ Logged in as: ${username}`);
                            window.GJAPI.bLoggedIn = true;
                            window.GJAPI.username = username;
                            
                            // Sync local achievements with Game Jolt
                            syncAchievementsToGameJolt();
                        } else {
                            console.log('⚠️ Auto-login failed');
                        }
                    });
                } else {
                    console.log('ℹ️ No auto-login available');
                }
            });
        } else {
            console.error('❌ Game Jolt API initialization failed');
        }
    });
};

// ============================================================================
// PART 2: TROPHY BRIDGE (Achievement Sync)
// ============================================================================

window.unlockTrophy = function(trophyID) {
    console.log(`🏆 Unlocking trophy: ${trophyID}`);
    
    // 1. Save locally
    const localTrophies = JSON.parse(localStorage.getItem('unlockedTrophies') || '[]');
    if (!localTrophies.includes(trophyID)) {
        localTrophies.push(trophyID);
        localStorage.setItem('unlockedTrophies', JSON.stringify(localTrophies));
    }

    // 2. Show visual popup (handled by progression.js showAchievementPopup)
    console.log(`✅ Trophy ${trophyID} saved locally`);

    // 3. Sync to Game Jolt (if logged in)
    if (window.GJAPI && window.GJAPI.bLoggedIn) {
        GJAPI.TrophyAchieve(trophyID, function(result) {
            if (result === 'SUCCESS') {
                console.log(`✅ Trophy ${trophyID} synced to Game Jolt`);
            } else {
                console.warn(`⚠️ Failed to sync trophy ${trophyID} to Game Jolt`);
            }
        });
    } else {
        console.log('ℹ️ Not logged into Game Jolt, trophy saved locally only');
    }
};

// ============================================================================
// PART 3: SYNC LOCAL ACHIEVEMENTS TO GAME JOLT
// ============================================================================

window.syncAchievementsToGameJolt = function() {
    if (!window.GJAPI || !window.GJAPI.bLoggedIn) {
        console.log('ℹ️ Cannot sync - not logged into Game Jolt');
        return;
    }

    console.log('🔄 Syncing local achievements to Game Jolt...');

    const localTrophies = JSON.parse(localStorage.getItem('unlockedTrophies') || '[]');
    const unlockedAchievements = window.unlockedAchievements || [];

    // Combine both sources
    const allUnlocked = [...new Set([...localTrophies, ...unlockedAchievements])];

    let syncCount = 0;
    allUnlocked.forEach(trophyID => {
        GJAPI.TrophyAchieve(trophyID, function(result) {
            if (result === 'SUCCESS') {
                syncCount++;
                console.log(`✅ Synced: ${trophyID}`);
            }
        });
    });

    console.log(`🔄 Synced ${syncCount} achievements to Game Jolt`);
};

// ============================================================================
// MAP EDITOR UI FUNCTIONS
// ============================================================================

function setEditorTool(tool) {
    if (!mapEditorState) return;
    mapEditorState.currentTool = tool;
    
    // Update button states
    document.querySelectorAll('.editor-toolbar button').forEach(btn => {
        btn.classList.remove('active');
    });
    document.getElementById('btn-editor-' + tool).classList.add('active');
    
    console.log('🛠️ Tool:', tool);
}

function toggleSymmetry() {
    if (!mapEditorState) return;
    mapEditorState.symmetryMode = !mapEditorState.symmetryMode;
    
    const btn = document.getElementById('btn-symmetry');
    btn.textContent = '🔄 SYMMETRY: ' + (mapEditorState.symmetryMode ? 'ON' : 'OFF');
    btn.classList.toggle('active', mapEditorState.symmetryMode);
    
    updateInfoPanel();
}

function selectDecoration(type) {
    if (!mapEditorState) return;
    mapEditorState.selectedDecoration = type;
    mapEditorState.currentTool = 'decoration';
    
    // Update UI
    document.querySelectorAll('.deco-item').forEach(item => {
        item.classList.remove('selected');
    });
    event.currentTarget.classList.add('selected');
    
    console.log('🌳 Selected decoration:', type);
}

function updateMapName(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.name = value;
}

function updateBgColor(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.bgColor = value;
    scene.background = new THREE.Color(value);
}

function updateFloorColor(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.floorColor = value;
    // Update floor mesh color if exists
}

function updateTrackColor(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.trackColor = value;
    mapEditorState.rebuildVisuals();
}

function updateParticleColor(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.particleColor = value;
}

function updateParticleDensity(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.particleDensity = value / 100;
    document.getElementById('value-particle-density').textContent = value + '%';
}

function updateParticleSpeed(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.particleSpeed = value / 100;
    document.getElementById('value-particle-speed').textContent = value + '%';
}

function updateFogColor(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.fogColor = value;
}

function updateFogDensity(value) {
    if (!mapEditorState) return;
    mapEditorState.mapData.settings.fogDensity = value / 100;
    document.getElementById('value-fog-density').textContent = value + '%';
}

function updateInfoPanel() {
    if (!mapEditorState) return;
    
    document.getElementById('info-path-length').textContent = mapEditorState.mapData.path.length;
    document.getElementById('info-deco-count').textContent = mapEditorState.mapData.decorations.length;
    document.getElementById('info-symmetry').textContent = mapEditorState.symmetryMode ? 'ON' : 'OFF';
    
    const validation = MapValidator.validate(mapEditorState.mapData);
    document.getElementById('info-valid').textContent = validation.valid ? '✅' : '❌';
}

function clearAllMap() {
    if (!mapEditorState) return;
    
    if (!confirm('⚠️ Clear entire map? This cannot be undone!')) return;
    
    mapEditorState.mapData.path = [];
    mapEditorState.mapData.decorations = [];
    mapEditorState.pathHead = null;
    mapEditorState.undoStack = [];
    mapEditorState.redoStack = [];
    mapEditorState.rebuildVisuals();
    updateInfoPanel();
}

function testMap() {
    const gameMap = testCustomMap();
    if (gameMap) {
        // Hide editor UI
        document.getElementById('map-editor-ui').classList.remove('active');
        
        // TODO: Start game with custom map
        alert('✅ Map valid! Ready to test.\n\n(Integration with startGame() needed)');
    }
}

function saveMap() {
    if (!mapEditorState) return;
    
    const slot = prompt('Enter save slot name:', 'my_map_' + Date.now());
    if (!slot) return;
    
    const success = MapStorage.saveMap(mapEditorState.mapData, slot);
    if (success) {
        alert('✅ Map saved to slot: ' + slot);
    }
}

function loadMap() {
    if (!mapEditorState) return;
    
    const slot = prompt('Enter save slot name to load:');
    if (!slot) return;
    
    const mapData = MapStorage.loadMap(slot);
    if (mapData) {
        mapEditorState.mapData = mapData;
        mapEditorState.rebuildVisuals();
        updateInfoPanel();
        alert('✅ Map loaded from slot: ' + slot);
    } else {
        alert('❌ No map found in slot: ' + slot);
    }
}

function shareMap() {
    if (!mapEditorState) return;
    
    const code = MapValidator.generateShareCode(mapEditorState.mapData);
    document.getElementById('share-code-input').value = code;
    document.getElementById('share-modal').classList.add('active');
}

function copyShareCode() {
    const input = document.getElementById('share-code-input');
    input.select();
    document.execCommand('copy');
    alert('✅ Share code copied to clipboard!');
}

function closeShareModal() {
    document.getElementById('share-modal').classList.remove('active');
}

function loadFromCode() {
    const code = document.getElementById('load-code-input').value.trim();
    if (!code) return;
    
    const mapData = MapValidator.loadFromShareCode(code);
    if (mapData) {
        mapEditorState.mapData = mapData;
        mapEditorState.rebuildVisuals();
        updateInfoPanel();
        closeLoadModal();
        alert('✅ Map loaded from share code!');
    } else {
        alert('❌ Invalid share code!');
    }
}

function closeLoadModal() {
    document.getElementById('load-modal').classList.remove('active');
}

function exitEditor() {
    if (!confirm('Exit editor? Unsaved changes will be lost.')) return;
    
    // Auto-save
    MapStorage.saveMap(mapEditorState.mapData, 'autosave');
    
    // Hide editor UI
    document.getElementById('map-editor-ui').classList.remove('active');
    mapEditorState.isActive = false;
    
    // TODO: Return to main menu
    goToMainMenu();
}

function toggleShortcutsHelp() {
    const panel = document.getElementById('shortcuts-panel');
    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
}

// Auto-update info panel
setInterval(() => {
    if (mapEditorState && mapEditorState.isActive) {
        updateInfoPanel();
    }
}, 500);
</script>


<body>

    <div id="ui-layer">
        
    <div id="achievements-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(8px); z-index: 2000000; justify-content: center; align-items: center; pointer-events: auto;">
        <div class="achievements-content" style="width: 500px; max-width: 90%; background: #1e293b; border: 4px solid #f1c40f; border-radius: 20px; overflow: hidden; display: flex; flex-direction: column; max-height: 80vh; position: relative; z-index: 2000001;">
            <div class="achievements-header" style="background: #0f172a; padding: 20px; text-align: center; border-bottom: 2px solid #f1c40f;">
                <div style="font-size: 24px; font-weight: 900; color: #f1c40f; text-shadow: 2px 2px 0 #000;">ACHIEVEMENTS</div>
            </div>
            <div id="achievements-list" style="padding: 20px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px;">
                </div>
            <div style="padding: 15px; background: #0f172a; border-top: 2px solid #f1c40f;">
                <button class="btn" onclick="closeAchievements()" style="width: 100%; background: #e74c3c;">CLOSE</button>
            </div>
        </div>
    </div>

	<!-- ============================================
     HTML START - Add this inside <div id="ui-layer">
     ============================================ -->

<!-- Skill Points Notification -->
<div id="skill-points-notify" onclick="openSkillTree()">
    🌟 SKILL POINT AVAILABLE! Click to spend
</div>

<!-- Achievement Popup -->
<div id="achievement-popup">
    <div class="achievement-icon">🏆</div>
    <div class="achievement-title">ACHIEVEMENT UNLOCKED!</div>
    <div id="achievement-desc-text" class="achievement-desc">Destroy 100 Enemies</div>
    <div id="achievement-reward-text" class="achievement-reward">Reward: 100 XP</div>
</div>

<!-- Level Up Popup -->
<div id="level-up-popup">
    <div class="levelup-header">
        <div class="levelup-title">LEVEL <span id="levelup-level">1</span></div>
        <div class="levelup-subtitle">⭐ REWARDS UNLOCKED ⭐</div>
    </div>
    <div id="levelup-rewards">
        <!-- Rewards will be inserted here -->
    </div>
    <button class="levelup-close-btn" onclick="closeLevelUpPopup()">CONTINUE</button>
</div>

<!-- Stats Panel (Top Right) -->
<div id="stats-panel">
    <div style="font-size: 16px; font-weight: bold; color: var(--secondary); margin-bottom: 10px; text-align: center;">
        SESSION STATS
    </div>
    <div class="stat-row">
        <span class="stat-label">Destroyed:</span>
        <span class="stat-value" id="stat-destroys">0</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">Damage:</span>
        <span class="stat-value" id="stat-damage">0</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">Income:</span>
        <span class="stat-value" id="stat-income">+0/wave</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">Interest:</span>
        <span class="stat-value" id="stat-interest">+0</span>
    </div>
    <div class="stat-row">
        <span class="stat-label">Win Streak:</span>
        <span class="stat-value" id="stat-streak">0</span>
    </div>
</div>

<!-- Ability Bar -->
<div id="ability-bar">
    <div class="ability-btn" id="ability-1" onclick="useAbility(1)">
        <div class="ability-icon">💰</div>
        <div class="ability-key">[1]</div>
        <div class="ability-cooldown"></div>
    </div>
    <div class="ability-btn" id="ability-2" onclick="useAbility(2)">
        <div class="ability-icon">⚡</div>
        <div class="ability-key">[2]</div>
        <div class="ability-cooldown"></div>
    </div>
    <div class="ability-btn" id="ability-3" onclick="useAbility(3)">
        <div class="ability-icon">❄️</div>
        <div class="ability-key">[3]</div>
        <div class="ability-cooldown"></div>
    </div>
    <div class="ability-btn" id="ability-4" onclick="useAbility(4)">
        <div class="ability-icon">🔥</div>
        <div class="ability-key">[4]</div>
        <div class="ability-cooldown"></div>
    </div>
</div>

<!-- Skill Tree Modal -->
<div id="skill-tree-modal">
    <div class="skill-tree-content">
        <div class="skill-tree-header">
            <div class="skill-tree-title">🌳 SKILL TREE</div>
            <div class="skill-points-display">
                ⭐ <span id="skill-points-count">0</span> Points
            </div>
        </div>

        <div id="skill-tree-container">
            <!-- Populated by updateSkillTree() -->
        </div>

        <button class="btn" onclick="closeSkillTree()" style="width: 100%; margin-top: 20px;">
            Close Skill Tree
        </button>
    </div>
</div>

<!-- Daily Challenges Panel -->
<!-- Daily Challenges Panel -->
<div id="challenges-panel" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.95); display: none; justify-content: center; align-items: center; z-index: 9997; pointer-events: auto;">
    <div class="challenges-content">
        <div class="skill-tree-header">
            <div class="skill-tree-title">🎯 DAILY CHALLENGES</div>
            <div id="challenges-refresh-timer" style="font-size: 12px; color: #aaa; margin-top: 5px;">Refreshes at 12:00 PM CET</div>
        </div>
        <div id="challenges-list"></div>
        <button class="btn" onclick="closeChallenges()" style="width: 100%; margin-top: 20px;">
            Close
        </button>
    </div>
</div>

	<div id="trophy-road-modal">
    <div class="trophy-road-content">
        <div class="trophy-road-header">
            <div class="trophy-road-title">PROGRESS ROAD</div>
            <div class="trophy-road-subtitle">COLLECT XP TO UNLOCK REWARDS</div>
        </div>
        
        <div id="trophy-road-container"></div>

        <div style="padding: 15px; background: #0d1b3a; border-top: 4px solid #000;">
            <button onclick="closeTrophyRoad()" style="
                width: 100%;
                padding: 15px;
                background: #e74c3c; /* Red Exit Button */
                border: 3px solid #000;
                border-radius: 10px;
                color: white;
                font-family: 'Orbitron', sans-serif;
                font-weight: 900;
                font-size: 18px;
                text-transform: uppercase;
                box-shadow: 0 4px 0 #c0392b;
                cursor: pointer;
                transition: 0.1s;
            " onmouseover="this.style.transform='translateY(-2px)'" 
               onmouseout="this.style.transform='translateY(0)'"
               onmousedown="this.style.transform='translateY(4px)'; this.style.boxShadow='none'">
                CLOSE
            </button>
        </div>
    </div>
</div>

<!-- HTML END -->
	
        <!-- Performance Stats -->
        <div id="performance-stats" style="position: absolute; bottom: 10px; left: 10px; display: flex; flex-direction: column; gap: 5px; pointer-events: none; z-index: 10000; align-items: flex-start;">
            <div class="perf-stat" id="fps-counter" style="background: rgba(0,0,0,0.7); color: #fff; padding: 4px 10px; border-radius: 12px; border: 1px solid #555; font-size: 10px; font-weight: bold;">FPS: 60</div>
            <div class="perf-stat" id="ping-counter" style="display:none; background: rgba(0,0,0,0.7); color: #fff; padding: 4px 10px; border-radius: 12px; border: 1px solid #555; font-size: 10px; font-weight: bold;">PING: 0ms</div>
            <div class="perf-stat" id="host-ping-counter" style="display:none; background: rgba(0,0,0,0.7); color: #fff; padding: 4px 10px; border-radius: 12px; border: 1px solid #555; font-size: 10px; font-weight: bold;">HOST: 0ms</div>
            <div class="perf-stat" id="server-location" style="display:none; background: rgba(0,0,0,0.7); color: #fff; padding: 4px 10px; border-radius: 12px; border: 1px solid #555; font-size: 10px; font-weight: bold;">📍 UNKNOWN</div>
        </div>

        <!-- Lag Warning -->
        <div id="lag-warning">
            ⚠️ CONNECTION ISSUES DETECTED ⚠️<br>
            <span style="font-size: 14px;">Host is experiencing high latency</span>
        </div>

        <!-- MP Warning Modal -->
        <div id="mp-warning-modal">
            <div class="mp-warning-content">
                <div class="mp-warning-title">⚠️ MULTIPLAYER NOTICE ⚠️</div>
                
                <div class="mp-warning-text">
                    <strong>IMPORTANT:</strong> This game uses <span class="mp-warning-highlight">peer-to-peer hosting</span>. 
                    The game runs entirely on the <span class="mp-warning-highlight">HOST's computer</span>, and all other 
                    players receive updates through the network.
                </div>

                <div class="mp-warning-section">
                    <h3>⚡ What This Means:</h3>
                    <ul>
                        <li>If the <strong>host's PC or internet is slow</strong>, <strong>everyone will lag</strong></li>
                        <li>The host's computer handles all game calculations</li>
                        <li>Players only receive position and action updates</li>
                        <li>Host performance directly affects all players</li>
                    </ul>
                </div>

                <div class="mp-warning-section"> <h3>💻 Recommended Host PC Specs (Max Settings):</h3> <ul> <li><strong>CPU:</strong> Modern 6-core (i5/Ryzen 5 or better, strong single-core)</li> <li><strong>RAM:</strong> 16GB minimum</li> <li><strong>GPU:</strong> Dedicated GPU (GTX 1060 / RX 580 or better)</li> <li><strong>Internet:</strong> 15+ Mbps upload speed</li> <li><strong>Connection:</strong> Wired ethernet required</li> </ul> </div>

                <div class="mp-warning-section">
                    <h3>🌐 Performance Tips:</h3>
                    <ul>
                        <li>Close other programs and browser tabs</li>
                        <li>Use a wired internet connection if possible</li>
                        <li>Choose servers geographically close to all players</li>
                        <li>Check your ping indicators during gameplay</li>
                        <li>Host should have stable internet (avoid downloads/streams)</li>
                    </ul>
                </div>

                <div class="mp-warning-text" style="margin-top: 20px; text-align: center;">
                    The game includes <span class="mp-warning-highlight">FPS, Ping, and Server Location indicators</span> 
                    to help you monitor performance in real-time.
                </div>

                <button class="btn btn-primary" onclick="closeMpWarning()" style="width: 100%; margin-top: 20px;">
                    I UNDERSTAND - CONTINUE
                </button>
            </div>
        </div>
        
	<!-- Multiplayer Name Menu -->
	<div id="mp-name-menu" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text">MULTIPLAYER</h1>
            <input type="text" id="player-name-input" placeholder="Enter Nickname" 
                   style="padding:15px; font-size:20px; border-radius:8px; border:none; text-align:center; width:250px; margin-bottom:20px;">
            <button class="btn btn-primary" style="width:200px;" onclick="playClick(); enterMpMenu()">CONTINUE</button>
            <button class="btn" style="width:200px; margin-top:10px;" onclick="playClick(); goToMainMenu()">BACK</button>
        </div>

	<!-- Region Selector Screen -->
<div id="region-selector-screen" class="fullscreen-modal" style="display:none;">
    <h1 class="title-text">SELECT SERVER REGION</h1>
    
    <div id="region-status-message" style="color: #aaa; font-size: 14px; margin-bottom: 25px; min-height: 20px;">
        Select a region to continue
    </div>
    
    <!-- Region List -->
    <div style="max-width: 700px; display: flex; flex-direction: column; gap: 15px; margin-bottom: 30px;">
        
        <!-- US West (Oregon) -->
        <div id="region-us-west" class="region-item" onclick="playClick(); selectRegion('us-west')">
            <div class="region-header">
                <div class="region-status-dot"></div>
                <div class="region-info">
                    <div class="region-name">🇺🇸 US West (Oregon)</div>
                    <div class="region-description">Best for West Coast USA & Canada</div>
                </div>
                <div class="region-ping">...</div>
            </div>
        </div>
        
        <!-- US East (Ohio) -->
        <div id="region-us-east-1" class="region-item" onclick="playClick(); selectRegion('us-east-1')">
            <div class="region-header">
                <div class="region-status-dot"></div>
                <div class="region-info">
                    <div class="region-name">🇺🇸 US East (Ohio)</div>
                    <div class="region-description">Best for Central & East USA</div>
                </div>
                <div class="region-ping">...</div>
            </div>
        </div>
        
        <!-- US East (Virginia) -->
        <div id="region-us-east-2" class="region-item" onclick="playClick(); selectRegion('us-east-2')">
            <div class="region-header">
                <div class="region-status-dot"></div>
                <div class="region-info">
                    <div class="region-name">🇺🇸 US East (Virginia)</div>
                    <div class="region-description">Best for East Coast USA & South America</div>
                </div>
                <div class="region-ping">...</div>
            </div>
        </div>
        
        <!-- EU Central (Frankfurt) -->
        <div id="region-eu-central" class="region-item" onclick="playClick(); selectRegion('eu-central')">
            <div class="region-header">
                <div class="region-status-dot"></div>
                <div class="region-info">
                    <div class="region-name">🇪🇺 EU Central (Frankfurt)</div>
                    <div class="region-description">Best for Europe, Middle East & Africa</div>
                </div>
                <div class="region-ping">...</div>
            </div>
        </div>
        
        <!-- Asia (Singapore) -->
        <div id="region-asia-southeast" class="region-item" onclick="playClick(); selectRegion('asia-southeast')">
            <div class="region-header">
                <div class="region-status-dot"></div>
                <div class="region-info">
                    <div class="region-name">🌏 Asia (Singapore)</div>
                    <div class="region-description">Best for Asia-Pacific & Oceania</div>
                </div>
                <div class="region-ping">...</div>
            </div>
        </div>
        
    </div>
    
    <!-- Selected Region Display -->
    <div style="
        background: rgba(0, 0, 0, 0.6);
        border: 2px solid #00ff88;
        border-radius: 12px;
        padding: 20px;
        margin-bottom: 25px;
        min-width: 350px;
    ">
        <div style="font-size: 14px; color: #888; margin-bottom: 8px;">SELECTED REGION:</div>
        <div id="selected-region-display">
            <div style="font-size: 16px; color: #666;">
                No region selected
            </div>
        </div>
    </div>
    
    <!-- Action Buttons -->
    <div style="display: flex; gap: 15px;">
        <button class="btn btn-primary" style="width:200px;" onclick="playClick(); proceedToMultiplayer()">
            CONNECT
        </button>
        <button class="btn" style="width:200px;" onclick="playClick(); goToMainMenu()">
            BACK
        </button>
    </div>
    
    <div style="margin-top: 20px; font-size: 12px; color: #666; max-width: 500px; text-align: center;">
        💡 Tip: The system auto-selects the region with the lowest latency, but you can manually choose another region to play with friends.
    </div>
</div>

	<!-- Multiplayer Menu -->
        <div id="mp-menu" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text">MULTIPLAYER</h1>
            
            <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 8px; border: 1px solid #555; max-width: 400px; text-align: center; margin-bottom: 20px;">
                <strong style="color: #f1c40f;">⚠️ SERVER NOTICE</strong>
                <p style="font-size: 14px; color: #ccc; margin: 5px 0 0 0;">
                    Free server sleeps when idle.<br>
                    If connection fails or hangs, <b>please wait 30-50 seconds</b> for the server to wake up and try again!
                </p>
            </div>

            <div style="display:flex; gap:20px;">
                <button class="btn btn-primary" style="width:150px; height:100px;" onclick="playClick(); hostGame()">HOST GAME</button>
                <button class="btn" style="width:150px; height:100px;" onclick="playClick(); showJoinInput()">JOIN GAME</button>
            </div>
            <div id="join-input-area" style="display:none; margin-top:20px; flex-direction:column; align-items:center;">
                <input type="text" id="room-code-input" placeholder="ROOM CODE" 
                       style="padding:10px; font-size:16px; width:150px; text-align:center; margin-bottom:10px;">
                <button class="btn btn-primary" onclick="playClick(); joinGame()">ENTER</button>
            </div>
            <button class="btn" style="margin-top:30px; width:200px;" onclick="playClick(); goToMainMenu()">BACK</button>
        </div>

	<!-- Multiplayer Lobby -->
        <div id="lobby-screen" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text">LOBBY</h1>
            <h2 id="lobby-room-code" style="color:var(--primary); font-size:40px; margin:0;">CODE: ????</h2>
            <div id="lobby-player-list" style="margin:30px 0; font-size:24px; color:#aaa;">
                Waiting for players...
            </div>
	    <div id="server-connection-info" style="
    background: rgba(0, 255, 136, 0.1);
    border: 1px solid rgba(0, 255, 136, 0.3);
    border-radius: 8px;
    padding: 12px;
    margin: 20px 0;
    max-width: 400px;
">
    <div style="font-size: 14px; color: #aaa;">
        Connecting to server...
    </div>
</div>
            <button id="lobby-start-btn" class="btn btn-primary" style="width:200px; display:none;" onclick="playClick(); showLevelSelectMP()">SELECT MAP</button>
            <p id="lobby-status" style="margin-top:10px; color:#777;">Waiting for Host to start...</p>
            <button class="btn" style="margin-top:20px; width:200px;" onclick="playClick(); leaveLobby()">LEAVE</button>
        </div>

	<!-- Multiplayer Gamemode -->
	<div id="mode-select" class="fullscreen-modal" style="display: none;">
            <h1 class="title-text">SELECT MODE</h1>
            <div class="map-container">
                <div class="map-card" onclick="playClick(); setGamemode('shared')">
                    <span class="map-title">Shared Gold</span>
                    <span class="map-desc">Both players use<br>the same wallet.</span>
                </div>
                <div class="map-card" onclick="playClick(); setGamemode('separate')">
                    <span class="map-title" style="color: #3498db">Separate Gold</span>
                    <span class="map-desc">Each player manages<br>their own money.</span>
                </div>
            </div>
            <button class="btn" style="margin-top: 30px;" onclick="leaveLobby()">BACK</button>
        </div>

	<div id="game-info-panel">
    		<div class="info-header" id="info-map-name">Map Name</div>
    		<div class="info-row"><span>Diff:</span> <span id="info-diff" style="color:#fff">Easy</span></div>
    		<div class="info-row"><span>Mode:</span> <span id="info-mode" style="color:#fff">Shared</span></div>
   		<div style="margin-top:8px; border-top:1px solid #444; padding-top:4px;">
    		    <div id="info-p1" class="player-row"><span>P1:</span> <span style="color:#f1c40f">$0</span></div>
   		    <div id="info-p2" class="player-row" style="display:none;"><span>P2:</span> <span style="color:#f1c40f">$0</span></div>
    		    <div id="info-p3" class="player-row" style="display:none;"><span>P3:</span> <span style="color:#f1c40f">$0</span></div>
    		    <div id="info-p4" class="player-row" style="display:none;"><span>P4:</span> <span style="color:#f1c40f">$0</span></div>
		</div>
	</div>

	<!-- Legal Buttons -->
<div id="legal-links" style="
    position: fixed;
    bottom: 12px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 13px;
    z-index: 999999;
    pointer-events: auto;
    user-select: none;
    color: #3b82f6;
">
    <span style="cursor:pointer; pointer-events:auto; text-decoration:underline;" onclick="openLegal('terms')">
        Terms
    </span>
    &nbsp;|&nbsp;
    <span style="cursor:pointer; pointer-events:auto; text-decoration:underline;" onclick="openLegal('privacy')">
        Privacy
    </span>
</div>

<!-- Legal Modal -->
<div id="legal-modal" style="
    display:none;
    position:fixed;
    top:0;
    left:0;
    width:100%;
    height:100%;
    background:rgba(0,0,0,0.75);
    z-index:1000000;
    pointer-events:auto;
    justify-content:center;
    align-items:center;
">
    <div style="
        width:600px;
        max-width:90%;
        max-height:80%;
        background:#0b1220;
        border-radius:12px;
        padding:20px;
        overflow-y:auto;
        pointer-events:auto;
        color:#e5e7eb;
    ">
        <h2 id="legal-title" style="margin-top:0; color:#60a5fa;"></h2>
        <div id="legal-content" style="font-size:14px; line-height:1.5;"></div>
        <button onclick="closeLegal()" style="
            margin-top:20px;
            width:100%;
            padding:10px;
            background:#2563eb;
            color:white;
            border:none;
            border-radius:6px;
            cursor:pointer;
            pointer-events:auto;
        ">
            Close
        </button>
    </div>
</div>

        <!-- Main Menu -->
        <div id="main-menu" class="fullscreen-modal">
            <h1 class="title-text" style="color:var(--primary)">KARLO'S TD</h1>
            <div style="display:flex; flex-direction:column; gap:10px; align-items:center;">
                <button class="btn btn-primary" style="width: 200px;" onclick="if(typeof playClick==='function')playClick(); showLevelSelect()">PLAY</button>
		
		<!-- Multiplayer button with counter positioned absolutely next to it -->
		<div style="position: relative;">
			<button id="btn-multiplayer" class="btn" style="width: 200px;" onclick="if(typeof playClick==='function')playClick(); showMpName()">MULTIPLAYER</button>
			
			<!-- Live Player Counter - positioned absolutely to not affect button centering -->
			<div id="live-player-counter" title="Players with game open right now">
				<div class="pulse-dot"></div>
				<span class="player-count-number" id="live-player-count">--</span>
				<span class="player-count-text">ONLINE</span>
			</div>
		</div>
		
		<button class="btn" style="width: 200px;" onclick="if(typeof playClick==='function')playClick(); if(typeof openChallenges==='function')openChallenges()">DAILY CHALLENGES</button>
		<button class="btn" style="width: 200px;" onclick="if(typeof playClick==='function')playClick(); if(typeof openSkillTree==='function')openSkillTree()">SKILL TREE</button>
                <button class="btn" style="width: 200px;" onclick="if(typeof playClick==='function')playClick(); showAlmanac()">ALMANAC</button>
                <button class="btn" style="width: 200px;" onclick="if(typeof playClick==='function')playClick(); showSettings()">SETTINGS</button>
                <button class="btn" style="width: 200px;" onclick="if(typeof playClick==='function')playClick(); showControls()">CONTROLS</button>
                
		<!--<button class="btn" style="width: 200px;" onclick="openMapEditor()">
    		🗺️ MAP CREATOR
		</button>-->

		<!--<button class="btn" style="width: 200px;" onclick="showCustomMapBrowser()">
    		📂 MY MAPS
		</button>-->

                <!-- Desktop Client Download Link -->
                <a href="https://k4rl0.itch.io/karlos-td" target="_blank" style="
                    margin-top: 10px;
                    color: #3498db;
                    text-decoration: underline;
                    font-size: 13px;
                    cursor: pointer;
                    background: none;
                    border: none;
                    padding: 0;
                    text-align: center;
                    transition: color 0.2s;
                    width: 200px;
                " onmouseover="this.style.color='#5dade2'" onmouseout="this.style.color='#3498db'">
                    Lagging? Download the Desktop Client for 60FPS + Fullscreen.
                </a>
            </div>
            <div id="author-tag">Made by Karlo</div>
        </div>

        <!-- Controls Menu -->
        <div id="controls-menu" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text">CONTROLS</h1>
            <div style="background:#222; padding:30px; border-radius:10px; border:1px solid #444; line-height:1.8; text-align:left;">
                <strong style="color:var(--primary)">Left Click:</strong> Select / Place Tower<br>
                <strong style="color:var(--primary)">Right Click:</strong> Deselect / Cancel<br>
                <strong style="color:var(--primary)">Mouse Wheel:</strong> Zoom In / Out<br>
                <strong style="color:var(--primary)">Hold Middle Mouse + Move:</strong> Pan Camera<br>
                <strong style="color:var(--primary)">ESC / Menu Button:</strong> Pause Game
            </div>
            <button class="btn" style="margin-top:20px; width:200px;" onclick="playClick(); goToMainMenu()">BACK</button>
        </div>

        <!-- Settings Menu -->
        <div id="settings-menu" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text">SETTINGS</h1>
            
            <div class="settings-tabs">
                <button id="tab-btn-graphics" class="tab-btn active" onclick="playClick(); openSettingsTab('graphics')">GRAPHICS</button>
                <button id="tab-btn-audio" class="tab-btn" onclick="playClick(); openSettingsTab('audio')">AUDIO</button>
                <button id="tab-btn-gameplay" class="tab-btn" onclick="playClick(); openSettingsTab('gameplay')">GAMEPLAY</button>
            </div>

            <div id="tab-content-graphics" class="settings-content">
                <div class="setting-row">
                    <span class="setting-label">Quality</span>
                    <button class="btn" id="set-gfx-btn" onclick="playClick(); toggleGraphics()">HIGH</button>
                
                <div style="text-align: center; margin-top: 5px;">
                    <button onclick="openAdvancedGraphics()" style="font-size: 12px; padding: 5px 15px; background: #3498db; border: none; border-radius: 5px; color: white; cursor: pointer;">⚙️ Advanced</button>
                </div></div>
                <div class="setting-row">
                    <span class="setting-label">Camera FOV</span>
                    <input type="range" id="fov-slider" min="30" max="90" value="45" oninput="setFOV(this.value)">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Screen Shake</span>
                    <button class="btn" id="set-shake-btn" onclick="playClick(); toggleShake()">ON</button>
                </div>
		<button class="btn" style="margin-top:15px; width:100%; font-size:12px; padding:8px; background:linear-gradient(135deg, #c0392b, #922b21); border-color:#e74c3c;" onclick="playClick(); resetSettings('graphics')">RESET GRAPHICS</button>
            </div>

            <div id="tab-content-audio" class="settings-content" style="display:none;">
                <div class="setting-row">
                    <span class="setting-label">SFX Volume</span>
                    <input type="range" id="sfx-slider" min="0" max="100" value="50" oninput="setSFXVolume(this.value)">
                </div>
                <div class="setting-row">
                    <span class="setting-label">Music Volume</span>
                    <input type="range" id="music-slider" min="0" max="100" value="50" oninput="setMusicVolume(this.value)">
                </div>
		<button class="btn" style="margin-top:15px; width:100%; font-size:12px; padding:8px; background:linear-gradient(135deg, #c0392b, #922b21); border-color:#e74c3c;" onclick="playClick(); resetSettings('audio')">RESET AUDIO</button>
            </div>

            <div id="tab-content-gameplay" class="settings-content" style="display:none;">
                <div class="setting-row">
                    <span class="setting-label">Auto Start Wave</span>
                    <button class="btn" id="set-auto-btn" onclick="playClick(); toggleAutoStart()">OFF</button>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Enemy HP Bars</span>
                    <button class="btn" id="set-hp-btn" onclick="playClick(); toggleHealthBars()">ON</button>
                </div>
                <div class="setting-row">
                    <span class="setting-label">Damage Text</span>
                    <button class="btn" id="set-dmg-btn" onclick="playClick(); toggleDmgText()">ON</button>
                </div>
                <div class="setting-row">
                    <span class="setting-label">FPS Counter</span>
                    <button class="btn" id="set-fps-btn" onclick="playClick(); toggleFPSCounter()">ON</button>
                </div>
		<button class="btn" style="margin-top:15px; width:100%; font-size:12px; padding:8px; background:linear-gradient(135deg, #c0392b, #922b21); border-color:#e74c3c;" onclick="playClick(); resetSettings('gameplay')">RESET GAMEPLAY</button>
            </div>

            <button class="btn" style="margin-top:20px; width:200px;" onclick="playClick(); backFromSettings()">BACK</button>
        </div>

        <!-- Almanac -->
        <div id="almanac-menu" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text">ALMANAC</h1>
            <div class="almanac-tabs">
                <button class="btn" onclick="playClick(); renderAlmanac('towers')">TOWERS</button>
                <button class="btn" onclick="playClick(); renderAlmanac('enemies')">ENEMIES</button>
            </div>
            <div id="almanac-grid" class="almanac-grid"></div>
            <div id="almanac-details" class="almanac-details"></div>
            <button class="btn" style="margin-top:20px; width:200px;" onclick="playClick(); goToMainMenu()">BACK</button>
        </div>

        <!-- Level Select -->
		<div id="level-select" class="fullscreen-modal" style="display: none;">
            <h1 class="title-text" style="font-size: 50px;">SELECT MAP</h1>
            
            <!-- Map Category Tabs -->
            <div style="display: flex; justify-content: center; gap: 15px; margin-bottom: 20px;">
                <button class="category-tab active" data-category="all" onclick="filterMapCategory('all')">
                    ALL MAPS
                </button>
                <button class="category-tab" data-category="easy" onclick="filterMapCategory('easy')">
                    🟢 EASY
                </button>
                <button class="category-tab" data-category="medium" onclick="filterMapCategory('medium')">
                    🟡 MEDIUM
                </button>
                <button class="category-tab" data-category="hard" onclick="filterMapCategory('hard')">
                    🔴 HARD
                </button>
            </div>

            <div class="map-container" id="map-container">
                <!-- EASY MAPS -->
                <div class="map-card" data-difficulty="hard" onclick="playClick(); selectMap(4)" style="border-color:#9b59b6; box-shadow: 0 0 15px #9b59b6;">
                    <span class="map-title" style="color: #9b59b6">The Void</span>
                    <span class="map-desc">Straight line path.<br>Pure chaos.</span>
                    <span class="map-difficulty" style="color: #e74c3c;">⚡ HARD</span>
                    <span class="map-credit">Suggested by fg79797</span>
                </div>

                <div class="map-card" data-difficulty="easy" onclick="playClick(); selectMap(0)" style="border-color:#e67e22; box-shadow: 0 0 15px #e67e22;">
                    <span class="map-title" style="color:#e67e22">Canyon Crossing</span>
                    <span class="map-desc">Standard difficulty.<br>Simple winding path.</span>
                    <span class="map-difficulty" style="color: #2ecc71;">⚡ EASY</span>
                </div>

                <div class="map-card" data-difficulty="medium" onclick="playClick(); selectMap(1)" style="border-color:#3498db; box-shadow: 0 0 15px #3498db;">
                    <span class="map-title" style="color: #3498db">Frozen Route</span>
                    <span class="map-desc">Long path.<br>Few turns.</span>
                    <span class="map-difficulty" style="color: #f1c40f;">⚡ MEDIUM</span>
                </div>

                <!-- MEDIUM MAPS -->
                <div class="map-card" data-difficulty="hard" onclick="playClick(); selectMap(2)" style="border-color:#e74c3c; box-shadow: 0 0 15px #e74c3c;">
                    <span class="map-title" style="color: #e74c3c">Volcanic Core</span>
                    <span class="map-desc">Zig-zag pattern.<br>Moderate challenge.</span>
                    <span class="map-difficulty" style="color: #e74c3c;">⚡ HARD</span>
                </div>

                <div class="map-card" data-difficulty="easy" onclick="playClick(); selectMap(3)" style="border-color:#ff69b4; box-shadow: 0 0 15px #ff69b4;">
                    <span class="map-title" style="color: #ff69b4">Kitty Kingdom</span>
                    <span class="map-desc">Cute & deadly.<br>Multiple turns.</span>
                    <span class="map-difficulty" style="color: #2ecc71;">⚡ EASY</span>
                    <span class="map-credit">Suggested by rukia_klucky_11629</span>
                </div>

                <div class="map-card" data-difficulty="medium" onclick="playClick(); selectMap(6)" style="border-color:#00d9ff; box-shadow: 0 0 15px #00d9ff;">
                    <span class="map-title" style="color: #00d9ff">Neon City</span>
                    <span class="map-desc">Cyberpunk vibes.<br>Urban warfare.</span>
                    <span class="map-difficulty" style="color: #f1c40f;">⚡ MEDIUM</span>
                </div>

                <div class="map-card" data-difficulty="hard" onclick="playClick(); selectMap(7)" style="border-color:#66ff33; box-shadow: 0 0 15px #66ff33;">
                    <span class="map-title" style="color: #66ff33">Toxic Swamp</span>
                    <span class="map-desc">Green fog.<br>Winding hazards.</span>
                    <span class="map-difficulty" style="color: #e74c3c;">⚡ HARD</span>
                </div>

                <!-- HARD MAPS -->
                <div class="map-card" data-difficulty="easy" onclick="playClick(); selectMap(5)" style="border-color:#aa00ff; box-shadow: 0 0 15px #aa00ff;">
                    <span class="map-title" style="color: #aa00ff">Crystal Caves</span>
                    <span class="map-desc">Deep purple glow.<br>Complex loops.</span>
                    <span class="map-difficulty" style="color: #2ecc71;">⚡ EASY</span>
                </div>

                <div class="map-card" data-difficulty="easy" onclick="playClick(); selectMap(8)" style="border-color:#888888; box-shadow: 0 0 15px #888888;">
                    <span class="map-title" style="color: #888888">Space Station</span>
                    <span class="map-desc">Zero gravity.<br>Many corners.</span>
                    <span class="map-difficulty" style="color: #2ecc71;">⚡ EASY</span>
                </div>

                <!-- NEW FARM MAP -->
                <div class="map-card" data-difficulty="easy" onclick="playClick(); selectMap(9)" style="border-color:#8fbc8f; box-shadow: 0 0 15px #8fbc8f;">
                    <span class="map-title" style="color: #8fbc8f">Harvest Valley</span>
                    <span class="map-desc">Peaceful farmlands.<br>Winding dirt roads.</span>
                    <span class="map-difficulty" style="color: #2ecc71;">⚡ EASY</span>
                    <span class="map-credit">Suggested by murasakiwastaken</span>
                </div>
                
                <div class="map-card" data-difficulty="medium" onclick="playClick(); selectMap(10)" style="border-color:#228b22; box-shadow: 0 0 15px #228b22;">
                    <span class="map-title" style="color: #228b22">Jungle Temple</span>
                    <span class="map-desc">Dense rainforest.<br>Winding river path.</span>
                    <span class="map-difficulty" style="color: #f1c40f;">⚡ MEDIUM</span>
                </div>

		<div class="map-card" data-difficulty="medium" onclick="playClick(); selectMap(11)" style="border-color:#9966ff; box-shadow: 0 0 15px #9966ff;">
    		    <span class="map-title" style="color: #9966ff">Mushroom Forest</span>
    		    <span class="map-desc">Magical fungi.<br>Twisting paths.</span>
   		    <span class="map-difficulty" style="color: #f1c40f;">⚡ MEDIUM</span>
		    <span class="map-credit">Suggested by m4thias_00</span>
		</div>
            </div>
            <button class="btn" style="margin-top: 30px;" onclick="goToMainMenu()">BACK</button>
        </div>

        <!-- Difficulty Select -->
        <div id="diff-select" class="fullscreen-modal" style="display: none;">
            <h1 class="title-text" style="font-size: 50px;">DIFFICULTY</h1>
            <div class="map-container">
                <div class="map-card" onclick="playClick(); startGame('easy')">
                    <span class="map-title" style="color:#2ecc71">EASY</span>
                    <span class="map-desc">20 Waves<br>Cheaper Towers</span>
                </div>
                <div class="map-card" onclick="playClick(); startGame('medium')">
                    <span class="map-title" style="color:#f1c40f">MEDIUM</span>
                    <span class="map-desc">40 Waves<br>Standard</span>
                </div>
                <div class="map-card" onclick="playClick(); startGame('hard')">
                    <span class="map-title" style="color:#e74c3c">HARD</span>
                    <span class="map-desc">60 Waves<br>Tougher Enemies</span>
                </div>
            </div>
            <button class="btn" style="margin-top: 30px;" onclick="playClick(); showLevelSelect()">BACK</button>
        </div>

        <!-- Pause Menu -->
        <div id="pause-menu" class="fullscreen-modal" style="display: none; background: rgba(0,0,0,0.8);">
            <div class="pause-menu-content">
                <h2 style="text-align: center; color: white; margin: 0 0 20px 0;">PAUSED</h2>
                <button class="btn btn-primary" onclick="playClick(); togglePause()">RESUME</button>
                <button class="btn" onclick="playClick(); restartLevel()">RESTART LEVEL</button>
                <button class="btn" onclick="playClick(); if(typeof openChallenges === 'function') openChallenges();">DAILY CHALLENGES</button>
                <button class="btn" onclick="playClick(); showSettings()">SETTINGS</button>
                <button class="btn" style="background:#c0392b; border-color:#e74c3c;" onclick="playClick(); goToMainMenu()">MAIN MENU</button>
                
                <!-- Legal Links in Pause Menu -->
                <div style="
                    margin-top: 30px;
                    font-size: 13px;
                    color: #3b82f6;
                    text-align: center;
                ">
                    <span style="cursor:pointer; text-decoration:underline;" onclick="openLegal('terms')">
                        Terms
                    </span>
                    &nbsp;|&nbsp;
                    <span style="cursor:pointer; text-decoration:underline;" onclick="openLegal('privacy')">
                        Privacy
                    </span>
                </div>
            </div>
        </div>

        <!-- Graphics Settings Restart Warning Popup -->
        <div id="graphics-restart-warning" class="fullscreen-modal" style="display:none; z-index:99999; background:rgba(0,0,0,0.95); pointer-events:auto;" onclick="event.stopPropagation();">
            <div style="background:var(--panel-bg); padding:40px; border-radius:20px; border:3px solid var(--primary); max-width:500px; text-align:center; pointer-events:auto;" onclick="event.stopPropagation();">
                <h2 style="color:var(--primary); margin-top:0; font-size:28px;">⚠️ RESTART REQUIRED</h2>
                <p style="color:#fff; font-size:16px; line-height:1.6; margin:20px 0;">
                    The shadow renderer needs to restart to apply your graphics settings changes.<br><br>
                    This will refresh the page and any unsaved progress will be lost.
                </p>
                <div style="display:flex; gap:15px; justify-content:center; margin-top:30px;">
                    <button class="btn btn-primary" onclick="playClick(); confirmGraphicsRestart()" style="min-width:150px;">YES, RESTART</button>
                    <button class="btn" onclick="playClick(); cancelGraphicsChange()" style="min-width:150px; background:#555;">CANCEL</button>
                </div>
            </div>
        </div>

        <!-- Graphics Restart Confirmation Popup -->
        <div id="graphics-restart-confirm" class="fullscreen-modal" style="display:none; z-index:99999; background:rgba(0,0,0,0.95); pointer-events:auto;" onclick="event.stopPropagation();">
            <div style="background:var(--panel-bg); padding:40px; border-radius:20px; border:3px solid var(--accent); max-width:500px; text-align:center; pointer-events:auto;" onclick="event.stopPropagation();">
                <h2 style="color:var(--accent); margin-top:0; font-size:28px;">⚠️ ARE YOU SURE?</h2>
                <p style="color:#fff; font-size:16px; line-height:1.6; margin:20px 0;">
                    This will refresh the page and delete any unsaved changes.<br><br>
                    Make sure you've saved your progress before continuing.
                </p>
                <div style="display:flex; gap:15px; justify-content:center; margin-top:30px;">
                    <button class="btn" onclick="playClick(); proceedWithRestart()" style="min-width:150px; background:var(--accent);">I AM SURE</button>
                    <button class="btn" onclick="playClick(); cancelGraphicsChange()" style="min-width:150px; background:#555;">I CHANGED MY MIND</button>
                </div>
            </div>
        </div>

        <!-- Game UI -->
        <div id="stats-bar">
            <div class="stat-pill"><span class="stat-icon">❤️</span> <span id="ui-lives">20</span></div>
            <div class="stat-pill"><span class="stat-icon">💰</span> $<span id="ui-gold">650</span></div>
            <div class="stat-pill"><span class="stat-icon">🌊</span> <span id="ui-wave">1</span> <span style="font-size:12px; color:#777; margin-left:5px;">/ <span id="ui-max-wave">20</span></span></div>
        </div>

        <button id="menu-btn" onclick="playClick(); togglePause()">☰ MENU</button>

        <div id="wave-controls">
            <button id="btn-start-wave" class="btn btn-primary">START WAVE</button>
        </div>

	<div id="tower-dock">
            <button id="dock-toggle">▼ Hide Towers</button>
            <!-- MODERN TOWER SELECTION PANEL -->
            <div id="tower-panel">
                <div id="tower-panel-header">
                    <div id="tower-panel-title">⚔️ BUILD TOWERS</div>
                    <div id="tower-count" style="color: #888; font-size: 12px;"></div>
                </div>
                
                <!-- Category Tabs -->
                <div id="tower-categories">
                    <div class="category-tab active" data-category="all" onclick="filterTowerCategory('all')">
                        ALL
                    </div>
                    <div class="category-tab" data-category="offense" onclick="filterTowerCategory('offense')">
                        ⚔️ OFFENSE
                    </div>
                    <div class="category-tab" data-category="support" onclick="filterTowerCategory('support')">
                        🛡️ SUPPORT
                    </div>
                    <div class="category-tab" data-category="economy" onclick="filterTowerCategory('economy')">
                        💰 ECONOMY
                    </div>
                    <div class="category-tab" data-category="special" onclick="filterTowerCategory('special')">
                        ⭐ SPECIAL
                    </div>
                </div>
                
                <!-- Search Bar -->
                <div id="tower-search-container">
                    <input type="text" id="tower-search" placeholder="🔍 Search towers..." oninput="searchTowers()" />
                </div>
                
                <!-- Tower Grid -->
                <div id="tower-grid-container">
                    <div id="tower-grid"></div>
                    <div id="tower-empty-state">
                        <div style="font-size: 48px; margin-bottom: 10px;">🔍</div>
                        <div>No towers found</div>
                    </div>
                </div>
            </div>
        </div>

        <div id="inspect-panel">
            <div id="ins-header">
                <h2 id="ins-name" style="margin:0; font-size:20px; color:var(--primary);">Tower</h2>
                <div id="ins-type" style="font-size:12px; color:#888;">Level <span id="ins-lvl">1</span></div>
                
                <div id="ins-owner" style="font-size:11px; font-weight:bold; margin-top:4px; display:none; letter-spacing:1px;">OWNER: ???</div>
            </div>
            
            <div class="stat-row"><span>Damage</span> <span id="ins-dmg" class="stat-val">10</span></div>
            <div class="stat-row"><span>Range</span> <span id="ins-range" class="stat-val">15</span></div>
            <div class="stat-row"><span>Speed</span> <span id="ins-rate" class="stat-val">1.0s</span></div>
            <!-- Dynamic Stats -->
            <div class="stat-row" id="row-special-1" style="display:none"><span id="lbl-special-1">Stun</span> <span id="val-special-1" class="stat-val">0%</span></div>
            <div class="stat-row" id="row-special-2" style="display:none"><span id="lbl-special-2">Slow</span> <span id="val-special-2" class="stat-val">0s</span></div>
            
            <button class="action-btn btn-up" id="btn-upgrade">UPGRADE</button>
            <div class="action-group">
                <button class="action-btn btn-sell" id="btn-sell">SELL ($<span id="val-sell">0</span>)</button>
                <button class="action-btn" style="background:#555" onclick="deselectAll()">CLOSE</button>
            </div>
        </div>
        
        <div id="game-over-screen" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text" style="color: #e74c3c;">DEFEAT</h1>
            <p style="font-size:20px; margin-bottom:20px; color:white;">You reached Wave <span id="final-wave-loss">0</span></p>
            
            
            
            <button class="btn btn-primary" onclick="playClick(); restartLevel()">TRY AGAIN</button>
            <button class="btn" style="margin-top:10px;" onclick="playClick(); returnToLobbyOrMenu()">LOBBY / MENU</button>
            
            <!-- Desktop Client Download -->
            <a href="https://k4rl0.itch.io/karlos-td" target="_blank" style="
                display: block;
                margin-top: 20px;
                color: #3498db;
                text-decoration: underline;
                font-size: 14px;
                cursor: pointer;
                transition: color 0.2s;
            " onmouseover="this.style.color='#5dade2'" onmouseout="this.style.color='#3498db'">
                Lagging? Download Desktop Client for 60FPS + Fullscreen
            </a>
        </div>

        <div id="victory-screen" class="fullscreen-modal" style="display:none;">
            <h1 class="title-text" style="color: #2ecc71;">VICTORY!</h1>
            <p style="font-size:20px; margin-bottom:20px; color:white;">Mission Accomplished</p>
            <button class="btn btn-primary" onclick="playClick(); returnToLobbyOrMenu()">CONTINUE</button>
        </div>

<div id="controls-hint">Middle Mouse to Pan</div>
    </div>
	<div id="player-level-container" onclick="if (!gameRunning) openTrophyRoad(); else console.log('⚠️ Trophy Road disabled during gameplay');" style="position: fixed; top: 5px; left: 15px; z-index: 2147483647; display: flex; align-items: center; gap: 10px; background: linear-gradient(135deg, rgba(20, 20, 40, 0.95), rgba(10, 14, 39, 0.98)); padding: 6px 15px; border-radius: 20px; border: 2px solid #e67e22; box-shadow: 0 4px 20px rgba(0,0,0,0.6); pointer-events: auto; cursor: pointer;">
        <div id="player-level-badge">LVL 1</div>
        <div id="xp-bar-container">
            <div id="xp-bar-fill"></div>
            <div id="xp-bar-text">0 / 100 XP</div>
        </div>
        
        <div id="btn-achievements" onclick="event.stopPropagation(); if (!gameRunning) openAchievements(); else console.log('⚠️ Achievements disabled during gameplay');" style="
            width: 32px; height: 32px; 
            background: #f1c40f; 
            border-radius: 50%; 
            display: flex; justify-content: center; align-items: center; 
            font-size: 18px; border: 2px solid #000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            transition: transform 0.1s;
            cursor: pointer;
        " onmousedown="this.style.transform='scale(0.9)'" onmouseup="this.style.transform='scale(1)'">
            🏆
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>

    <script>
        // ========================================================================
        // CRAZYGAMES SDK v2 - COMPLETE QA-COMPLIANT INTEGRATION
        // ========================================================================
        /*
         * INTEGRATION STATUS: ✅ FULLY IMPLEMENTED
         * 
         * This game strictly follows all 6 CrazyGames SDK v2 requirements:
         * 
         * ✅ REQUIREMENT 1: SDK Installation
         *    - SDK script loaded in <head> at line 22
         *    - Path: https://sdk.crazygames.com/crazygames-sdk-v2.js
         * 
         * ✅ REQUIREMENT 2: Initialization & Loading Metrics
         *    - Function: initCrazyGamesSDK()
         *    - Calls: loadingStart() → wait 1s → loadingStop()
         *    - Auto-initializes on window.load event
         *    - Tracks: "Time to Interactive" metric
         * 
         * ✅ REQUIREMENT 3: Gameplay Tracking
         *    - Function: notifyGameplayStart() - called when wave starts (line 11023)
         *    - Function: notifyGameplayStop() - called on:
         *      • Game Over (line 8406)
         *      • Pause Menu (line 7740 via runPauseLogic)
         *      • Return to Main Menu (line 7486)
         *      • Victory Screen (line 8515)
         *    - Tracks: "Average Playtime" metric
         * 
         * ✅ REQUIREMENT 4: Ad Implementation
         *    - Midgame Ads: showIntermissionAd() - every 5 waves (line 11027)
         *    - Rewarded Ads: showRewardAd() - for:
         *      • Revive button (line 2772)
         *      • Bonus gold button (line 2690)
         *    - All ads use adStarted, adFinished, adError callbacks
         *    - Tracks: Revenue metrics
         * 
         * ✅ REQUIREMENT 5: Audio & Pause Handling
         *    - Function: setGameFocus(bool)
         *    - On Ad Start: isPaused=true, AudioSys.ctx.suspend()
         *    - On Ad End: isPaused=false, AudioSys.ctx.resume()
         *    - Ensures game pauses and audio mutes during all ads
         * 
         * ✅ REQUIREMENT 6: Happy Time (Algorithm Boost)
         *    - Function: triggerHappyTime()
         *    - Called on: Boss waves (every 10 waves) - line 8496
         *    - Called on: Victory screen - line 8508
         *    - Tracks: Player engagement & positive moments
         * 
         * ✅ REQUIREMENT 7: Environment Safety
         *    - All SDK calls wrapped in availability checks
         *    - Works offline (localhost/itch.io) without errors
         *    - Graceful degradation when SDK unavailable
         * 
         * INTEGRATION SUMMARY:
         * - Loading: Auto-tracked on page load
         * - Gameplay: Tracked from wave start to game over/pause/menu
         * - Ads: Every 5 waves + revive/bonus buttons
         * - Happy Time: Boss waves + victory
         * - Audio: Auto-mutes during ads
         * - Safety: Works in all environments
         */
        
        let crazygamesSDK = null;
        let isSDKReady = false;
        let gameLoadingComplete = false;
        
        /**
         * CRITICAL QA METRIC #1: Initialize SDK and START loading timer
         * This IIFE runs IMMEDIATELY when the script executes
         */
        // ==========================================
// 🎮 KARLOS TD - CRAZYGAMES SDK INTEGRATION
// ==========================================

async function initCrazyGamesSDK() {
    console.log("⏳ Initializing CrazyGames SDK...");

    try {
        // 1. Wait for SDK to be ready
        if (!window.CrazyGames || !window.CrazyGames.SDK) {
            await new Promise(resolve => setTimeout(resolve, 500));
        }

        if (window.CrazyGames && window.CrazyGames.SDK) {
            const sdk = window.CrazyGames.SDK;
            
            // Initialize the SDK
            await sdk.init();
            console.log("🎉 SDK Initialized. Environment:", sdk.environment);

            // Tell CrazyGames we started loading
            sdk.game.sdkGameLoadingStart();
            console.log("📊 Loading metrics started");

            // Since you have no loading screen, wait a moment and then report ready
            setTimeout(() => {
                sdk.game.sdkGameLoadingStop();
                console.log("✅ Game Ready - Loading Complete (Time to Interactive reported)");
            }, 1000);
            
            // Store SDK reference globally for invite link
            crazygamesSDK = sdk;
            isSDKReady = true;
        } else {
            console.log("⚠️ CrazyGames SDK not available - running in offline/dev mode");
        }

    } catch (e) {
        console.error("❌ SDK Init Failed:", e);
        console.log("⚠️ Continuing in offline mode...");
    }
}

// ==========================================
// CRAZYGAMES INVITE LINK (Multiplayer)
// ==========================================

/**
 * Generate and show CrazyGames invite link
 * Called when entering multiplayer lobby
 */
function showInviteButton() {
    if (!window.CrazyGames || !window.CrazyGames.SDK) {
        console.log('⚠️ SDK not available - invite button unavailable');
        return;
    }
    
    try {
        const sdk = window.CrazyGames.SDK;
        
        // Show invite button in CrazyGames interface
        if (sdk.game && sdk.game.showInviteButton) {
            sdk.game.showInviteButton({
                roomId: myRoomId || 'unknown'
            });
            console.log('✅ Invite button shown');
        }
    } catch (e) {
        console.error('Error showing invite button:', e);
    }
}

/**
 * Hide CrazyGames invite link
 * Called when leaving multiplayer lobby
 */
function hideInviteButton() {
    if (!window.CrazyGames || !window.CrazyGames.SDK) {
        return;
    }
    
    try {
        const sdk = window.CrazyGames.SDK;
        
        // Hide invite button
        if (sdk.game && sdk.game.hideInviteButton) {
            sdk.game.hideInviteButton();
            console.log('✅ Invite button hidden');
        }
    } catch (e) {
        console.error('Error hiding invite button:', e);
    }
}

/**
 * Get invite link for current room
 * Returns URL that players can share
 */
function getInviteLink() {
    if (!myRoomId) {
        console.log('⚠️ No room ID available');
        return null;
    }
    
    if (!window.CrazyGames || !window.CrazyGames.SDK) {
        // Fallback for offline mode
        return `${window.location.origin}${window.location.pathname}?room=${myRoomId}`;
    }
    
    try {
        const sdk = window.CrazyGames.SDK;
        
        // Get invite link from SDK
        if (sdk.game && sdk.game.inviteLink) {
            const link = sdk.game.inviteLink({
                roomId: myRoomId
            });
            console.log('✅ Invite link generated:', link);
            return link;
        }
    } catch (e) {
        console.error('Error getting invite link:', e);
    }
    
    // Fallback
    return `${window.location.origin}${window.location.pathname}?room=${myRoomId}`;
}

// ==========================================
// LEVEL UP & UNLOCK NOTIFICATIONS
// ==========================================

/**
 * Show level up popup with animation
 * Called by progression system when player levels up
 */
window.showLevelUpPopup = function() {
    console.log('🎉 showLevelUpPopup called for level', window.playerLevel);
    const earnedSP = (window.playerLevel % 5 === 0);
    
    const popup = document.createElement('div');
    popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%) scale(0);
        background: linear-gradient(135deg, #9b59b6, #8e44ad);
        color: white;
        padding: 40px 60px;
        border-radius: 20px;
        font-size: 32px;
        font-weight: 900;
        text-align: center;
        box-shadow: 0 15px 40px rgba(0,0,0,0.7);
        z-index: 2000000;
        animation: popIn 0.6s ease-out forwards;
    `;
    popup.innerHTML = `
        <div style="font-size: 72px; margin-bottom: 15px;">🎉</div>
        <div>LEVEL UP!</div>
        <div style="font-size: 48px; margin-top: 10px;">Level ${window.playerLevel}</div>
        ${earnedSP ? '<div style="font-size: 18px; margin-top: 15px; opacity: 0.9; color: #f1c40f;">⭐ +1 Skill Point ⭐</div>' : ''}
    `;
    document.body.appendChild(popup);
    console.log('✅ Level up popup added to DOM');

    setTimeout(() => {
        popup.style.animation = 'popOut 0.4s ease-in forwards';
        setTimeout(() => popup.remove(), 400);
    }, 2500);
};

/**
 * Show tower/upgrade unlock notification
 * Called when player unlocks new content
 */
window.showUnlockNotif = function(message) {
    const notif = document.createElement('div');
    notif.style.cssText = `
        position: fixed;
        top: 180px;
        right: 20px;
        background: linear-gradient(135deg, #3498db, #2980b9);
        color: white;
        padding: 15px 25px;
        border-radius: 12px;
        font-size: 16px;
        font-weight: bold;
        box-shadow: 0 6px 20px rgba(0,0,0,0.4);
        z-index: 1000000;
        animation: slideIn 0.4s ease-out;
    `;
    notif.innerText = message;
    document.body.appendChild(notif);

    setTimeout(() => {
        notif.style.animation = 'slideOut 0.4s ease-in';
        setTimeout(() => notif.remove(), 400);
    }, 3000);
};

// Add CSS animations for popups
if (!document.getElementById('popup-animations')) {
    const style = document.createElement('style');
    style.id = 'popup-animations';
    style.textContent = `
        @keyframes popIn {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
        @keyframes popOut {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
        }
        @keyframes slideIn {
            from { transform: translateX(400px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        @keyframes slideOut {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(400px); opacity: 0; }
        }
    `;
    document.head.appendChild(style);
}

// ==========================================
// MULTIPLAYER LOBBY RETURN (CrazyGames Requirement)
// ==========================================

/**
 * Smart function that returns to lobby in multiplayer or menu in singleplayer
 * CrazyGames requires players stay in lobby after game ends
 */
function returnToLobbyOrMenu() {
    if (isMultiplayerMode && socket && myRoomId) {
        // Multiplayer: Return to lobby
        returnToLobby();
    } else {
        // Singleplayer: Go to main menu
        goToMainMenu();
    }
}

	function startGameWithCustomMap(customMap) {
    console.log('🎮 Starting game with custom map:', customMap.name);
    
    // Add custom map to MAPS array temporarily
    const tempMapIndex = MAPS.length;
    MAPS.push(customMap);
    
    // Start game with this map
    selectedMapIndex = tempMapIndex;
    
    // Your existing startGame() logic here
    hideAllScreens();
    setGameUIVisible(true);
    resetGame();
    loadMap(tempMapIndex);
    
    // Apply custom settings
    if (customMap.customSettings) {
        applyCustomMapSettings(customMap.customSettings);
    }
    
    gameRunning = true;
    isPaused = false;
}

/**
 * Return to multiplayer lobby after game ends
 * Shows lobby screen with same players
 */
function returnToLobby() {
    console.log('🔄 Returning to lobby...');
    
    // Stop gameplay tracking
    notifyGameplayStop();
    
    // Reset game state but keep multiplayer data
    resetGame();
    loadMap(0); // Load dummy map for background
    
    gameRunning = false;
    isPaused = false;
    // Keep isMultiplayerMode = true
    
    // Show lobby screen
    hideAllScreens();
    document.getElementById('lobby-screen').style.display = 'flex';
    document.getElementById('lobby-room-code').innerText = "CODE: " + myRoomId;
    
    // Update XP bar when returning to lobby
    if (typeof window.updateXPBar === 'function') {
        window.updateXPBar();
    } else if (typeof window.updateXPBarDirect === 'function') {
        window.updateXPBarDirect();
    }
    
    // ✅ FIX: Show legal links in lobby
    const legal = document.getElementById('legal-links');
    if(legal) legal.style.display = 'block';

    // ✅ FIX 5: Force hide Ping/Location in Lobby (so they don't stick)
    const serverLoc = document.getElementById('server-location');
    const pingDisp = document.getElementById('ping-display');
    if(serverLoc) serverLoc.style.display = 'none';
    if(pingDisp) pingDisp.style.display = 'none';

    // Show invite button again
    showInviteButton();
    
    // Update lobby with current players
    if (allPlayers && allPlayers.length > 0) {
        const list = document.getElementById('lobby-player-list');
        list.innerHTML = allPlayers.map((p, i) => {
            const level = (i === myPlayerIndex && window.playerLevel) ? window.playerLevel : '?';
            const levelBadge = `<span style="background: linear-gradient(135deg, #e67e22, #e74c3c); padding: 2px 8px; border-radius: 5px; font-size: 14px; margin-right: 8px;">LVL ${level}</span>`;
            return `<div style="color:${PLAYER_COLORS[i]}">${levelBadge}${p.name} ${p.role==='host'?'(HOST)':''}</div>`;
        }).join('');
    }
    
    // Show appropriate buttons
    if (myRole === 'host') {
        document.getElementById('lobby-start-btn').style.display = 'block';
        document.getElementById('lobby-status').style.display = 'none';
    } else {
        document.getElementById('lobby-start-btn').style.display = 'none';
        document.getElementById('lobby-status').innerText = "Waiting for host to select map...";
        document.getElementById('lobby-status').style.display = 'block';
    }
    
    console.log('✅ Back in lobby!');
}

function setGameFocus(hasFocus) {
            if (!hasFocus) {
                // 1. Pause Game Logic
                isPaused = true; 
                // 2. Mute Audio Engine (Instant Silence)
                if (AudioSys && AudioSys.ctx) AudioSys.ctx.suspend();
                console.log("🔇 Game Paused & Muted for Ad");
            } else {
                // 1. Resume Game Logic
                isPaused = false;
                // 2. Resume Audio Engine
                if (AudioSys && AudioSys.ctx) AudioSys.ctx.resume();
                console.log("🔊 Game Resumed");
            }
        }

function showIntermissionAd() {
    // No-op - ads disabled but CrazyGames SDK tracking remains active
    console.log('⚠️ Intermission ad disabled');
}

// --- REWARD FUNCTION (AD REMOVED) ---
function showRewardAd(onSuccess) {
    // Instantly grant reward without showing ad (SDK tracking remains active)
    console.log('✅ Reward granted instantly (ad disabled)');
    if (onSuccess) onSuccess();
}

// --- MIDGAME AD FUNCTION (AD REMOVED) ---
function showMidgameAd() {
    // No-op - ads disabled but CrazyGames SDK tracking remains active
    console.log('⚠️ Midgame ad disabled');
}
        
        /**
         * CRITICAL QA METRIC #2: Stop loading timer when main menu appears
         * Call this the EXACT moment the main menu is visible and interactive
         */
        function notifyLoadingComplete() {
            if (window.CrazyGames && window.CrazyGames.SDK && !gameLoadingComplete) {
                try {
                    window.CrazyGames.SDK.game.sdkGameLoadingStop();
                    gameLoadingComplete = true;
                    console.log('✅ Loading Complete - Main Menu Ready');
                    console.log('⏹️ Loading Timer Stopped (Time to Play recorded)');
                } catch (e) {
                    console.warn('Loading complete tracking failed:', e);
                }
            }
        }
        
        /**
         * CRITICAL QA METRIC #3: Start gameplay tracking
         * Call ONLY when player enters actual gameplay (wave starts)
         * NOT when in menus, map select, or paused
         */
        function notifyGameplayStart() {
            if (window.CrazyGames && window.CrazyGames.SDK) {
                try {
                    window.CrazyGames.SDK.game.gameplayStart();
                    console.log('🎮 Gameplay Started (Average Playtime tracking)');
                } catch (e) {
                    console.warn('Gameplay start tracking failed:', e);
                }
            }
        }
        
        /**
         * CRITICAL QA METRIC #4: Stop gameplay tracking
         * Call when:
         * - Player pauses
         * - Player dies (game over)
         * - Player returns to menu
         * - Ad is playing
         */
        function notifyGameplayStop() {
            if (window.CrazyGames && window.CrazyGames.SDK) {
                try {
                    window.CrazyGames.SDK.game.gameplayStop();
                    console.log('⏸️ Gameplay Stopped (Playtime paused)');
                } catch (e) {
                    console.warn('Gameplay stop tracking failed:', e);
                }
            }
        }
        
        /**
         * HAPPY TIME: Celebration event
         * Call when player achieves something positive:
         * - Beats a boss wave
         * - Completes a difficult level
         * - Gets a high score
         * 
         * This creates positive engagement metrics
         */
        function triggerHappyTime() {
            if (window.CrazyGames && window.CrazyGames.SDK) {
                try {
                    window.CrazyGames.SDK.game.happytime();
                    console.log('🎉 Happy Time! (Player achieved something)');
                } catch (e) {
                    console.warn('Happy time tracking failed:', e);
                }
            }
        }
        
        // ========================================================================
        // AD FUNCTIONS
        // ========================================================================
        
        // (Duplicate showMidgameAd removed - using stub above)
        
        // (Duplicate ad functions removed - using stubs above)
        
        /**
         * Revive Player (Rewarded Ad Reward)
         * - Clears all enemies (prevents instant death)
         * - Resets camera to default position
         * - Gives 1 life
         * - Restarts current wave
         */
        function revivePlayer() {
            // 1. Clear all enemies and projectiles
            enemies.forEach(e => { 
                scene.remove(e.mesh); 
                if(e.hpGroup) scene.remove(e.hpGroup); 
            });
            projectiles.forEach(p => scene.remove(p.mesh));
            enemies = [];
            projectiles = [];
            
            // 2. Reset camera to default position
            camera.position.set(0, 110, 50);
            camera.lookAt(0, 0, 0);
            camera.updateProjectionMatrix();
            
            // 3. Give player 1 life
            lives = 1;
            
            // 4. Reset wave state (will restart current wave)
            activeWave = false;
            spawningFinished = true;
            wave--; // Decrement so next start goes to same wave
            
            // 5. Close game over screen and resume game
            document.getElementById('game-over-screen').style.display = 'none';
            isPaused = false;
            gameRunning = true;
            
            // 6. Enable start wave button
            const btn = document.getElementById('btn-start-wave');
            if(btn) {
                btn.disabled = false;
                btn.innerText = "START WAVE";
                btn.style.backgroundColor = "";
            }
            
            // 7. Resume gameplay tracking
            notifyGameplayStart();
            
            // 8. Update UI
            updateUI();
            
            console.log('🔄 Player revived! Wave ' + (wave + 1) + ' ready to restart.');
        }
        
        // --- SYNCED RANDOMNESS ---
        let mapSeed = 12345;
        function seededRandom() {
            var t = mapSeed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        }

        /** --- SAVE SYSTEM --- */
        const SAVE_KEY = "td_proto_save";
        let unlocks = {
            towers: {}, 
            enemies: [] 
        };

        function loadData() {
            const data = localStorage.getItem(SAVE_KEY);
            if(data) {
                unlocks = JSON.parse(data);
            }
            Object.keys(TOWERS).forEach(k => { if(!unlocks.towers[k]) unlocks.towers[k] = 1; });
        }

        function saveData() {
            localStorage.setItem(SAVE_KEY, JSON.stringify(unlocks));
        }

	// --- SETTINGS SAVE SYSTEM ---
        const SETTINGS_KEY = "td_proto_settings";

        function saveSettings() {
            const settings = {
                sfx: AudioSys.sfxVolume,
                music: AudioSys.musicVolume,
                graphics: graphicsMode,
                advancedGraphicsSettings: advancedGraphicsSettings, // Save advanced settings
                shake: shakeEnabled,
                dmgText: dmgTextEnabled,
                auto: autoWave,
		hpBars: healthBarsEnabled,
                bloom: bloomStrength,
                fov: cameraFOV,
                showFPS: showFPSCounter
            };
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settings));
        }

	function resetSettings(category) {
            if(category === 'graphics') {
                // 1. Reset Variables
                graphicsMode = 3;      // High
                bloomStrength = 1.5;   // Default glow
                cameraFOV = 45;        // Default zoom
                shakeEnabled = true;   // Shake ON

                // 2. Update UI Elements
                document.getElementById('set-gfx-btn').innerText = "ULTRA"
                document.getElementById('bloom-slider').value = 15;
                document.getElementById('fov-slider').value = 45;
                document.getElementById('set-shake-btn').innerText = "ON";

                // 3. Apply Changes to Engine
                applyGraphicsPreset(3);
                if(bloomPass) bloomPass.strength = 1.5;
                camera.fov = 45;
                camera.updateProjectionMatrix();
            }
            else if(category === 'audio') {
                // 1. Reset Variables
                AudioSys.sfxVolume = 0.5;
                AudioSys.musicVolume = 0.5;

                // 2. Update UI
                document.getElementById('sfx-slider').value = 50;
                document.getElementById('music-slider').value = 50;
            }
            else if(category === 'gameplay') {
                // 1. Reset Variables
                autoWave = false;
                healthBarsEnabled = true;
                dmgTextEnabled = true;
                showFPSCounter = true;

                // 2. Update UI
                document.getElementById('set-auto-btn').innerText = "OFF";
                document.getElementById('set-hp-btn').innerText = "ON";
                document.getElementById('set-dmg-btn').innerText = "ON";
                document.getElementById('set-fps-btn').innerText = "ON";

                // 3. Apply (Show health bars and FPS counter again)
                enemies.forEach(e => {
                    if(e.hpGroup) e.hpGroup.visible = true;
                });
                const fpsEl = document.getElementById('fps-counter');
                if(fpsEl) fpsEl.style.display = 'block';
            }
            
            // Save the defaults immediately
            saveSettings();
        }

        function loadSettings() {
            const data = localStorage.getItem(SETTINGS_KEY);
            if(!data) return; 

            let s = {};
            try { s = JSON.parse(data); } catch(e) { return; }

            // 1. Audio (Safely Load)
            try {
                if(s.sfx !== undefined) {
                    AudioSys.sfxVolume = s.sfx;
                    document.getElementById('sfx-slider').value = s.sfx * 100;
                }
                if(s.music !== undefined) {
                    AudioSys.musicVolume = s.music;
                    document.getElementById('music-slider').value = s.music * 100;
                }
            } catch(e) { console.log("Audio Load Error", e); }

            // 2. Graphics (Safely Load)
            try {
                if(s.graphics !== undefined) {
                    graphicsMode = s.graphics;
                    // Load advanced graphics settings first if they exist
                    if(s.advancedGraphicsSettings) {
                        Object.assign(advancedGraphicsSettings, s.advancedGraphicsSettings);
                    } else {
                        // If no advanced settings saved, apply preset
                        if(typeof applyGraphicsPreset === 'function') {
                            applyGraphicsPreset(graphicsMode);
                        }
                    }
                    // Always apply the settings after loading
                    if(typeof applyGraphicsSettings === 'function') {
                        applyGraphicsSettings();
                    }
                    // Update UI button text
                    const btn = document.getElementById('set-gfx-btn');
                    if(btn) {
                        const presetNames = ['LOW', 'MEDIUM', 'HIGH', 'ULTRA', 'CUSTOM'];
                        btn.innerText = presetNames[graphicsMode] || 'ULTRA';
                    }
                }
            } catch(e) { console.log("Graphics Load Error", e); }

            // 3. Toggles (Safely Load)
            try {
                if(s.shake !== undefined) {
                    shakeEnabled = s.shake;
                    const btn = document.getElementById('set-shake-btn');
                    if(btn) btn.innerText = shakeEnabled ? "ON" : "OFF";
                }
                if(s.dmgText !== undefined) {
                    dmgTextEnabled = s.dmgText;
                    const btn = document.getElementById('set-dmg-btn');
                    if(btn) btn.innerText = dmgTextEnabled ? "ON" : "OFF";
                }
                if(s.auto !== undefined) {
                    autoWave = s.auto;
                    const btn = document.getElementById('set-auto-btn');
                    if(btn) btn.innerText = autoWave ? "ON" : "OFF";
                }
            } catch(e) { console.log("Toggles Load Error", e); }
	    // Load New Settings
                if(s.hpBars !== undefined) {
                    healthBarsEnabled = s.hpBars;
                    const btn = document.getElementById('set-hp-btn');
                    if(btn) btn.innerText = healthBarsEnabled ? "ON" : "OFF";
                }
                if(s.showFPS !== undefined) {
                    showFPSCounter = s.showFPS;
                    const btn = document.getElementById('set-fps-btn');
                    const fpsEl = document.getElementById('fps-counter');
                    if(btn) btn.innerText = showFPSCounter ? "ON" : "OFF";
                    if(fpsEl) fpsEl.style.display = showFPSCounter ? 'block' : 'none';
                }
                if(s.bloom !== undefined) {
                    bloomStrength = s.bloom;
                    const slider = document.getElementById('bloom-slider');
                    if(slider) slider.value = bloomStrength * 10;
                    if(bloomPass) bloomPass.strength = bloomStrength;
                }
                if(s.fov !== undefined) {
                    cameraFOV = s.fov;
                    const slider = document.getElementById('fov-slider');
                    if(slider) slider.value = cameraFOV;
                    camera.fov = cameraFOV;
                    camera.updateProjectionMatrix();
                }
        }

	// Helper to update Graphics UI/Engine without cycling the mode
        function applyGraphicsVisuals(mode) {
            const btn = document.getElementById('set-gfx-btn');
            if(!btn) return; // Safety check

            if (mode === 2) {
                btn.innerText = "HIGH";
                shadowsEnabled = true;
                if(renderer) renderer.setPixelRatio(window.devicePixelRatio);
            } else if (mode === 1) {
                btn.innerText = "MEDIUM";
                shadowsEnabled = false;
                if(renderer) renderer.setPixelRatio(window.devicePixelRatio);
            } else {
                btn.innerText = "LOW";
                shadowsEnabled = false;
                if(renderer) renderer.setPixelRatio(0.6);
            }
            
            // Apply settings to scene if it exists
            if(renderer) renderer.shadowMap.enabled = shadowsEnabled;
            if(scene) {
                scene.traverse(o => {
                    if(o.isMesh) {
                        o.castShadow = shadowsEnabled;
                        o.receiveShadow = shadowsEnabled;
                    }
                });
            }
        }

        function unlockEnemy(type) {
            if(!unlocks.enemies.includes(type)) {
                unlocks.enemies.push(type);
                saveData();
            }
        }

        function unlockTowerLevel(type, level) {
            if(unlocks.towers[type] < level) {
                unlocks.towers[type] = level;
                saveData();
            }
        }

        /** --- AUDIO --- */
        const AudioSys = {
            ctx: null,
            sfxVolume: 0.5,
            musicVolume: 0.5,
            noiseBuffer: null,
	    
            // Music Sequencing State
            musicPlaying: false,
            currentTrackName: null,
            noteIndex: 0,
            musicTimer: null,
            
            // Track Data (EXTENDED VERSIONS)
            // --- EXTENDED 1-MINUTE SOUNDTRACKS ---
            tracks: {
                // ============================================
                // PROFESSIONAL MUSIC TRACKS - KARLO'S TD
                // Each track has: Intro (8 bars) → Build (8 bars) → Drop (16 bars) → Bridge (8 bars) → Outro (8 bars)
                // Total: 48 bars = ~96-120 seconds per track
                // ============================================
                
                menu: {
                    speed: 100,
                    lead: ['triangle', 'square', 'sine', 'sawtooth'],
                    bassInst: ['triangle', 'sine'],
                    melody: [
                        // INTRO - Gentle piano-like (8 bars)
                        523,0,0,0, 659,0,0,0, 784,0,0,0, 659,0,0,0,
                        523,0,0,0, 392,0,0,0, 440,0,0,0, 523,0,0,0,
                        587,0,0,0, 698,0,0,0, 784,0,0,0, 698,0,0,0,
                        587,0,0,0, 523,0,0,0, 440,0,0,0, 392,0,0,0,
                        
                        // BUILD - Adding rhythm (8 bars)
                        523,0,523,0, 659,0,659,0, 784,0,659,0, 523,0,0,0,
                        392,0,392,0, 440,0,440,0, 523,0,440,0, 392,0,0,0,
                        587,0,587,0, 698,0,698,0, 784,0,698,0, 587,0,0,0,
                        659,0,659,0, 784,0,784,0, 880,0,784,0, 659,0,0,0,
                        
                        // DROP - Main melody with harmonies (16 bars)
                        1046,0,880,0, 784,0,659,0, 784,0,880,0, 1046,0,0,0,
                        880,0,784,0, 659,0,587,0, 523,0,0,0, 0,0,0,0,
                        1046,0,880,0, 784,0,659,0, 784,0,880,0, 1046,0,0,0,
                        1175,0,1046,0, 880,0,784,0, 659,0,0,0, 0,0,0,0,
                        
                        784,0,659,0, 523,0,659,0, 784,0,880,0, 784,0,659,0,
                        523,0,440,0, 392,0,440,0, 523,0,587,0, 523,0,0,0,
                        1046,880,784,659, 784,880,1046,1175, 1318,1046,880,784, 659,0,0,0,
                        523,659,784,880, 1046,1175,1318,1568, 1760,0,0,0, 0,0,0,0,
                        
                        // BRIDGE - Breakdown (8 bars)
                        392,0,0,0, 440,0,0,0, 523,0,0,0, 587,0,0,0,
                        659,0,587,0, 523,0,440,0, 392,0,0,0, 0,0,0,0,
                        523,0,0,0, 587,0,0,0, 659,0,0,0, 784,0,0,0,
                        880,0,784,0, 659,0,587,0, 523,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Gentle fadeout (8 bars)
                        523,0,659,0, 784,0,659,0, 523,0,392,0, 329,0,0,0,
                        392,0,523,0, 659,0,523,0, 392,0,329,0, 261,0,0,0,
                        523,0,0,0, 392,0,0,0, 329,0,0,0, 261,0,0,0,
                        196,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro bass
                        130,0,0,0, 0,0,0,0, 146,0,0,0, 0,0,0,0, 123,0,0,0, 0,0,0,0, 130,0,0,0, 0,0,0,0,
                        // Build bass  
                        130,0,130,0, 146,0,146,0, 123,0,123,0, 130,0,130,0, 146,0,146,0, 164,0,164,0, 146,0,146,0, 130,0,130,0,
                        // Drop bass
                        130,130,0,130, 146,146,0,146, 123,123,0,123, 130,130,0,130,
                        146,146,0,146, 164,164,0,164, 174,174,0,174, 196,196,0,196,
                        130,130,130,130, 146,146,146,146, 123,123,123,123, 130,130,130,130,
                        164,164,164,164, 174,174,174,174, 196,196,196,196, 220,220,220,220,
                        // Bridge bass
                        98,0,0,0, 110,0,0,0, 123,0,0,0, 146,0,0,0, 164,0,0,0, 146,0,0,0, 123,0,0,0, 98,0,0,0,
                        // Outro bass
                        130,0,0,0, 123,0,0,0, 110,0,0,0, 98,0,0,0, 65,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                canyon: {
                    speed: 115,
                    lead: ['square', 'sawtooth', 'triangle', 'square'],
                    bassInst: ['sawtooth', 'square'],
                    melody: [
                        // INTRO - Western whistle (8 bars)
                        392,0,0,0, 440,0,0,0, 494,0,0,0, 440,0,392,0,
                        329,0,0,0, 293,0,0,0, 261,0,0,0, 293,0,329,0,
                        392,0,0,0, 440,0,0,0, 494,0,523,0, 587,0,0,0,
                        494,0,0,0, 440,0,0,0, 392,0,0,0, 0,0,0,0,
                        
                        // BUILD - Guitar-like strums (8 bars)
                        392,0,392,392, 440,0,440,440, 494,0,494,494, 523,0,523,523,
                        587,0,587,587, 523,0,523,523, 494,0,494,494, 440,0,440,440,
                        392,392,0,392, 440,440,0,440, 494,494,0,494, 523,523,0,523,
                        587,587,0,587, 659,659,0,659, 784,784,0,784, 880,0,0,0,
                        
                        // DROP - Rock riff (16 bars)
                        392,0,392,0, 587,0,0,0, 392,0,392,0, 523,0,0,0,
                        392,0,392,0, 494,0,440,392, 349,0,0,0, 0,0,0,0,
                        392,392,587,587, 784,784,880,880, 1046,0,880,0, 784,0,659,0,
                        587,0,523,0, 494,0,440,0, 392,0,0,0, 0,0,0,0,
                        
                        440,0,440,0, 659,0,0,0, 440,0,440,0, 587,0,0,0,
                        440,0,440,0, 523,0,494,440, 392,0,0,0, 0,0,0,0,
                        880,880,0,880, 784,784,0,784, 659,659,0,659, 587,587,0,587,
                        523,523,494,494, 440,440,392,392, 349,349,329,329, 293,0,0,0,
                        
                        // BRIDGE - Solo (8 bars)
                        784,0,880,0, 1046,0,880,0, 784,0,659,0, 587,0,523,0,
                        494,0,523,0, 587,0,659,0, 784,0,880,0, 1046,0,0,0,
                        1046,880,784,659, 587,523,494,440, 392,349,329,293, 261,0,0,0,
                        392,440,494,523, 587,659,784,880, 1046,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Fadeout whistle (8 bars)
                        392,0,0,0, 440,0,0,0, 494,0,0,0, 523,0,0,0,
                        494,0,0,0, 440,0,0,0, 392,0,0,0, 329,0,0,0,
                        293,0,0,0, 329,0,0,0, 392,0,0,0, 329,0,0,0,
                        293,0,0,0, 261,0,0,0, 196,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro - walking bass
                        98,0,0,0, 110,0,0,0, 123,0,0,0, 110,0,98,0,
                        87,0,0,0, 73,0,0,0, 65,0,0,0, 73,0,87,0,
                        // Build
                        98,0,98,98, 110,0,110,110, 123,0,123,123, 130,0,130,130,
                        146,0,146,146, 130,0,130,130, 123,0,123,123, 110,0,110,110,
                        // Drop - driving bass
                        98,98,0,98, 98,98,0,98, 98,98,0,98, 98,98,0,98,
                        110,110,0,110, 110,110,0,110, 123,123,0,123, 123,123,0,123,
                        98,98,98,98, 110,110,110,110, 123,123,123,123, 146,146,146,146,
                        98,0,0,0, 110,0,0,0, 123,0,0,0, 146,0,0,0,
                        // Bridge
                        98,0,110,0, 123,0,146,0, 164,0,146,0, 123,0,110,0,
                        98,0,0,0, 110,0,0,0, 123,0,0,0, 146,0,0,0,
                        // Outro
                        98,0,0,0, 87,0,0,0, 73,0,0,0, 65,0,0,0, 49,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                frozen: {
                    speed: 90,
                    lead: ['sine', 'triangle', 'square', 'sine'],
                    bassInst: ['sine', 'triangle'],
                    melody: [
                        // INTRO - Ice crystals forming (8 bars)
                        523,659,784,1046, 0,0,0,0, 587,740,880,1175, 0,0,0,0,
                        494,622,740,988, 0,0,0,0, 523,659,784,1046, 0,0,0,0,
                        1046,0,0,0, 880,0,0,0, 784,0,0,0, 659,0,0,0,
                        523,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        
                        // BUILD - Snowfall (8 bars)
                        1046,0,1046,0, 880,0,880,0, 784,0,784,0, 659,0,659,0,
                        587,0,587,0, 740,0,740,0, 880,0,880,0, 1046,0,1046,0,
                        1175,0,1046,0, 880,0,784,0, 659,0,587,0, 523,0,494,0,
                        440,0,494,0, 523,0,587,0, 659,0,784,0, 880,0,0,0,
                        
                        // DROP - Blizzard (16 bars)
                        1046,784,659,523, 1175,880,740,587, 1318,988,784,659, 1568,1175,988,784,
                        1046,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        1046,880,784,659, 587,523,494,440, 392,440,494,523, 587,659,784,880,
                        1046,0,1318,0, 1568,0,1760,0, 1976,0,0,0, 0,0,0,0,
                        
                        1318,0,1046,0, 880,0,659,0, 523,0,659,0, 880,0,1046,0,
                        1318,0,1568,0, 1760,0,1568,0, 1318,0,1046,0, 880,0,0,0,
                        1046,1175,1318,1568, 1760,1568,1318,1175, 1046,880,784,659, 523,0,0,0,
                        784,880,1046,1175, 1318,1568,1760,1976, 2093,0,0,0, 0,0,0,0,
                        
                        // BRIDGE - Calm after storm (8 bars)
                        523,0,0,0, 659,0,0,0, 784,0,0,0, 1046,0,0,0,
                        880,0,0,0, 784,0,0,0, 659,0,0,0, 523,0,0,0,
                        1046,0,880,0, 784,0,659,0, 587,0,523,0, 494,0,440,0,
                        392,0,440,0, 494,0,523,0, 587,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Melting (8 bars)
                        1046,0,0,0, 880,0,0,0, 784,0,0,0, 659,0,0,0,
                        523,0,0,0, 440,0,0,0, 392,0,0,0, 329,0,0,0,
                        261,0,0,0, 196,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        130,0,0,0, 0,0,0,0, 146,0,0,0, 0,0,0,0, 123,0,0,0, 0,0,0,0, 130,0,0,0, 0,0,0,0,
                        // Build
                        130,0,130,0, 146,0,146,0, 123,0,123,0, 130,0,130,0, 146,0,146,0, 164,0,164,0, 174,0,174,0, 196,0,0,0,
                        // Drop
                        65,0,65,0, 65,0,65,0, 73,0,73,0, 73,0,73,0,
                        61,0,61,0, 61,0,61,0, 65,0,65,0, 65,0,65,0,
                        65,65,0,65, 73,73,0,73, 82,82,0,82, 98,98,0,98,
                        65,0,0,0, 73,0,0,0, 82,0,0,0, 98,0,0,0,
                        // Bridge
                        130,0,0,0, 146,0,0,0, 164,0,0,0, 196,0,0,0, 164,0,0,0, 146,0,0,0, 130,0,0,0, 0,0,0,0,
                        // Outro
                        130,0,0,0, 110,0,0,0, 98,0,0,0, 82,0,0,0, 65,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                volcano: {
                    speed: 105,
                    lead: ['sawtooth', 'square', 'sawtooth', 'triangle'],
                    bassInst: ['sawtooth', 'square'],
                    melody: [
                        // INTRO - Rumbling (8 bars)
                        164,0,164,0, 164,0,196,0, 164,0,164,0, 220,0,0,0,
                        164,0,164,0, 164,0,196,0, 164,0,164,0, 246,0,0,0,
                        164,196,220,246, 164,196,220,246, 164,196,220,246, 277,0,0,0,
                        330,0,311,0, 293,0,277,0, 261,0,246,0, 220,0,0,0,
                        
                        // BUILD - Pressure building (8 bars)
                        330,0,330,0, 311,0,311,0, 330,0,330,0, 392,0,0,0,
                        330,0,330,0, 311,0,311,0, 330,0,330,0, 440,0,0,0,
                        392,0,330,0, 392,0,330,0, 392,0,440,0, 494,0,0,0,
                        523,0,494,0, 440,0,392,0, 330,0,0,0, 0,0,0,0,
                        
                        // DROP - Eruption (16 bars)
                        330,330,392,392, 440,440,494,494, 523,523,587,587, 659,659,0,0,
                        784,0,659,0, 587,0,523,0, 494,0,440,0, 392,0,330,0,
                        659,0,659,0, 784,0,784,0, 880,0,880,0, 1046,0,0,0,
                        1175,0,1046,0, 880,0,784,0, 659,0,0,0, 0,0,0,0,
                        
                        330,392,440,494, 523,587,659,784, 880,784,659,587, 523,494,440,392,
                        330,0,392,0, 440,0,494,0, 523,0,494,0, 440,0,392,0,
                        784,784,880,880, 1046,1046,1175,1175, 1318,1318,0,0, 0,0,0,0,
                        1046,880,784,659, 587,523,494,440, 392,330,293,261, 220,0,0,0,
                        
                        // BRIDGE - Lava flow (8 bars)
                        330,0,0,0, 392,0,0,0, 440,0,0,0, 494,0,0,0,
                        523,0,494,0, 440,0,392,0, 330,0,0,0, 0,0,0,0,
                        392,0,440,0, 494,0,523,0, 587,0,659,0, 784,0,880,0,
                        1046,0,880,0, 784,0,659,0, 587,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Cooling down (8 bars)
                        330,0,0,0, 311,0,0,0, 293,0,0,0, 277,0,0,0,
                        261,0,0,0, 246,0,0,0, 220,0,0,0, 196,0,0,0,
                        164,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        41,0,41,0, 41,0,41,0, 49,0,49,0, 49,0,49,0, 41,0,41,0, 41,0,41,0, 55,0,55,0, 55,0,55,0,
                        // Build
                        41,41,0,41, 41,41,0,41, 49,49,0,49, 49,49,0,49, 55,55,0,55, 55,55,0,55, 65,65,0,65, 65,65,0,65,
                        // Drop
                        41,41,41,41, 41,41,41,41, 49,49,49,49, 49,49,49,49,
                        55,55,55,55, 55,55,55,55, 65,65,65,65, 65,65,65,65,
                        41,0,41,0, 49,0,49,0, 55,0,55,0, 65,0,65,0,
                        73,0,73,0, 82,0,82,0, 98,0,98,0, 110,0,0,0,
                        // Bridge
                        41,0,0,0, 49,0,0,0, 55,0,0,0, 65,0,0,0, 73,0,0,0, 65,0,0,0, 55,0,0,0, 49,0,0,0,
                        // Outro
                        41,0,0,0, 36,0,0,0, 32,0,0,0, 29,0,0,0, 24,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                kitty: {
                    speed: 95,
                    lead: ['square', 'triangle', 'sine', 'square'],
                    bassInst: ['sine', 'triangle'],
                    melody: [
                        // INTRO - Cute bouncy (8 bars)
                        523,0,523,0, 659,0,0,0, 587,0,587,0, 523,0,494,0,
                        392,0,392,0, 440,0,0,0, 523,0,587,0, 659,0,0,0,
                        523,0,523,0, 659,0,0,0, 784,0,784,0, 880,0,0,0,
                        784,0,659,0, 587,0,523,0, 440,0,0,0, 0,0,0,0,
                        
                        // BUILD - Getting excited (8 bars)
                        784,0,784,0, 880,0,880,0, 1046,0,880,0, 784,0,659,0,
                        523,0,659,0, 784,0,880,0, 1046,0,0,0, 0,0,0,0,
                        523,587,659,698, 784,880,1046,1175, 1318,1046,880,784, 659,0,0,0,
                        784,698,659,587, 523,494,440,392, 349,392,440,494, 523,0,0,0,
                        
                        // DROP - Main chorus (16 bars)
                        1046,0,1046,0, 1175,0,1175,0, 1318,0,1175,0, 1046,0,880,0,
                        784,0,880,0, 1046,0,1175,0, 1318,0,0,0, 0,0,0,0,
                        1046,1175,1318,1568, 1760,1568,1318,1175, 1046,880,784,659, 523,0,0,0,
                        1046,0,1318,0, 1568,0,1318,0, 1046,0,880,0, 784,0,0,0,
                        
                        523,659,784,880, 523,659,784,880, 523,659,784,880, 1046,0,0,0,
                        1046,880,784,659, 523,659,784,880, 1046,1175,1318,1568, 1760,0,0,0,
                        1318,0,1046,0, 880,0,784,0, 659,0,523,0, 440,0,392,0,
                        523,587,659,784, 880,1046,1175,1318, 1568,0,0,0, 0,0,0,0,
                        
                        // BRIDGE - Breakdown (8 bars)
                        392,0,0,0, 440,0,0,0, 523,0,0,0, 587,0,0,0,
                        659,0,0,0, 784,0,0,0, 880,0,0,0, 1046,0,0,0,
                        1046,0,880,0, 784,0,659,0, 587,0,523,0, 494,0,440,0,
                        392,0,440,0, 494,0,523,0, 587,0,659,0, 784,0,0,0,
                        
                        // OUTRO - Happy ending (8 bars)
                        523,0,659,0, 784,0,1046,0, 880,0,784,0, 659,0,523,0,
                        440,0,523,0, 659,0,784,0, 880,0,0,0, 0,0,0,0,
                        1046,0,0,0, 880,0,0,0, 784,0,0,0, 659,0,0,0,
                        523,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        130,0,0,0, 130,0,0,0, 146,0,0,0, 146,0,0,0, 164,0,0,0, 174,0,0,0, 196,0,0,0, 196,0,0,0,
                        // Build
                        130,0,130,0, 146,0,146,0, 164,0,164,0, 174,0,174,0, 196,0,196,0, 220,0,220,0, 196,0,196,0, 174,0,0,0,
                        // Drop
                        130,130,0,130, 146,146,0,146, 164,164,0,164, 174,174,0,174,
                        196,196,0,196, 220,220,0,220, 246,246,0,246, 261,261,0,261,
                        130,130,130,130, 146,146,146,146, 164,164,164,164, 196,196,196,196,
                        220,220,220,220, 246,246,246,246, 261,261,261,261, 293,293,293,293,
                        // Bridge
                        98,0,0,0, 110,0,0,0, 130,0,0,0, 146,0,0,0, 164,0,0,0, 174,0,0,0, 196,0,0,0, 0,0,0,0,
                        // Outro
                        130,0,0,0, 146,0,0,0, 164,0,0,0, 196,0,0,0, 174,0,0,0, 146,0,0,0, 130,0,0,0, 0,0,0,0
                    ]
                },

                void: {
                    speed: 110,
                    lead: ['sawtooth', 'square', 'triangle', 'sine'],
                    bassInst: ['triangle', 'sawtooth'],
                    melody: [
                        // INTRO - Eerie atmosphere (8 bars)
                        466,0,0,0, 311,0,0,0, 587,0,0,0, 466,0,0,0,
                        311,0,349,0, 293,0,311,0, 233,0,0,0, 0,0,0,0,
                        698,0,0,0, 466,0,0,0, 932,0,0,0, 698,0,0,0,
                        466,0,0,0, 349,0,0,0, 233,0,0,0, 0,0,0,0,
                        
                        // BUILD - Glitch patterns (8 bars)
                        932,0,233,0, 932,0,233,0, 1175,0,293,0, 1175,0,293,0,
                        466,466,0,0, 587,587,0,0, 698,698,0,0, 932,932,0,0,
                        1175,0,932,0, 698,0,587,0, 466,0,349,0, 233,0,0,0,
                        1397,1175,932,698, 587,466,349,293, 233,0,0,0, 0,0,0,0,
                        
                        // DROP - Discordant chaos (16 bars)
                        311,370,466,0, 311,370,466,0, 311,370,466,0, 622,740,932,0,
                        1244,0,932,0, 698,0,466,0, 349,0,0,0, 0,0,0,0,
                        466,0,587,0, 698,0,932,0, 1175,0,1397,0, 1661,0,0,0,
                        1397,0,1175,0, 932,0,698,0, 587,0,466,0, 349,0,0,0,
                        
                        233,311,466,622, 932,1175,1397,1661, 1976,1661,1397,1175, 932,622,466,311,
                        233,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        932,0,932,0, 1175,0,1175,0, 1397,0,1397,0, 1661,0,1661,0,
                        698,698,932,932, 1175,1175,1397,1397, 1661,0,0,0, 0,0,0,0,
                        
                        // BRIDGE - False calm (8 bars)
                        311,0,0,0, 349,0,0,0, 392,0,0,0, 466,0,0,0,
                        587,0,466,0, 392,0,349,0, 311,0,0,0, 0,0,0,0,
                        466,0,587,0, 698,0,932,0, 1175,0,932,0, 698,0,587,0,
                        466,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Fading into void (8 bars)
                        932,0,0,0, 698,0,0,0, 466,0,0,0, 311,0,0,0,
                        233,0,0,0, 175,0,0,0, 117,0,0,0, 87,0,0,0,
                        58,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro - low drone
                        58,0,0,0, 58,0,0,0, 58,0,0,0, 58,0,0,0, 65,0,0,0, 65,0,0,0, 52,0,0,0, 52,0,0,0,
                        // Build
                        58,58,0,58, 65,65,0,65, 69,69,0,69, 77,77,0,77, 58,58,0,58, 65,65,0,65, 77,77,0,77, 87,87,0,87,
                        // Drop
                        29,29,29,29, 29,29,29,29, 32,32,32,32, 32,32,32,32,
                        36,36,36,36, 36,36,36,36, 29,29,29,29, 29,29,29,29,
                        58,0,58,0, 65,0,65,0, 77,0,77,0, 87,0,87,0,
                        58,58,0,0, 65,65,0,0, 77,77,0,0, 87,87,0,0,
                        // Bridge
                        77,0,0,0, 87,0,0,0, 98,0,0,0, 116,0,0,0, 98,0,0,0, 87,0,0,0, 77,0,0,0, 0,0,0,0,
                        // Outro
                        58,0,0,0, 52,0,0,0, 46,0,0,0, 39,0,0,0, 29,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                cave: {
                    speed: 125,
                    lead: ['sine', 'triangle', 'sine', 'square'],
                    bassInst: ['sine', 'triangle'],
                    melody: [
                        // INTRO - Echoing drips (8 bars)
                        523,0,261,0, 523,0,261,0, 392,0,196,0, 392,0,196,0,
                        659,0,329,0, 659,0,329,0, 523,0,261,0, 523,0,261,0,
                        329,0,164,0, 329,0,164,0, 261,0,130,0, 261,0,130,0,
                        392,0,196,0, 392,0,196,0, 196,0,98,0, 196,0,0,0,
                        
                        // BUILD - Exploration (8 bars)
                        523,0,0,0, 587,0,0,0, 659,0,0,0, 784,0,0,0,
                        659,0,0,0, 587,0,0,0, 523,0,0,0, 392,0,0,0,
                        523,587,659,784, 880,784,659,587, 523,440,392,349, 329,0,0,0,
                        392,440,523,587, 659,784,880,1046, 1175,0,0,0, 0,0,0,0,
                        
                        // DROP - Crystal cavern (16 bars)
                        1046,0,523,0, 880,0,440,0, 784,0,392,0, 659,0,329,0,
                        523,0,261,0, 392,0,196,0, 329,0,164,0, 261,0,0,0,
                        1046,880,784,659, 523,659,784,880, 1046,1175,1318,1568, 1760,0,0,0,
                        880,0,440,0, 784,0,392,0, 659,0,329,0, 523,0,0,0,
                        
                        659,0,784,0, 880,0,1046,0, 1175,0,1046,0, 880,0,784,0,
                        659,0,587,0, 523,0,494,0, 440,0,392,0, 329,0,0,0,
                        1318,1046,880,784, 659,784,880,1046, 1318,1568,1760,1976, 2093,0,0,0,
                        1046,0,523,0, 880,0,440,0, 784,0,392,0, 659,0,0,0,
                        
                        // BRIDGE - Deep chamber (8 bars)
                        329,0,0,0, 392,0,0,0, 523,0,0,0, 659,0,0,0,
                        784,0,659,0, 523,0,392,0, 329,0,261,0, 196,0,0,0,
                        523,0,587,0, 659,0,784,0, 880,0,1046,0, 1175,0,1318,0,
                        1568,0,1318,0, 1046,0,880,0, 784,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Exit (8 bars)
                        523,0,0,0, 392,0,0,0, 329,0,0,0, 261,0,0,0,
                        196,0,0,0, 164,0,0,0, 130,0,0,0, 98,0,0,0,
                        65,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        65,0,0,0, 0,0,0,0, 82,0,0,0, 0,0,0,0, 87,0,0,0, 0,0,0,0, 65,0,0,0, 0,0,0,0,
                        // Build
                        65,0,65,0, 82,0,82,0, 87,0,87,0, 98,0,98,0, 65,0,65,0, 73,0,73,0, 82,0,82,0, 98,0,0,0,
                        // Drop
                        49,0,0,0, 55,0,0,0, 65,0,0,0, 73,0,0,0,
                        82,0,0,0, 98,0,0,0, 110,0,0,0, 130,0,0,0,
                        65,65,0,65, 73,73,0,73, 82,82,0,82, 98,98,0,98,
                        49,0,49,0, 55,0,55,0, 65,0,65,0, 82,0,0,0,
                        // Bridge
                        82,0,0,0, 98,0,0,0, 130,0,0,0, 164,0,0,0, 196,0,0,0, 164,0,0,0, 130,0,0,0, 0,0,0,0,
                        // Outro
                        65,0,0,0, 55,0,0,0, 49,0,0,0, 41,0,0,0, 32,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                neon: {
                    speed: 100,
                    lead: ['square', 'sawtooth', 'triangle', 'square'],
                    bassInst: ['sawtooth', 'square'],
                    melody: [
                        // INTRO - Synthwave buildup (8 bars)
                        440,0,0,0, 440,0,523,0, 392,0,0,0, 0,0,0,0,
                        349,0,0,0, 349,0,392,0, 329,0,0,0, 0,0,0,0,
                        440,0,440,0, 523,0,587,0, 659,0,659,0, 587,0,523,0,
                        440,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        
                        // BUILD - Ascending (8 bars)
                        440,523,587,659, 440,523,587,659, 440,523,587,659, 784,0,0,0,
                        392,494,587,784, 392,494,587,784, 392,494,587,784, 880,0,0,0,
                        440,0,440,0, 523,0,587,0, 659,0,784,0, 880,0,1046,0,
                        1175,0,1046,0, 880,0,784,0, 659,0,0,0, 0,0,0,0,
                        
                        // DROP - Main synthwave (16 bars)
                        880,0,880,0, 1046,0,1046,0, 1175,0,1046,0, 880,0,784,0,
                        659,0,784,0, 880,0,1046,0, 1175,0,0,0, 0,0,0,0,
                        880,784,659,587, 523,587,659,784, 880,1046,1175,1318, 1568,0,0,0,
                        1046,0,880,0, 784,0,659,0, 587,0,523,0, 440,0,0,0,
                        
                        1046,0,1046,0, 1175,0,1175,0, 1318,0,1175,0, 1046,0,880,0,
                        784,0,880,0, 1046,0,1175,0, 1318,0,1568,0, 1760,0,0,0,
                        880,880,0,880, 784,784,0,784, 659,659,0,659, 587,587,0,587,
                        523,523,587,587, 659,659,784,784, 880,880,1046,1046, 1175,0,0,0,
                        
                        // BRIDGE - Breakdown (8 bars)
                        392,0,0,0, 440,0,0,0, 523,0,0,0, 587,0,0,0,
                        659,0,587,0, 523,0,440,0, 392,0,0,0, 0,0,0,0,
                        440,523,587,659, 784,880,1046,1175, 1318,1568,1760,1976, 2093,0,0,0,
                        1046,0,880,0, 784,0,659,0, 587,0,523,0, 440,0,0,0,
                        
                        // OUTRO - Fadeout with arps (8 bars)
                        440,523,587,659, 440,523,587,659, 392,494,587,784, 392,494,587,784,
                        880,0,0,0, 784,0,0,0, 659,0,0,0, 587,0,0,0,
                        523,0,0,0, 440,0,0,0, 392,0,0,0, 329,0,0,0,
                        261,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        110,0,0,0, 110,0,0,0, 98,0,0,0, 98,0,0,0, 87,0,0,0, 87,0,0,0, 82,0,0,0, 82,0,0,0,
                        // Build
                        110,110,0,110, 110,110,0,110, 98,98,0,98, 98,98,0,98, 87,87,0,87, 87,87,0,87, 130,130,0,130, 130,130,0,130,
                        // Drop
                        110,110,110,110, 110,110,110,110, 98,98,98,98, 98,98,98,98,
                        87,87,87,87, 87,87,87,87, 82,82,82,82, 82,82,82,82,
                        110,0,110,0, 110,0,110,0, 98,0,98,0, 98,0,98,0,
                        87,0,87,0, 87,0,87,0, 130,0,130,0, 130,0,130,0,
                        // Bridge
                        98,0,0,0, 110,0,0,0, 130,0,0,0, 146,0,0,0, 164,0,0,0, 146,0,0,0, 130,0,0,0, 0,0,0,0,
                        // Outro
                        110,0,0,0, 98,0,0,0, 87,0,0,0, 82,0,0,0, 65,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                city: {
                    speed: 100,
                    lead: ['square', 'sawtooth', 'triangle', 'square'],
                    bassInst: ['sawtooth', 'square'],
                    melody: [
                        // Same as neon (city = neon cyberpunk vibe)
                        440,0,0,0, 440,0,523,0, 392,0,0,0, 0,0,0,0,
                        349,0,0,0, 349,0,392,0, 329,0,0,0, 0,0,0,0,
                        440,0,440,0, 523,0,587,0, 659,0,659,0, 587,0,523,0,
                        440,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        440,523,587,659, 440,523,587,659, 440,523,587,659, 784,0,0,0,
                        392,494,587,784, 392,494,587,784, 392,494,587,784, 880,0,0,0,
                        440,0,440,0, 523,0,587,0, 659,0,784,0, 880,0,1046,0,
                        1175,0,1046,0, 880,0,784,0, 659,0,0,0, 0,0,0,0,
                        880,0,880,0, 1046,0,1046,0, 1175,0,1046,0, 880,0,784,0,
                        659,0,784,0, 880,0,1046,0, 1175,0,0,0, 0,0,0,0,
                        880,784,659,587, 523,587,659,784, 880,1046,1175,1318, 1568,0,0,0,
                        1046,0,880,0, 784,0,659,0, 587,0,523,0, 440,0,0,0,
                        1046,0,1046,0, 1175,0,1175,0, 1318,0,1175,0, 1046,0,880,0,
                        784,0,880,0, 1046,0,1175,0, 1318,0,1568,0, 1760,0,0,0,
                        880,880,0,880, 784,784,0,784, 659,659,0,659, 587,587,0,587,
                        523,523,587,587, 659,659,784,784, 880,880,1046,1046, 1175,0,0,0,
                        392,0,0,0, 440,0,0,0, 523,0,0,0, 587,0,0,0,
                        659,0,587,0, 523,0,440,0, 392,0,0,0, 0,0,0,0,
                        440,523,587,659, 784,880,1046,1175, 1318,1568,1760,1976, 2093,0,0,0,
                        1046,0,880,0, 784,0,659,0, 587,0,523,0, 440,0,0,0,
                        440,523,587,659, 440,523,587,659, 392,494,587,784, 392,494,587,784,
                        880,0,0,0, 784,0,0,0, 659,0,0,0, 587,0,0,0,
                        523,0,0,0, 440,0,0,0, 392,0,0,0, 329,0,0,0,
                        261,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        110,0,0,0, 110,0,0,0, 98,0,0,0, 98,0,0,0, 87,0,0,0, 87,0,0,0, 82,0,0,0, 82,0,0,0,
                        110,110,0,110, 110,110,0,110, 98,98,0,98, 98,98,0,98, 87,87,0,87, 87,87,0,87, 130,130,0,130, 130,130,0,130,
                        110,110,110,110, 110,110,110,110, 98,98,98,98, 98,98,98,98,
                        87,87,87,87, 87,87,87,87, 82,82,82,82, 82,82,82,82,
                        110,0,110,0, 110,0,110,0, 98,0,98,0, 98,0,98,0,
                        87,0,87,0, 87,0,87,0, 130,0,130,0, 130,0,130,0,
                        98,0,0,0, 110,0,0,0, 130,0,0,0, 146,0,0,0, 164,0,0,0, 146,0,0,0, 130,0,0,0, 0,0,0,0,
                        110,0,0,0, 98,0,0,0, 87,0,0,0, 82,0,0,0, 65,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                space: {
                    speed: 110,
                    lead: ['square', 'sawtooth', 'sine', 'triangle'],
                    bassInst: ['sawtooth', 'square'],
                    melody: [
                        // INTRO - Launch sequence (8 bars)
                        440,0,0,0, 440,0,880,0, 440,0,0,0, 880,0,0,0,
                        523,0,0,0, 523,0,1046,0, 523,0,0,0, 1046,0,0,0,
                        587,0,0,0, 587,0,1175,0, 659,0,0,0, 1318,0,0,0,
                        784,0,0,0, 880,0,0,0, 1046,0,0,0, 1175,0,0,0,
                        
                        // BUILD - Acceleration (8 bars)
                        440,0,440,0, 880,0,880,0, 1046,0,880,0, 440,0,0,0,
                        523,0,523,0, 1046,0,1046,0, 1318,0,1046,0, 523,0,0,0,
                        587,659,587,659, 784,880,784,880, 1046,1175,1046,1175, 1318,0,0,0,
                        1568,1318,1175,1046, 880,784,659,587, 523,440,392,349, 293,0,0,0,
                        
                        // DROP - Space flight (16 bars)
                        1046,0,1046,0, 1318,0,1318,0, 1568,0,1318,0, 1046,0,880,0,
                        784,0,880,0, 1046,0,1318,0, 1568,0,0,0, 0,0,0,0,
                        1568,1318,1046,880, 784,880,1046,1318, 1568,1760,1976,2093, 2349,0,0,0,
                        1568,0,1318,0, 1046,0,880,0, 784,0,659,0, 587,0,0,0,
                        
                        880,0,880,0, 1760,0,1760,0, 880,0,880,0, 1760,0,1760,0,
                        1046,0,1046,0, 2093,0,2093,0, 1046,0,1046,0, 2093,0,0,0,
                        1760,1760,0,1760, 1568,1568,0,1568, 1318,1318,0,1318, 1175,1175,0,1175,
                        1046,1046,880,880, 784,784,659,659, 587,587,523,523, 440,0,0,0,
                        
                        // BRIDGE - Asteroid field (8 bars)
                        587,0,784,0, 1046,0,1318,0, 1568,0,1318,0, 1046,0,784,0,
                        587,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        784,0,880,0, 1046,0,1175,0, 1318,0,1568,0, 1760,0,1976,0,
                        2093,0,1976,0, 1760,0,1568,0, 1318,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Landing (8 bars)
                        1046,0,0,0, 880,0,0,0, 784,0,0,0, 659,0,0,0,
                        587,0,0,0, 523,0,0,0, 440,0,0,0, 392,0,0,0,
                        293,0,0,0, 220,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        110,0,0,0, 110,0,0,0, 130,0,0,0, 130,0,0,0, 146,0,0,0, 146,0,0,0, 164,0,0,0, 164,0,0,0,
                        // Build
                        110,110,0,110, 130,130,0,130, 146,146,0,146, 164,164,0,164, 146,146,0,146, 164,164,0,164, 196,196,0,196, 220,220,0,220,
                        // Drop
                        110,0,110,0, 110,0,110,0, 130,0,130,0, 130,0,130,0,
                        146,0,146,0, 146,0,146,0, 164,0,164,0, 164,0,164,0,
                        110,110,110,110, 130,130,130,130, 146,146,146,146, 196,196,196,196,
                        220,220,220,220, 246,246,246,246, 261,261,261,261, 293,293,293,293,
                        // Bridge
                        146,0,0,0, 164,0,0,0, 196,0,0,0, 220,0,0,0, 246,0,0,0, 220,0,0,0, 196,0,0,0, 0,0,0,0,
                        // Outro
                        130,0,0,0, 110,0,0,0, 98,0,0,0, 82,0,0,0, 65,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                swamp: {
                    speed: 135,
                    lead: ['sawtooth', 'square', 'triangle', 'sawtooth'],
                    bassInst: ['square', 'sawtooth'],
                    melody: [
                        // INTRO - Murky atmosphere (8 bars)
                        196,0,0,0, 220,0,0,0, 246,0,0,0, 220,0,196,0,
                        174,0,0,0, 155,0,0,0, 138,0,0,0, 155,0,174,0,
                        196,0,220,0, 246,0,277,0, 311,0,277,0, 246,0,220,0,
                        196,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        
                        // BUILD - Sludge rising (8 bars)
                        196,0,196,0, 220,0,220,0, 246,0,246,0, 277,0,277,0,
                        311,0,311,0, 349,0,349,0, 392,0,392,0, 440,0,0,0,
                        196,220,246,277, 311,349,392,440, 494,440,392,349, 311,277,246,220,
                        196,0,220,0, 246,0,277,0, 311,0,0,0, 0,0,0,0,
                        
                        // DROP - Heavy groove (16 bars)
                        392,0,392,0, 440,0,440,0, 494,0,440,0, 392,0,349,0,
                        311,0,349,0, 392,0,440,0, 494,0,0,0, 0,0,0,0,
                        392,392,0,392, 440,440,0,440, 494,494,0,494, 523,523,0,523,
                        587,0,523,0, 494,0,440,0, 392,0,0,0, 0,0,0,0,
                        
                        311,0,311,0, 349,0,349,0, 392,0,349,0, 311,0,277,0,
                        246,0,277,0, 311,0,349,0, 392,0,440,0, 494,0,0,0,
                        587,587,523,523, 494,494,440,440, 392,392,349,349, 311,311,277,277,
                        246,246,220,220, 196,196,174,174, 155,0,0,0, 0,0,0,0,
                        
                        // BRIDGE - Toxic bubbles (8 bars)
                        196,0,246,0, 311,0,392,0, 494,0,392,0, 311,0,246,0,
                        196,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        311,0,349,0, 392,0,440,0, 494,0,523,0, 587,0,659,0,
                        784,0,659,0, 587,0,523,0, 494,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Sinking (8 bars)
                        392,0,0,0, 349,0,0,0, 311,0,0,0, 277,0,0,0,
                        246,0,0,0, 220,0,0,0, 196,0,0,0, 174,0,0,0,
                        155,0,0,0, 138,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        49,0,0,0, 55,0,0,0, 61,0,0,0, 55,0,49,0, 43,0,0,0, 38,0,0,0, 34,0,0,0, 38,0,43,0,
                        // Build
                        49,0,49,0, 55,0,55,0, 61,0,61,0, 69,0,69,0, 77,0,77,0, 87,0,87,0, 98,0,98,0, 110,0,0,0,
                        // Drop
                        49,49,49,49, 49,49,49,49, 55,55,55,55, 55,55,55,55,
                        61,61,61,61, 61,61,61,61, 77,77,77,77, 77,77,77,77,
                        49,0,49,0, 55,0,55,0, 61,0,61,0, 77,0,77,0,
                        87,0,87,0, 98,0,98,0, 110,0,110,0, 123,0,0,0,
                        // Bridge
                        49,0,0,0, 55,0,0,0, 61,0,0,0, 77,0,0,0, 87,0,0,0, 77,0,0,0, 61,0,0,0, 49,0,0,0,
                        // Outro
                        49,0,0,0, 43,0,0,0, 38,0,0,0, 34,0,0,0, 29,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                farm: {
                    speed: 110,
                    lead: ['triangle', 'sine', 'square', 'triangle'],
                    bassInst: ['sine', 'triangle'],
                    melody: [
                        // INTRO - Pastoral morning (8 bars)
                        523,0,0,0, 587,0,0,0, 659,0,0,0, 587,0,523,0,
                        440,0,0,0, 392,0,0,0, 329,0,0,0, 392,0,440,0,
                        523,0,587,0, 659,0,784,0, 880,0,784,0, 659,0,587,0,
                        523,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        
                        // BUILD - Day's work (8 bars)
                        523,0,523,0, 587,0,587,0, 659,0,659,0, 784,0,784,0,
                        659,0,659,0, 587,0,587,0, 523,0,523,0, 440,0,440,0,
                        392,440,523,587, 659,784,880,1046, 1175,1046,880,784, 659,0,0,0,
                        784,659,587,523, 440,392,349,329, 293,329,349,392, 440,0,0,0,
                        
                        // DROP - Harvest celebration (16 bars)
                        784,0,784,0, 880,0,880,0, 1046,0,880,0, 784,0,659,0,
                        523,0,659,0, 784,0,880,0, 1046,0,0,0, 0,0,0,0,
                        1046,880,784,659, 523,659,784,880, 1046,1175,1318,1568, 1760,0,0,0,
                        1046,0,880,0, 784,0,659,0, 523,0,440,0, 392,0,0,0,
                        
                        659,0,659,0, 784,0,784,0, 880,0,784,0, 659,0,587,0,
                        523,0,587,0, 659,0,784,0, 880,0,1046,0, 1175,0,0,0,
                        880,880,0,880, 784,784,0,784, 659,659,0,659, 587,587,0,587,
                        523,523,587,587, 659,659,784,784, 880,880,1046,1046, 1175,0,0,0,
                        
                        // BRIDGE - Peaceful afternoon (8 bars)
                        392,0,0,0, 440,0,0,0, 523,0,0,0, 587,0,0,0,
                        659,0,587,0, 523,0,440,0, 392,0,329,0, 293,0,0,0,
                        523,0,587,0, 659,0,784,0, 880,0,1046,0, 1175,0,1318,0,
                        1568,0,1318,0, 1046,0,880,0, 784,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Sunset (8 bars)
                        523,0,0,0, 440,0,0,0, 392,0,0,0, 329,0,0,0,
                        293,0,0,0, 261,0,0,0, 220,0,0,0, 196,0,0,0,
                        164,0,0,0, 130,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro
                        130,0,0,0, 146,0,0,0, 164,0,0,0, 146,0,130,0, 110,0,0,0, 98,0,0,0, 82,0,0,0, 98,0,110,0,
                        // Build
                        130,0,130,0, 146,0,146,0, 164,0,164,0, 196,0,196,0, 164,0,164,0, 146,0,146,0, 130,0,130,0, 110,0,0,0,
                        // Drop
                        130,130,0,130, 146,146,0,146, 164,164,0,164, 196,196,0,196,
                        164,164,0,164, 146,146,0,146, 130,130,0,130, 110,110,0,110,
                        130,130,130,130, 146,146,146,146, 164,164,164,164, 196,196,196,196,
                        220,220,220,220, 246,246,246,246, 261,261,261,261, 293,293,293,293,
                        // Bridge
                        98,0,0,0, 110,0,0,0, 130,0,0,0, 146,0,0,0, 164,0,0,0, 146,0,0,0, 130,0,0,0, 0,0,0,0,
                        // Outro
                        130,0,0,0, 110,0,0,0, 98,0,0,0, 82,0,0,0, 65,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                jungle: {
                    speed: 105,
                    lead: ['triangle', 'square', 'sawtooth', 'sine'],
                    bassInst: ['sawtooth', 'triangle'],
                    melody: [
                        // INTRO - Tribal awakening (8 bars)
                        392,0,0,0, 523,0,392,0, 329,0,0,0, 392,0,329,0,
                        293,0,0,0, 349,0,293,0, 261,0,0,0, 293,0,261,0,
                        392,0,523,0, 659,0,523,0, 392,0,329,0, 293,0,261,0,
                        392,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        
                        // BUILD - Drumbeat intensifies (8 bars)
                        392,0,392,392, 523,0,523,523, 392,0,392,392, 329,0,329,329,
                        293,0,293,293, 349,0,349,349, 392,0,392,392, 440,0,440,440,
                        523,392,523,392, 659,523,659,523, 784,659,784,659, 880,0,0,0,
                        659,523,392,329, 293,261,220,196, 174,196,220,261, 293,0,0,0,
                        
                        // DROP - Jungle celebration (16 bars)
                        784,0,784,0, 880,0,880,0, 1046,0,880,0, 784,0,659,0,
                        523,0,659,0, 784,0,880,0, 1046,0,0,0, 0,0,0,0,
                        659,523,392,523, 659,784,880,1046, 1175,1046,880,784, 659,0,0,0,
                        784,0,659,0, 523,0,440,0, 392,0,329,0, 293,0,0,0,
                        
                        392,0,523,0, 659,0,784,0, 880,0,784,0, 659,0,523,0,
                        392,0,329,0, 293,0,329,0, 392,0,440,0, 523,0,0,0,
                        1046,880,784,659, 523,659,784,880, 1046,1175,1318,1568, 1760,0,0,0,
                        880,784,659,523, 440,392,329,293, 261,220,196,174, 155,0,0,0,
                        
                        // BRIDGE - Rainforest ambience (8 bars)
                        523,0,392,0, 329,0,261,0, 196,0,261,0, 329,0,392,0,
                        523,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        659,0,523,0, 392,0,329,0, 293,0,349,0, 392,0,440,0,
                        523,587,659,784, 880,1046,1175,1318, 1568,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Sunset in jungle (8 bars)
                        392,0,0,0, 329,0,0,0, 293,0,0,0, 261,0,0,0,
                        220,0,0,0, 196,0,0,0, 174,0,0,0, 155,0,0,0,
                        130,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,
                        0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro - deep tribal drums
                        98,0,0,0, 98,0,0,0, 82,0,0,0, 82,0,0,0, 73,0,0,0, 73,0,0,0, 65,0,0,0, 65,0,0,0,
                        // Build - driving rhythm
                        98,98,0,98, 98,98,0,98, 82,82,0,82, 82,82,0,82, 73,73,0,73, 73,73,0,73, 87,87,0,87, 110,110,0,110,
                        // Drop - powerful bassline
                        98,98,98,98, 98,98,98,98, 82,82,82,82, 82,82,82,82,
                        73,73,73,73, 73,73,73,73, 65,65,65,65, 65,65,65,65,
                        98,0,98,0, 82,0,82,0, 73,0,73,0, 65,0,65,0,
                        87,0,87,0, 98,0,98,0, 110,0,110,0, 130,0,130,0,
                        // Bridge - rhythmic pulse
                        98,0,0,0, 82,0,0,0, 73,0,0,0, 65,0,0,0, 73,0,0,0, 82,0,0,0, 98,0,0,0, 0,0,0,0,
                        // Outro - fading drums
                        98,0,0,0, 82,0,0,0, 73,0,0,0, 65,0,0,0, 49,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ]
                },

                mushroom: {
                    speed: 95,
                    lead: ['sine', 'triangle', 'square', 'sine'],
                    bassInst: ['triangle', 'sine'],
                    melody: [
                        // INTRO - Mystical forest awakening (8 bars)
                        659,0,0,0, 784,0,0,0, 880,0,0,0, 1046,0,0,0,
                        988,0,0,0, 880,0,0,0, 784,0,0,0, 659,0,0,0,
                        523,0,659,0, 784,0,880,0, 1046,0,1175,0, 1318,0,0,0,
                        1046,0,880,0, 784,0,659,0, 523,0,0,0, 0,0,0,0,
                        
                        // BUILD - Spore dance (8 bars)
                        784,0,784,0, 880,0,880,0, 1046,0,1046,0, 1175,0,1175,0,
                        1046,0,1046,0, 880,0,880,0, 784,0,784,0, 659,0,659,0,
                        1318,1175,1046,880, 784,659,523,440, 392,523,659,784, 880,0,0,0,
                        659,523,440,392, 349,440,523,659, 784,880,1046,1175, 1318,0,0,0,
                        
                        // DROP - Magical glow (16 bars)
                        1046,0,1046,0, 1175,0,1175,0, 1318,0,1175,0, 1046,0,880,0,
                        784,0,880,0, 1046,0,1175,0, 1318,0,0,0, 0,0,0,0,
                        1568,1318,1175,1046, 880,784,659,523, 659,784,880,1046, 1175,0,0,0,
                        1318,0,1046,0, 880,0,784,0, 659,0,523,0, 440,0,0,0,
                        
                        880,0,880,0, 1046,0,1046,0, 1175,0,1046,0, 880,0,784,0,
                        659,0,784,0, 880,0,1046,0, 1175,0,1318,0, 1568,0,0,0,
                        1046,1046,0,1046, 880,880,0,880, 784,784,0,784, 659,659,0,659,
                        523,523,659,659, 784,784,880,880, 1046,1046,1175,1175, 1318,0,0,0,
                        
                        // BRIDGE - Twilight whispers (8 bars)
                        523,0,0,0, 659,0,0,0, 784,0,0,0, 880,0,0,0,
                        1046,0,880,0, 784,0,659,0, 523,0,440,0, 392,0,0,0,
                        659,0,784,0, 880,0,1046,0, 1175,0,1318,0, 1568,0,1760,0,
                        1976,0,1760,0, 1568,0,1318,0, 1175,0,0,0, 0,0,0,0,
                        
                        // OUTRO - Spores settling (8 bars)
                        1046,0,0,0, 880,0,0,0, 784,0,0,0, 659,0,0,0,
                        523,0,0,0, 440,0,0,0, 392,0,0,0, 329,0,0,0,
                        293,0,0,0, 261,0,0,0, 220,0,0,0, 196,0,0,0,
                        164,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0
                    ],
                    bass: [
                        // Intro - pulsing bass
                        164,0,0,0, 196,0,0,0, 220,0,0,0, 261,0,0,0,
                        246,0,0,0, 220,0,0,0, 196,0,0,0, 164,0,0,0,
                        // Build
                        164,0,164,0, 196,0,196,0, 220,0,220,0, 246,0,246,0,
                        220,0,220,0, 196,0,196,0, 164,0,164,0, 146,0,146,0,
                        // Drop - bouncing bass
                        164,164,0,164, 196,196,0,196, 220,220,0,220, 246,246,0,246,
                        261,261,0,261, 246,246,0,246, 220,220,0,220, 196,196,0,196,
                        164,164,164,164, 196,196,196,196, 220,220,220,220, 246,246,246,246,
                        261,261,261,261, 293,293,293,293, 329,329,329,329, 349,349,349,349,
                        // Bridge
                        130,0,0,0, 164,0,0,0, 196,0,0,0, 220,0,0,0,
                        246,0,0,0, 220,0,0,0, 196,0,0,0, 164,0,0,0,
                        // Outro
                        164,0,0,0, 146,0,0,0, 130,0,0,0, 110,0,0,0,
                        98,0,0,0, 82,0,0,0, 65,0,0,0, 0,0,0,0
                    ]
                }
            },
            init: function() {
                if (!this.ctx) {
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.ctx = new AudioContext();
		    this.initNoise();
                }
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume().catch(e => console.log(e));
                }
                // Start menu music if not playing
                if (!this.musicPlaying) this.playMusic('menu');
            },

	    // --- NEW: Generate White Noise Buffer (For Explosions & Guns) ---
            initNoise: function() {
                const bufferSize = this.ctx.sampleRate * 2; // 2 seconds of noise
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                this.noiseBuffer = buffer;
            },

            playMusic: function(trackName) {
                if (this.currentTrackName === trackName && this.musicPlaying) return;
                
                this.stopMusic();
                this.currentTrackName = trackName;
                this.musicPlaying = true;
                this.noteIndex = 0;
                
                const track = this.tracks[trackName];
                
                const tick = () => {
                    if (!this.musicPlaying || !this.ctx) return;
                    
                    const melFreq = track.melody[this.noteIndex % track.melody.length];
                    const bassFreq = track.bass[this.noteIndex % track.bass.length];
                    
                    // --- FIX: DYNAMIC INSTRUMENT SWITCHING ---
                    // Calculate which "Section" (16-note bar) we are in
                    const section = Math.floor(this.noteIndex / 16);

                    // Pick the instrument for this section (Loop back if we run out)
                    // If 'leadInst' is a simple string, it uses that. If it's an array, it cycles!
                    let leadType = Array.isArray(track.lead) ? track.lead[section % track.lead.length] : (track.lead || 'triangle');
                    let bassType = Array.isArray(track.bassInst) ? track.bassInst[section % track.bassInst.length] : (track.bassInst || 'sine');

                    if (melFreq > 0) this.tone(melFreq, leadType, 0.1, 0.1, true); 
                    if (bassFreq > 0) this.tone(bassFreq, bassType, 0.3, 0.15, true);
                    // -----------------------------------------

                    this.noteIndex++;
                    this.musicTimer = setTimeout(tick, track.speed);
                };
                
                tick();
            },

            stopMusic: function() {
                this.musicPlaying = false;
                if (this.musicTimer) clearTimeout(this.musicTimer);
                this.musicTimer = null;
                this.currentTrackName = null;
            },

            tone: function(freq, type, dur, vol = 0.1, isMusic = false) {
                if (!this.ctx || this.ctx.state === 'suspended') return;
                
                const masterVol = isMusic ? this.musicVolume : this.sfxVolume;
                if (masterVol <= 0.001) return;

                try {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = type; 
                    o.frequency.setValueAtTime(freq, this.ctx.currentTime);
                    
                    // Attack/Decay envelope
                    const now = this.ctx.currentTime;
                    g.gain.setValueAtTime(0, now);
                    g.gain.linearRampToValueAtTime(vol * masterVol, now + 0.02);
                    g.gain.exponentialRampToValueAtTime(0.001, now + dur);
                    
                    o.connect(g); 
                    g.connect(this.ctx.destination);
                    
                    o.start(); 
                    o.stop(now + dur + 0.1);
                } catch(e) {}
            },
            
	    // --- NEW: Play Noise (For Explosions) ---
            noise: function(dur, vol, filterFreq = 1000) {
                if (!this.ctx || !this.noiseBuffer) return;
                if (this.sfxVolume <= 0.001) return;

                const src = this.ctx.createBufferSource();
                src.buffer = this.noiseBuffer;
                
                // Filter to make it sound like an explosion (Low) or shot (High)
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = filterFreq;

                const g = this.ctx.createGain();
                g.gain.setValueAtTime(vol * this.sfxVolume, this.ctx.currentTime);
                g.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + dur);

                src.connect(filter);
                filter.connect(g);
                g.connect(this.ctx.destination);
                
                src.start();
                src.stop(this.ctx.currentTime + dur);
            },

	    explosion: function() {
                if (!this.ctx) return;
                // Create a low-frequency rumble using the noise generator
                this.noise(0.4, 0.5, 400); 
            },

	    // --- NEW: Complex SFX Engine ---
            shoot: function(type) {
                if (!this.ctx) return;

                // 1. GUNNER: "Bang" (Mid Pitch Saw + Noise Burst)
                if(type === 'gunner') {
                    this.tone(150, 'sawtooth', 0.15, 0.2); // Body
                    this.noise(0.1, 0.3, 1200); // Punch
                } 
                // 2. SNIPER: "BOOM" (Deep decay + Heavy Impact)
                else if(type === 'sniper') {
                    this.tone(80, 'square', 0.4, 0.4); // Deep Body
                    this.noise(0.4, 0.4, 800); // Long Echo
                    // Pitch drop effect
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.frequency.setValueAtTime(300, this.ctx.currentTime);
                    o.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.3);
                    g.gain.setValueAtTime(0.2 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.3);
                }
                // 3. MINIGUN: "Brrrt" (High pitch snap + white noise)
                else if(type === 'minigun') {
                    this.noise(0.05, 0.15, 3000); // Sharp hiss
                    this.tone(200, 'square', 0.05, 0.1); // Undertone
                }
                // 4. MORTAR: "Whump" (Deep Sine Sweep)
                else if(type === 'mortar') {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.frequency.setValueAtTime(150, this.ctx.currentTime);
                    o.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.5); // Pitch Drop
                    g.gain.setValueAtTime(0.5 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.5);
                    this.noise(0.4, 0.2, 500); // Muffled explosion
                }
                // 5. LASER: "Zzap" (Fast High Frequency Sweep)
                else if(type === 'laser') {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sawtooth';
                    o.frequency.setValueAtTime(1500, this.ctx.currentTime);
                    o.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.15); // Fast Drop
                    g.gain.setValueAtTime(0.15 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.2);
                }
                // 6. PLASMA: "Wub" (Frequency Rise)
                else if(type === 'plasma') {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sine';
                    o.frequency.setValueAtTime(200, this.ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.2); // Rise
                    g.gain.setValueAtTime(0.2 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.25);
                }
                // 7. ICE: "Chime" (High Sine + Triangle)
                else if(type === 'ice') {
                    this.tone(1500, 'sine', 0.2, 0.1);
                    this.tone(2000, 'triangle', 0.3, 0.05);
                }
                // 8. FARM: "Ka-Ching" (Two tones)
                else if(type === 'farm') {
                    this.tone(1200, 'sine', 0.1, 0.1);
                    setTimeout(() => this.tone(1800, 'sine', 0.2, 0.1), 100);
                }
            },

            click: function() {
                // UI Click Sound
                this.tone(1200, 'sine', 0.05, 0.05, false);
            },
	    
            hover: function() {
                // High pitch (1000Hz), Super Short (0.03s), Very Quiet (0.02 vol)
                // This creates a subtle "tick" sensation without annoying the user.
                this.tone(1000, 'sine', 0.03, 0.02, false);
            },
	    
            // --- REMASTERED SFX ENGINE ---
            shoot: function(type) {
                if (!this.ctx) return;

                // 1. GUNNER: "Heavy Bolter" (Percussive Thud + Click)
                if(type === 'gunner') {
                    // Layer A: The "Punch" (A deep Sine wave drop, like a kick drum)
                    // We use 'sine' because it has no buzz. It just feels like a physical hit.
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sine'; 
                    o.frequency.setValueAtTime(120, this.ctx.currentTime);
                    o.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1); 
                    
                    g.gain.setValueAtTime(0.5 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                    
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.15);

                    // Layer B: The "Pow" (Burst of noise for the explosion)
                    this.noise(0.1, 0.4, 800); 
                } 
                
                // 2. SNIPER (RANGER): "High-Velocity Rifle" (Whip Crack + Boom)
                else if(type === 'sniper') {
                    // Layer A: Sub-Bass Shockwave (Felt more than heard)
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sine'; 
                    o.frequency.setValueAtTime(100, this.ctx.currentTime);
                    o.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.4); // Drops really low
                    
                    g.gain.setValueAtTime(0.6 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
                    
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.45);

                    // Layer B: The "Crack" (High Speed Bullet breaking air)
                    // Very short, high frequency noise burst
                    this.noise(0.05, 0.3, 2500);

                    // Layer C: Distant Echo (The boom rolling away)
                    setTimeout(() => {
                        this.noise(0.4, 0.2, 200); // Low muffled noise
                    }, 50);
                }
                
                // 3. MINIGUN: "Rotary Cannon" (Tight hiss)
                else if(type === 'minigun') {
                    this.noise(0.04, 0.15, 3000); // Sharp hiss
                    this.tone(100, 'square', 0.04, 0.05); // Low metallic undertone
                }
                
                // 4. MORTAR: "Thump" (Deep Sine Sweep)
                else if(type === 'mortar') {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.frequency.setValueAtTime(150, this.ctx.currentTime);
                    o.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.5); 
                    g.gain.setValueAtTime(0.5 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.5);
                    this.noise(0.4, 0.2, 500); // Muffled explosion
                }
                
                // 5. LASER: "Zzap" (Fast High Frequency Sweep)
                else if(type === 'laser') {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sawtooth';
                    o.frequency.setValueAtTime(1500, this.ctx.currentTime);
                    o.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.15); 
                    g.gain.setValueAtTime(0.15 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.2);
                }
                
                // 6. PLASMA: "Wub" (Frequency Rise)
                else if(type === 'plasma') {
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sine';
                    o.frequency.setValueAtTime(200, this.ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(800, this.ctx.currentTime + 0.2); 
                    g.gain.setValueAtTime(0.2 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.25);
                }
                
                // 7. ICE: "Chime" (Glassy)
                else if(type === 'ice') {
                    this.tone(1500, 'sine', 0.2, 0.1);
                    this.tone(2000, 'triangle', 0.3, 0.05);
                }
                
                // 8. FARM: "Ka-Ching" (Coin sound)
                else if(type === 'farm') {
                    this.tone(1200, 'sine', 0.1, 0.1);
                    setTimeout(() => this.tone(1800, 'sine', 0.2, 0.1), 100);
                }
                
                // 9. TESLA: "Arc" (Static Snap)
                else if(type === 'tesla') {
                     this.tone(800, 'square', 0.1, 0.1);
                     this.noise(0.1, 0.2, 2000); 
                }
                
                // 10. FLAMETHROWER: "Whoosh" (Blowtorch/Gas sound)
                else if(type === 'flamethrower') {
                    // High-frequency hiss (gas escaping)
                    this.noise(0.15, 0.25, 4000);
                    
                    // Low rumble (fire combustion)
                    const o = this.ctx.createOscillator();
                    const g = this.ctx.createGain();
                    o.type = 'sawtooth';
                    o.frequency.setValueAtTime(80, this.ctx.currentTime);
                    o.frequency.linearRampToValueAtTime(120, this.ctx.currentTime + 0.15);
                    g.gain.setValueAtTime(0.3 * this.sfxVolume, this.ctx.currentTime);
                    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
                    o.connect(g); g.connect(this.ctx.destination);
                    o.start(); o.stop(this.ctx.currentTime + 0.2);
                }
            },
            
            lifeLoss: function() {
                if (!this.ctx) return;
                // Dramatic alarm sound (two-tone siren)
                const o1 = this.ctx.createOscillator();
                const g1 = this.ctx.createGain();
                o1.type = 'square';
                o1.frequency.setValueAtTime(400, this.ctx.currentTime);
                o1.frequency.setValueAtTime(300, this.ctx.currentTime + 0.15);
                o1.frequency.setValueAtTime(400, this.ctx.currentTime + 0.3);
                g1.gain.setValueAtTime(0.4 * this.sfxVolume, this.ctx.currentTime);
                g1.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
                o1.connect(g1); g1.connect(this.ctx.destination);
                o1.start(); o1.stop(this.ctx.currentTime + 0.4);
            },
            
            setSFXVolume: function(val) { this.sfxVolume = val / 100; },
            setMusicVolume: function(val) { this.musicVolume = val / 100; }
        };

        // Helper for UI clicks
        function playClick() { 
            try {
                if(typeof AudioSys !== 'undefined' && AudioSys.click) {
                    AudioSys.click(); 
                }
            } catch(e) {
                // Audio system not ready, ignore
            }
        }
        window.setSFXVolume = function(val) { AudioSys.setSFXVolume(val); saveSettings(); }
        window.setMusicVolume = function(val) { AudioSys.setMusicVolume(val); saveSettings(); }

        /** --- MAP DATA --- */
        const MAPS = [
            {
                name: "Canyon Crossing",
                track: 'canyon',
                floorColor: 0x1e272e,
                path: [
                    new THREE.Vector3(-60, 0, -32), new THREE.Vector3(-20, 0, -32),
                    new THREE.Vector3(-20, 0, 12), new THREE.Vector3(20, 0, 12),
                    new THREE.Vector3(20, 0, -12), new THREE.Vector3(60, 0, -12),
                    new THREE.Vector3(60, 0, 32), new THREE.Vector3(-60, 0, 32)
                ]
            },
            {
                name: "Frozen Route",
                track: 'frozen',
                floorColor: 0x2c3e50,
                path: [
                    new THREE.Vector3(-60, 0, 40), new THREE.Vector3(-60, 0, -20),
                    new THREE.Vector3(-20, 0, -20), new THREE.Vector3(-20, 0, 20),
                    new THREE.Vector3(20, 0, 20), new THREE.Vector3(20, 0, -20),
                    new THREE.Vector3(60, 0, -20), new THREE.Vector3(60, 0, 40)
                ]
            },
{
                name: "Volcanic Core",
                track: 'volcano',
                floorColor: 0x1a0f0f, // Very dark red/black
                path: [
                    new THREE.Vector3(-70, 0, -40), 
                    new THREE.Vector3(0, 0, -20),   // Zig
                    new THREE.Vector3(-50, 0, 0),   // Zag
                    new THREE.Vector3(50, 0, 0),    // Zig
                    new THREE.Vector3(0, 0, 20),    // Zag
                    new THREE.Vector3(70, 0, 40)
                ]
            },
		{
                name: "Kitty Kingdom",
                track: 'kitty',
                floorColor: 0xffe6ea, 
                path: [
                    // Fixed coordinates to be multiples of 4 (Grid Size)
                    new THREE.Vector3(-72, 0, 40), 
                    new THREE.Vector3(-28, 0, 40),
                    new THREE.Vector3(-28, 0, -20), 
                    new THREE.Vector3(28, 0, -20),  
                    new THREE.Vector3(28, 0, 20),   
                    new THREE.Vector3(-8, 0, 20),  
                    new THREE.Vector3(-8, 0, -40), 
                    new THREE.Vector3(72, 0, -40)
                ]
            },
		{
                name: "The Void",
                track: 'void',
                floorColor: 0x0a0a0a, // Almost pitch black
                path: [
                    // A perfect straight line from Left to Right
                    new THREE.Vector3(-100, 0, 0), 
                    new THREE.Vector3(100, 0, 0)
                ]
            },
            {
                name: "Crystal Caves",
                track: 'cave',
                floorColor: 0x1a0b2e, // Deep Purple
                path: [
                    // Start (Left) - Uses -90 (Center of tile)
                    new THREE.Vector3(-92, 0, -52),
                    
                    // First Loop (Up)
                    new THREE.Vector3(-52, 0, -52), 
                    new THREE.Vector3(-52, 0, 52),   

                    // Second Loop (Down)
                    new THREE.Vector3(-12, 0, 52),
                    new THREE.Vector3(-12, 0, -52),

                    // Third Loop (Up)
                    new THREE.Vector3(32, 0, -52),
                    new THREE.Vector3(32, 0, 52),

                    // Fourth Loop (Down)
                    new THREE.Vector3(72, 0, 52),
                    new THREE.Vector3(72, 0, -52),

                    // End (Right) - Uses 90 (Center of tile)
                    new THREE.Vector3(92, 0, -52)
                ]
            },
            {
                name: "Neon City",
                track: 'city',
                floorColor: 0x0f0f2e, // Dark cyber blue
                path: [
                    new THREE.Vector3(-80, 0, 40),
                    new THREE.Vector3(-40, 0, 40),
                    new THREE.Vector3(-40, 0, -10),
                    new THREE.Vector3(0, 0, -10),
                    new THREE.Vector3(0, 0, 20),
                    new THREE.Vector3(40, 0, 20),
                    new THREE.Vector3(40, 0, -40),
                    new THREE.Vector3(80, 0, -40)
                ]
            },
            {
                name: "Toxic Swamp",
                track: 'swamp',
                floorColor: 0x1a2a1a, // Dark green
                path: [
                    new THREE.Vector3(-90, 0, 20),
                    new THREE.Vector3(-50, 0, -20),
                    new THREE.Vector3(-10, 0, 20),
                    new THREE.Vector3(30, 0, -20),
                    new THREE.Vector3(70, 0, 20),
                    new THREE.Vector3(90, 0, 40)
                ]
            },
            {
                name: "Space Station",
                track: 'space',
                floorColor: 0x0a0a1a, // Deep space black
                path: [
                    new THREE.Vector3(-60, 0, -40),
                    new THREE.Vector3(0, 0, -40),
                    new THREE.Vector3(0, 0, 0),
                    new THREE.Vector3(-40, 0, 0),
                    new THREE.Vector3(-40, 0, 30),
                    new THREE.Vector3(40, 0, 30),
                    new THREE.Vector3(40, 0, -10),
                    new THREE.Vector3(60, 0, -10),
                    new THREE.Vector3(60, 0, 40)
                ]
            }
        ,
            {
                name: "Harvest Valley",
                track: 'farm',
                floorColor: 0x8b7355, // Brown/tan dirt color
                path: [
                    // Winding farm path through fields (ALL MULTIPLES OF 4)
                    new THREE.Vector3(-80, 0, 40),
                    new THREE.Vector3(-40, 0, 40),
                    new THREE.Vector3(-40, 0, 0),
                    new THREE.Vector3(-60, 0, 0),
                    new THREE.Vector3(-60, 0, -32),
                    new THREE.Vector3(0, 0, -32),
                    new THREE.Vector3(0, 0, 12),
                    new THREE.Vector3(40, 0, 12),
                    new THREE.Vector3(40, 0, -40),
                    new THREE.Vector3(80, 0, -40)
                ]
            },
            {
                name: "Jungle Temple",
                track: 'jungle',
                floorColor: 0x2d4a2b, // Dark jungle green
                path: [
                    // Winding river through dense jungle (ALL MULTIPLES OF 4)
                    new THREE.Vector3(-80, 0, -40),
                    new THREE.Vector3(-52, 0, -20),
                    new THREE.Vector3(-52, 0, 20),
                    new THREE.Vector3(-20, 0, 20),
                    new THREE.Vector3(-20, 0, -12),
                    new THREE.Vector3(12, 0, -12),
                    new THREE.Vector3(12, 0, 28),
                    new THREE.Vector3(40, 0, 28),
                    new THREE.Vector3(40, 0, -20),
                    new THREE.Vector3(68, 0, -20),
                    new THREE.Vector3(68, 0, 40),
                    new THREE.Vector3(92, 0, 40)
                ]
            },
            {
                name: "Mushroom Forest",
                track: 'mushroom',
                floorColor: 0x3d2817, // Dark forest floor brown
                path: [
                    // Medium difficulty: Moderate length with curves (not too many corners)
                    // Winding forest path through giant mushrooms
                    new THREE.Vector3(-84, 0, -32),
                    new THREE.Vector3(-48, 0, -32),
                    new THREE.Vector3(-48, 0, 16),
                    new THREE.Vector3(-16, 0, 16),
                    new THREE.Vector3(-16, 0, -24),
                    new THREE.Vector3(24, 0, -24),
                    new THREE.Vector3(24, 0, 20),
                    new THREE.Vector3(56, 0, 20),
                    new THREE.Vector3(56, 0, -36),
                    new THREE.Vector3(88, 0, -36)
                ]
            }];

	function loadCustomIcons() {
            // 1. Link Towers
            Object.keys(TOWERS).forEach(key => {
                // This tells the game: "The icon for 'gunner' is at 'assets/towers/gunner.png'"
                TOWER_ICONS[key] = `assets/towers/${key}.png`;
            });

            // 2. Link Enemies
            Object.keys(ENEMIES).forEach(key => {
                // Special check for spaces (e.g. 'shadow interceptor' -> 'shadow%20interceptor.png')
                // But usually browsers handle spaces fine locally.
                ENEMY_ICONS[key] = `assets/enemies/${key}.png`;
            });
        }

        /** --- CONFIG --- */
        const MAX_LEVEL = 5;
        const GRID_SIZE = 4;
        const ROAD_WIDTH = 4.0;
        
        let GAME_CONFIG = { maxWaves: 20, hpMult: 1.0, costMult: 1.0, gold: 650 };
        const ENEMIES = {
            red:    { color: 0xff0000, hp: 20, speed: 0.22, size: 1.0, score: 5 },
            blue:   { color: 0x3498db, hp: 35, speed: 0.30, size: 0.9, score: 10 },
            green:  { color: 0x27ae60, hp: 60, speed: 0.25, size: 1.0, score: 15 },
            yellow: { color: 0xf1c40f, hp: 40, speed: 0.55, size: 0.8, score: 20 },
            white:  { color: 0xecf0f1, hp: 30, speed: 0.50, size: 0.8, score: 20 },
            pink:   { color: 0xff69b4, hp: 25, speed: 0.75, size: 0.7, score: 25 },
            'shadow interceptor':  { color: 0x222222, hp: 120,speed: 0.20, size: 1.0, score: 30 },
            tank:   { color: 0x7f8c8d, hp: 300,speed: 0.15, size: 1.2, score: 40 }, // Armored
            zebra:  { color: 0xbdc3c7, hp: 140,speed: 0.40, size: 1.1, score: 40 },
            rainbow:{ color: 0xe67e22, hp: 230,speed: 0.55, size: 1.1, score: 50 },
            omnicrawler:{ color: 0xd35400, hp: 800,speed: 0.20, size: 1.3, score: 100 },
            
            // BOSSES
            'siege walker':   { color: 0x3498db, hp: 3000, speed: 0.15, size: 2.5, score: 500, type:'boss' },
            'dreadnought':    { color: 0xe74c3c, hp: 8000, speed: 0.10, size: 3.5, score: 1000, type:'boss' },
            'the obliterator':   { color: 0x27ae60, hp: 20000,speed: 0.08, size: 4.5, score: 3000, type:'boss' },
            'void stalker':    { color: 0x2c3e50, hp: 5000, speed: 0.45, size: 2.0, score: 2000, type:'boss' },
            'entropy monolith':    { color: 0x8e44ad, hp: 50000,speed: 0.05, size: 6.0, score: 10000, type:'boss' },

	    // SPECIALS
            healer: { color: 0x00ff00, hp: 200, speed: 0.25, size: 1.3, score: 60, type:'special', ability:'heal' },
            disruptor:{ color: 0x00ffff, hp: 300, speed: 0.35, size: 1.1, score: 70, type:'special', ability:'stun' },
            summoner: { color: 0x8e44ad, hp: 750,speed: 0.15, size: 1.6, score: 100,type:'special', ability:'summon' },
        };

	const TOWER_UPGRADES = {
            gunner: {
                A: { name: "Doomsday", desc: "Huge Damage & Splash", dmgMult: 4.0, rateMult: 1.5, rangeMult: 1.2, splash: 6, color: 0x2c3e50, cost: 2300 },
                B: { name: "Shredder", desc: "Insane Fire Rate", dmgMult: 0.8, rateMult: 0.25, rangeMult: 1.0, color: 0xc0392b, cost: 2900 }
            },
            sniper: {
                A: { name: "Cripple", desc: "Stuns MOABs", dmgMult: 1.5, rateMult: 1.0, rangeMult: 1.2, special: 'stun_boss', color: 0x8e44ad, cost: 3500 },
                B: { name: "Elite", desc: "Full Auto Fire", dmgMult: 0.6, rateMult: 0.3, rangeMult: 1.0, color: 0xf1c40f, cost: 3200 }
            },
            minigun: {
                A: { name: "Vulcan", desc: "No Spread Stream", dmgMult: 1.5, rateMult: 0.8, rangeMult: 1.2, color: 0xe67e22, cost: 4200 },
                B: { name: "Rockets", desc: "Explosive Rounds", dmgMult: 3.0, rateMult: 2.0, rangeMult: 1.0, splash: 5, color: 0x7f8c8d, cost: 4800 }
            },
            cannon: {
                A: { name: "Howitzer", desc: "Massive Explosions", dmgMult: 2.5, rateMult: 1.2, rangeMult: 1.3, splash: 10, color: 0x34495e, cost: 3800 },
                B: { name: "Grapeshot", desc: "Triple Cannonballs", dmgMult: 0.7, rateMult: 0.4, rangeMult: 1.0, splash: 4, color: 0x7f8c8d, cost: 3200 }
            },
            flamethrower: {
                A: { name: "Dragon's Breath", desc: "Long Lasting Burns", dmgMult: 1.5, rateMult: 1.0, rangeMult: 1.3, dotAdd: 5, dotDurMult: 2.5, color: 0xff6600, cost: 4200 },
                B: { name: "Ring of Fire", desc: "360° Inferno", dmgMult: 0.8, rateMult: 0.5, rangeMult: 0.8, special: 'area_fire', color: 0xffaa00, cost: 3800 }
            },
            mortar: {
                A: { name: "Nuke", desc: "Massive Nuke", dmgMult: 5.0, rateMult: 1.5, rangeMult: 1.2, splash: 15, color: 0x27ae60, cost: 5500 },
                B: { name: "Battery", desc: "Triple Shot", dmgMult: 0.8, rateMult: 0.3, rangeMult: 1.0, color: 0x2980b9, cost: 4500 }
            },
            tesla: {
                A: { name: "Superbolt", desc: "Chains 10 Enemies", dmgMult: 1.2, rateMult: 1.0, chainAdd: 7, color: 0x3498db, cost: 4900 },
                B: { name: "Plasma Arc", desc: "Single Target Melter", dmgMult: 4.0, rateMult: 0.8, chainSet: 1, color: 0x9b59b6, cost: 5800 }
            },
            ice: {
                A: { name: "Absolute Zero", desc: "Freeze Aura", dmgMult: 1.0, rateMult: 1.0, slowAdd: 0.3, rangeMult: 1.5, color: 0x00cec9, cost: 3000 },
                B: { name: "Icicles", desc: "Shoots Spikes", dmgMult: 5.0, rateMult: 0.5, rangeMult: 1.2, color: 0xffffff, cost: 3800 }
            },
            laser: {
                A: { name: "Death Ray", desc: "Insta-Destroy Damage", dmgMult: 5.0, rateMult: 1.0, rangeMult: 1.2, color: 0xff0000, cost: 6500 },
                B: { name: "Splitter", desc: "Hits 3 Targets", dmgMult: 0.8, rateMult: 1.0, rangeMult: 1.0, special: 'multi_target', color: 0xe91e63, cost: 5200 }
            },
            plasma: {
                A: { name: "Sun God", desc: "Massive Area", dmgMult: 2.0, rateMult: 1.0, splash: 10, color: 0xf1c40f, cost: 12500 },
                B: { name: "Black Hole", desc: "90% Slow Field", dmgMult: 0.5, rateMult: 0.5, splash: 6, special: 'black_hole', color: 0x000000, cost: 16000 }
            },
            farm: {
                A: { name: "Bank", desc: "Huge Payouts", incomeAdd: 150, rateMult: 1.5, color: 0xf39c12, cost: 3500 },
                B: { name: "Factory", desc: "Fast Production", incomeAdd: 50, rateMult: 0.5, color: 0x7f8c8d, cost: 4200 }
            }
        };

        const TOWERS = {
            // Global rebalance: slightly higher base costs to reduce extreme early-game spam on all difficulties
            gunner: { name: "Gunner", cost: 130, range: 14, dmg: 10, rate: 0.8, color: 0x7f8c8d, category: 'offense', hotkey: '1' },
            sniper: { name: "Ranger", cost: 280, range: 40, dmg: 50, rate: 2.5, color: 0x27ae60, category: 'offense', hotkey: '2' },
            ice:    { name: "Cryo",   cost: 330, range: 12, dmg: 5,  rate: 1.0, color: 0x00cec9, slow: 0.5, stunChance: 0.1, stunDur: 0.5, category: 'support', hotkey: '3' },
            minigun:{ name: "Gatling",cost: 430, range: 12, dmg: 4,  rate: 0.1, color: 0xf39c12, category: 'offense', hotkey: '4' },
            cannon: { name: "Cannon", cost: 500, range: 18, dmg: 30, rate: 2.0, color: 0x95a5a6, splash: 6, category: 'offense', hotkey: '5' },
            flamethrower: { name: "Inferno", cost: 600, range: 10, dmg: 0.5, rate: 0.1, color: 0xff4500, dot: 2, dotDuration: 3.0, category: 'special', hotkey: 'Q' },
            mortar: { name: "Mortar", cost: 550, range: 50, dmg: 60, rate: 3.5, color: 0x34495e, splash: 10, minRange: 12, category: 'offense', hotkey: '6' },
            tesla:  { name: "Tesla",  cost: 700, range: 12, dmg: 15, rate: 0.9, color: 0x3498db, chain: 3, jump: 6, category: 'special', hotkey: '7' },
            laser:  { name: "Laser",  cost: 800, range: 16, dmg: 2,  rate: 0.05,color: 0xe74c3c, category: 'special', hotkey: '8' },
            plasma: { name: "Plasma", cost: 1300,range: 14, dmg: 60, rate: 1.5, color: 0x9b59b6, splash: 5, category: 'special', hotkey: '9' },
            farm:   { name: "Farm",   cost: 550, range: 0,  dmg: 0,  rate: 5.0, color: 0x27ae60, income: 40, category: 'economy', hotkey: '0' }
        };

        // Extended Wave Generator
        function getWaveData(w) {
            // Bosses at checkpoints (unchanged)
            if(w === 20) return [{ type: 'siege walker', count: 1, interval: 2000 }];
            if(w === 30) return [{ type: 'dreadnought', count: 1, interval: 2000 }];
            if(w === 40) return [{ type: 'the obliterator', count: 1, interval: 2000 }];
            if(w === 50) return [{ type: 'void stalker', count: 3, interval: 2000 }];
            if(w === 60) return [{ type: 'entropy monolith', count: 1, interval: 2000 }];
            
            const wavePlan = [];
            
            // Phase 1: Basics (1-10)
            if(w < 3) wavePlan.push({ type: 'red', count: 5+w*3, interval: 600 });
            else if(w < 6) { wavePlan.push({ type: 'red', count: 10, interval: 300 }); wavePlan.push({ type: 'blue', count: w, interval: 800 }); }
            else if(w < 11) { wavePlan.push({ type: 'blue', count: 15, interval: 400 }); wavePlan.push({ type: 'green', count: 5, interval: 1000 }); }
            
            // Phase 2: Introduction of Specials (11-20)
            else if(w < 15) { 
                wavePlan.push({ type: 'green', count: 10, interval: 500 }); 
                if(w>12) wavePlan.push({ type: 'healer', count: 2, interval: 2000 }); // NEW
            }
            else if(w < 20) { 
                wavePlan.push({ type: 'yellow', count: 20, interval: 200 }); 
                wavePlan.push({ type: 'disruptor', count: 3, interval: 1500 }); // NEW
            }
            
            // Phase 3: Combinations (21-30)
            else if(w < 25) { 
                wavePlan.push({ type: 'white', count: 20, interval: 200 }); 
                wavePlan.push({ type: 'summoner', count: 2, interval: 4000 }); // NEW
            }
            else if(w < 30) { 
                wavePlan.push({ type: 'zebra', count: 15, interval: 300 }); 
                wavePlan.push({ type: 'healer', count: 5, interval: 1000 }); 
                wavePlan.push({ type: 'disruptor', count: 5, interval: 1000 });
            }
            
            // Phase 4: Chaos (31-40)
            else if(w < 35) { wavePlan.push({ type: 'rainbow', count: 10, interval: 500 }); wavePlan.push({ type: 'omnicrawler', count: 2, interval: 2000 }); }
            else if(w < 40) { 
                wavePlan.push({ type: 'omnicrawler', count: 10, interval: 1200 }); 
                wavePlan.push({ type: 'summoner', count: 4, interval: 3000 }); // Army builders
            }
            
            // Phase 5: Hardcore (41-60)
            else if(w < 50) { 
                wavePlan.push({ type: 'bfb', count: 1, interval: 1000 }); 
                wavePlan.push({ type: 'healer', count: 10, interval: 500 }); // Medic train
            }
            else { 
                wavePlan.push({ type: 'zomg', count: 1, interval: 5000 }); 
                wavePlan.push({ type: 'disruptor', count: 10, interval: 400 }); // Tower shutdown
            }

            return wavePlan;
        }

	// --- MAP DECORATIONS ---
        function createDecorations(mapIndex) {
            const isFrozen = (mapIndex === 1); 
            const isVolcano = (mapIndex === 2);
	    const isKitty = (mapIndex === 3);
	    const isVoid = (mapIndex === 4); 
            const isCrystalCave = (mapIndex === 5);
            const isNeonCity = (mapIndex === 6);
            const isToxicSwamp = (mapIndex === 7);
            const isSpaceStation = (mapIndex === 8);
	    const isFarm = (mapIndex === 9);
            const isJungle = (mapIndex === 10);
            const isMushroom = (mapIndex === 11);
	    
            const propCount = 70;

            // === MATERIAL LIBRARY ===
            const matPine = new THREE.MeshStandardMaterial({ color: 0x1e8449, roughness: 0.8 });
            const matWood = new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 1.0 });
            const matSnow = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.3 });
            const matIce = new THREE.MeshStandardMaterial({ color: 0xaaddff, transparent: true, opacity: 0.7, metalness: 0.5 });
            const matSand = new THREE.MeshStandardMaterial({ color: 0xd35400, roughness: 1.0 });
            const matCactus = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 0.9 });
            const matBasalt = new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.4, metalness: 0.3 });
            const matMagma = new THREE.MeshBasicMaterial({ color: 0xff4500 });
	    const matPink = new THREE.MeshStandardMaterial({ color: 0xff69b4, roughness: 0.5 });
            const matPastel = new THREE.MeshStandardMaterial({ color: 0xffb7c5, roughness: 0.9 });
            const matWhite = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 });
            const matRedBow = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.4 });
            const matGreen = new THREE.MeshStandardMaterial({ color: 0x2ecc71, roughness: 0.8 });
            const matYellow = new THREE.MeshStandardMaterial({ color: 0xf1c40f });
            // Mushroom materials
            const matMushroomRed = new THREE.MeshStandardMaterial({ color: 0xff4444, roughness: 0.6 });
            const matMushroomBlue = new THREE.MeshStandardMaterial({ color: 0x4488ff, roughness: 0.6 });
            const matMushroomPurple = new THREE.MeshStandardMaterial({ color: 0x9966ff, roughness: 0.6 });
            const matMushroomSpots = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.5 });
            const matMushroomStem = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.8 });
            const matMushroomGlow = new THREE.MeshStandardMaterial({ 
                color: 0x88ffaa, 
                emissive: 0x44ff88, 
                emissiveIntensity: 0.5,
                roughness: 0.3 
            });
            const matMoss = new THREE.MeshStandardMaterial({ color: 0x4a7c4a, roughness: 1.0 });
	    const matHay = new THREE.MeshStandardMaterial({ color: 0xeaddca, roughness: 1.0 });
            const matOakLeaf = new THREE.MeshStandardMaterial({ color: 0x228b22, roughness: 0.8 });
            const matPumpkin = new THREE.MeshStandardMaterial({ color: 0xff7518, roughness: 0.6 });
            const matCorn = new THREE.MeshStandardMaterial({ color: 0xd4af37, roughness: 0.9 });
            const matFence = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 1.0 });
            // Jungle materials
            const matJungleLeaf = new THREE.MeshStandardMaterial({ color: 0x1a5c1a, roughness: 0.9 });
            const matVine = new THREE.MeshStandardMaterial({ color: 0x3d6b3d, roughness: 1.0 });
            const matStone = new THREE.MeshStandardMaterial({ color: 0x7a7a7a, roughness: 0.8 });
            const matOrchid = new THREE.MeshStandardMaterial({ color: 0xff00ff, roughness: 0.3 });
            const matBamboo = new THREE.MeshStandardMaterial({ color: 0x6b8e23, roughness: 0.7 });

            for(let i = 0; i < propCount; i++) {
                const x = (seededRandom() - 0.5) * 220;
                const z = (seededRandom() - 0.5) * 160;
                const pos = new THREE.Vector3(x, 0, z);

                // Road Check
                let tooClose = false;
                for(let j=0; j<currentWaypoints.length-1; j++) {
                    const a = currentWaypoints[j];
                    const b = currentWaypoints[j+1];
                    const lineLen = a.distanceToSquared(b);
                    if (lineLen === 0) continue;
                    const t = Math.max(0, Math.min(1, ((pos.x - a.x) * (b.x - a.x) + (pos.z - a.z) * (b.z - a.z)) / lineLen));
                    const proj = new THREE.Vector3().copy(a).add(new THREE.Vector3().subVectors(b, a).multiplyScalar(t));
                    if (pos.distanceTo(proj) < 10) { tooClose = true; break; }
                }
                if(tooClose) continue; 

                const group = new THREE.Group();
                group.position.copy(pos);
                const s = 0.8 + seededRandom() * 0.6;
                group.scale.set(s, s, s);
                group.rotation.y = seededRandom() * Math.PI * 2;

                // ═══════════════════════════════════════════
                // 0. CANYON CROSSING - Desert/Rocky Theme (DEFAULT)
                // ═══════════════════════════════════════════
                if (mapIndex === 0) {
                    const rng = seededRandom();
                    
                    if (rng > 0.7) {
                        // SAGUARO CACTUS - Tall with arms
                        const main = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 5, 8), matCactus);
                        main.position.y = 2.5;
                        
                        // Left arm
                        const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2, 8), matCactus);
                        arm1.position.set(-1, 3, 0);
                        arm1.rotation.z = Math.PI/2;
                        const arm1up = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8), matCactus);
                        arm1up.position.set(-2, 3.75, 0);
                        
                        // Right arm
                        const arm2 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8), matCactus);
                        arm2.position.set(1, 2.5, 0);
                        arm2.rotation.z = -Math.PI/2;
                        const arm2up = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2, 8), matCactus);
                        arm2up.position.set(1.75, 3.5, 0);
                        
                        // Flowers on top
                        const flower = new THREE.Mesh(
                            new THREE.ConeGeometry(0.3, 0.4, 8),
                            new THREE.MeshStandardMaterial({color: 0xff69b4, roughness: 0.5})
                        );
                        flower.position.y = 5.2;
                        
                        group.add(main, arm1, arm1up, arm2, arm2up, flower);
                    }
                    else if (rng > 0.5) {
                        // DESERT ROCK FORMATION - Layered sandstone
                        const layers = 4 + Math.floor(Math.random()*3);
                        for(let k=0; k<layers; k++) {
                            const width = 2.5 - k*0.3;
                            const layer = new THREE.Mesh(
                                new THREE.BoxGeometry(width, 0.8, width),
                                new THREE.MeshStandardMaterial({
                                    color: 0xd2691e - k*0x101010,
                                    roughness: 1.0
                                })
                            );
                            layer.position.y = k*0.8 + 0.4;
                            layer.rotation.y = k * 0.3;
                            group.add(layer);
                        }
                    }
                    else if (rng > 0.3) {
                        // TUMBLEWEED - Desert plant ball
                        const tumbleweed = new THREE.Mesh(
                            new THREE.IcosahedronGeometry(1, 1),
                            new THREE.MeshStandardMaterial({
                                color: 0x8b7355,
                                wireframe: true
                            })
                        );
                        tumbleweed.position.y = 1;
                        group.add(tumbleweed);
                    }
                    else if (rng > 0.15) {
                        // BARREL CACTUS - Round spiky plant
                        const body = new THREE.Mesh(
                            new THREE.SphereGeometry(1, 12, 8),
                            matCactus
                        );
                        body.scale.y = 0.7;
                        body.position.y = 0.7;
                        
                        // Spines (vertical ridges)
                        for(let k=0; k<12; k++) {
                            const angle = (k/12) * Math.PI * 2;
                            const spine = new THREE.Mesh(
                                new THREE.BoxGeometry(0.05, 1.4, 0.05),
                                new THREE.MeshStandardMaterial({color: 0xffffff})
                            );
                            spine.position.set(Math.cos(angle)*0.95, 0.7, Math.sin(angle)*0.95);
                            group.add(spine);
                        }
                        
                        // Flower on top
                        const flower = new THREE.Mesh(
                            new THREE.ConeGeometry(0.2, 0.3, 6),
                            matYellow
                        );
                        flower.position.y = 1.4;
                        
                        group.add(body, flower);
                    }
                    else {
                        // DESERT BONES - Skull decoration
                        const skull = new THREE.Mesh(
                            new THREE.SphereGeometry(0.6),
                            new THREE.MeshStandardMaterial({color: 0xf5f5dc, roughness: 0.9})
                        );
                        skull.scale.set(1, 0.8, 1);
                        skull.position.y = 0.5;
                        
                        // Eye sockets
                        const eye1 = new THREE.Mesh(
                            new THREE.SphereGeometry(0.15),
                            new THREE.MeshStandardMaterial({color: 0x000000})
                        );
                        eye1.position.set(-0.2, 0.5, 0.5);
                        const eye2 = eye1.clone();
                        eye2.position.set(0.2, 0.5, 0.5);
                        
                        // Horns
                        const horn1 = new THREE.Mesh(
                            new THREE.ConeGeometry(0.1, 0.5, 6),
                            new THREE.MeshStandardMaterial({color: 0xdeb887})
                        );
                        horn1.position.set(-0.5, 0.8, 0);
                        horn1.rotation.z = Math.PI/4;
                        const horn2 = horn1.clone();
                        horn2.position.set(0.5, 0.8, 0);
                        horn2.rotation.z = -Math.PI/4;
                        
                        group.add(skull, eye1, eye2, horn1, horn2);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 1. FROZEN TUNDRA - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isFrozen) {
                    const rng = seededRandom();
                    
                    if (rng > 0.75) {
                        // FROSTED PINE TREE - Multi-layered with snow
                        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.5, 2, 8), matWood);
                        trunk.position.y = 1;
                        
                        // 4 layers of foliage
                        for(let layer = 0; layer < 4; layer++) {
                            const radius = 2.5 - (layer * 0.5);
                            const height = 2.5 - (layer * 0.3);
                            const foliage = new THREE.Mesh(new THREE.ConeGeometry(radius, height, 8), matPine);
                            foliage.position.y = 2.2 + (layer * 1.2);
                            
                            // Snow cap on each layer
                            const snow = new THREE.Mesh(new THREE.ConeGeometry(radius + 0.1, height * 0.6, 8), matSnow);
                            snow.position.y = 2.2 + (layer * 1.2) + height * 0.2;
                            
                            group.add(foliage, snow);
                        }
                        group.add(trunk);
                    }
                    else if (rng > 0.55) {
                        // ICE SPIKE CLUSTER - Sharp crystalline formations
                        const count = 5 + Math.floor(Math.random() * 3);
                        for(let k=0; k<count; k++) {
                            const height = 2 + Math.random() * 4;
                            const spike = new THREE.Mesh(
                                new THREE.ConeGeometry(0.3 + Math.random() * 0.3, height, 6),
                                matIce
                            );
                            const angle = (k / count) * Math.PI * 2 + Math.random() * 0.5;
                            const dist = Math.random() * 1.5;
                            spike.position.set(Math.cos(angle) * dist, height/2, Math.sin(angle) * dist);
                            spike.rotation.x = (Math.random() - 0.5) * 0.3;
                            spike.rotation.z = (Math.random() - 0.5) * 0.3;
                            group.add(spike);
                        }
                    }
                    else if (rng > 0.35) {
                        // FROZEN LAKE - Reflective ice surface
                        const lake = new THREE.Mesh(
                            new THREE.CircleGeometry(2.5 + Math.random(), 32),
                            new THREE.MeshStandardMaterial({
                                color: 0xddeeff,
                                transparent: true,
                                opacity: 0.8,
                                metalness: 0.9,
                                roughness: 0.1
                            })
                        );
                        lake.rotation.x = -Math.PI/2;
                        lake.position.y = 0.05;
                        
                        // Ice chunks floating
                        for(let k=0; k<3; k++) {
                            const chunk = new THREE.Mesh(
                                new THREE.DodecahedronGeometry(0.3 + Math.random() * 0.2),
                                matIce
                            );
                            chunk.position.set(
                                (Math.random()-0.5)*2,
                                0.1,
                                (Math.random()-0.5)*2
                            );
                            group.add(chunk);
                        }
                        group.add(lake);
                    }
                    else if (rng > 0.2) {
                        // SNOW DRIFT - Natural snow accumulation
                        const drift = new THREE.Mesh(
                            new THREE.SphereGeometry(2, 16, 8),
                            matSnow
                        );
                        drift.scale.set(1.5, 0.4, 1);
                        drift.position.y = 0.4;
                        group.add(drift);
                    }
                    else {
                        // SNOWMAN - Classic winter decoration
                        const base = new THREE.Mesh(new THREE.SphereGeometry(1.3), matSnow);
                        base.position.y = 1.1;
                        const middle = new THREE.Mesh(new THREE.SphereGeometry(1.0), matSnow);
                        middle.position.y = 2.7;
                        const head = new THREE.Mesh(new THREE.SphereGeometry(0.7), matSnow);
                        head.position.y = 4.0;
                        
                        // Carrot nose
                        const nose = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.6, 8), matSand);
                        nose.position.set(0, 4.0, 0.7);
                        nose.rotation.x = Math.PI/2;
                        
                        // Coal eyes
                        const eye1 = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({color: 0x000000}));
                        eye1.position.set(-0.2, 4.1, 0.6);
                        const eye2 = eye1.clone();
                        eye2.position.set(0.2, 4.1, 0.6);
                        
                        // Stick arms
                        const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5, 6), matWood);
                        arm1.position.set(-1.2, 2.7, 0);
                        arm1.rotation.z = Math.PI/3;
                        const arm2 = arm1.clone();
                        arm2.position.set(1.2, 2.7, 0);
                        arm2.rotation.z = -Math.PI/3;
                        
                        group.add(base, middle, head, nose, eye1, eye2, arm1, arm2);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 2. VOLCANIC WASTELAND - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isVolcano) {
                    const rng = seededRandom();
                    
                    if (rng > 0.7) {
                        // BASALT COLUMNS - Hexagonal volcanic rock formations
                        const count = 6 + Math.floor(Math.random() * 4);
                        for(let k=0; k<count; k++) {
                            const height = 1.5 + Math.random() * 3.5;
                            const col = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.5, 0.5, height, 6),
                                matBasalt
                            );
                            const angle = (k / count) * Math.PI * 2;
                            const dist = Math.random() * 1.2;
                            col.position.set(Math.cos(angle) * dist, height/2, Math.sin(angle) * dist);
                            col.rotation.y = Math.random() * Math.PI;
                            group.add(col);
                        }
                    }
                    else if (rng > 0.5) {
                        // MAGMA VENT - Active lava geyser
                        const crater = new THREE.Mesh(
                            new THREE.ConeGeometry(2.5, 3, 8, 1, true),
                            matBasalt
                        );
                        crater.position.y = 1.5;
                        
                        // Glowing lava pool
                        const lava = new THREE.Mesh(
                            new THREE.CircleGeometry(1.8, 16),
                            new THREE.MeshBasicMaterial({
                                color: 0xff4500,
                                emissive: 0xff4500,
                                emissiveIntensity: 1
                            })
                        );
                        lava.rotation.x = -Math.PI/2;
                        lava.position.y = 2.0;
                        
                        // Bubbling effect (multiple small spheres)
                        for(let k=0; k<3; k++) {
                            const bubble = new THREE.Mesh(
                                new THREE.SphereGeometry(0.3),
                                matMagma
                            );
                            bubble.position.set(
                                (Math.random()-0.5)*1.5,
                                2.1,
                                (Math.random()-0.5)*1.5
                            );
                            group.add(bubble);
                        }
                        
                        group.add(crater, lava);
                    }
                    else if (rng > 0.3) {
                        // OBSIDIAN SHARDS - Sharp black glass
                        const count = 4 + Math.floor(Math.random() * 3);
                        const matObsidian = new THREE.MeshStandardMaterial({
                            color: 0x0a0a0a,
                            metalness: 0.8,
                            roughness: 0.2
                        });
                        
                        for(let k=0; k<count; k++) {
                            const shard = new THREE.Mesh(
                                new THREE.ConeGeometry(0.4, 2 + Math.random() * 2, 4),
                                matObsidian
                            );
                            const angle = (k / count) * Math.PI * 2;
                            const dist = Math.random() * 1.5;
                            shard.position.set(Math.cos(angle) * dist, 1, Math.sin(angle) * dist);
                            shard.rotation.set(
                                Math.random() * 0.3,
                                Math.random() * Math.PI * 2,
                                (Math.random() - 0.5) * 0.5
                            );
                            group.add(shard);
                        }
                    }
                    else if (rng > 0.15) {
                        // LAVA POOL - Glowing molten rock
                        const pool = new THREE.Mesh(
                            new THREE.CircleGeometry(2 + Math.random(), 12),
                            new THREE.MeshBasicMaterial({
                                color: 0xff3300,
                                emissive: 0xff6600,
                                emissiveIntensity: 0.8
                            })
                        );
                        pool.rotation.x = -Math.PI/2;
                        pool.position.y = 0.05;
                        
                        // Glowing edges
                        const ring = new THREE.Mesh(
                            new THREE.RingGeometry(2, 2.3, 12),
                            new THREE.MeshBasicMaterial({color: 0x882200})
                        );
                        ring.rotation.x = -Math.PI/2;
                        ring.position.y = 0.06;
                        
                        group.add(pool, ring);
                    }
                    else {
                        // ASH PILE - Volcanic debris
                        const pile = new THREE.Mesh(
                            new THREE.ConeGeometry(1.5, 1, 8),
                            new THREE.MeshStandardMaterial({color: 0x3a3a3a, roughness: 1.0})
                        );
                        pile.position.y = 0.5;
                        group.add(pile);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 3. HELLO KITTY WORLD - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isKitty) {
                    const rng = seededRandom();
                    
                    if (rng > 0.7) {
                        // CANDY CANE - Striped pole
                        const cane = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.3, 3, 16),
                            new THREE.MeshStandardMaterial({
                                color: 0xff0066,
                                roughness: 0.3
                            })
                        );
                        cane.position.y = 1.5;
                        cane.rotation.z = 0.3;
                        
                        // White stripes
                        for(let k=0; k<5; k++) {
                            const stripe = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.32, 0.32, 0.4, 16),
                                matWhite
                            );
                            stripe.position.y = 0.5 + k * 0.6;
                            cane.add(stripe);
                        }
                        
                        group.add(cane);
                    }
                    else if (rng > 0.5) {
                        // GIANT CUPCAKE - Multi-layer dessert
                        const bottom = new THREE.Mesh(
                            new THREE.CylinderGeometry(1.2, 1.0, 0.8, 16),
                            new THREE.MeshStandardMaterial({color: 0xffd700, roughness: 0.5})
                        );
                        bottom.position.y = 0.4;
                        
                        const frosting = new THREE.Mesh(
                            new THREE.SphereGeometry(1.3, 16, 16),
                            matPink
                        );
                        frosting.scale.y = 0.8;
                        frosting.position.y = 1.5;
                        
                        // Cherry on top
                        const cherry = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3),
                            new THREE.MeshStandardMaterial({color: 0xff0000, roughness: 0.2})
                        );
                        cherry.position.y = 2.5;
                        
                        // Stem
                        const stem = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.05, 0.05, 0.3),
                            matGreen
                        );
                        stem.position.y = 2.7;
                        
                        group.add(bottom, frosting, cherry, stem);
                    }
                    else if (rng > 0.3) {
                        // MUSHROOM HOUSE - Toadstool with door
                        const stem = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.8, 0.9, 2, 16),
                            matPastel
                        );
                        stem.position.y = 1;
                        
                        const cap = new THREE.Mesh(
                            new THREE.SphereGeometry(1.8, 16, 16),
                            matRedBow
                        );
                        cap.scale.y = 0.6;
                        cap.position.y = 2.5;
                        
                        // White spots on cap
                        for(let k=0; k<5; k++) {
                            const spot = new THREE.Mesh(
                                new THREE.CircleGeometry(0.2 + Math.random() * 0.2, 8),
                                matWhite
                            );
                            spot.position.set(
                                (Math.random()-0.5)*1.5,
                                2.5 + (Math.random()-0.5)*0.3,
                                (Math.random()-0.5)*1.5
                            );
                            spot.lookAt(0, 2.5, 0);
                            group.add(spot);
                        }
                        
                        // Door
                        const door = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 0.8, 0.1),
                            matWood
                        );
                        door.position.set(0, 0.8, 0.9);
                        
                        group.add(stem, cap, door);
                    }
                    else if (rng > 0.15) {
                        // LOLLIPOP - Spiral candy
                        const stick = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.1, 2, 8),
                            matWhite
                        );
                        stick.position.y = 1;
                        
                        const candy = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32),
                            matPink
                        );
                        candy.position.y = 2.5;
                        
                        // Spiral decoration
                        for(let k=0; k<3; k++) {
                            const spiral = new THREE.Mesh(
                                new THREE.TorusGeometry(0.6 - k*0.15, 0.08, 8, 16),
                                matWhite
                            );
                            spiral.position.y = 2.5;
                            spiral.rotation.x = Math.PI/2;
                            group.add(spiral);
                        }
                        
                        group.add(stick, candy);
                    }
                    else {
                        // GIANT BOW - The signature decoration
                        const center = new THREE.Mesh(
                            new THREE.SphereGeometry(0.5),
                            matRedBow
                        );
                        center.position.y = 1.2;
                        
                        // Left loop
                        const leftLoop = new THREE.Mesh(
                            new THREE.TorusGeometry(0.8, 0.3, 16, 32),
                            matRedBow
                        );
                        leftLoop.position.set(-0.9, 1.2, 0);
                        leftLoop.rotation.y = Math.PI/2;
                        
                        // Right loop
                        const rightLoop = leftLoop.clone();
                        rightLoop.position.set(0.9, 1.2, 0);
                        
                        // Ribbons
                        const ribbon1 = new THREE.Mesh(
                            new THREE.BoxGeometry(0.4, 1.5, 0.1),
                            matRedBow
                        );
                        ribbon1.position.set(-0.3, 0.3, 0);
                        ribbon1.rotation.z = 0.3;
                        
                        const ribbon2 = ribbon1.clone();
                        ribbon2.position.set(0.3, 0.3, 0);
                        ribbon2.rotation.z = -0.3;
                        
                        group.add(center, leftLoop, rightLoop, ribbon1, ribbon2);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 4. THE VOID - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isVoid) {
                    const rng = seededRandom();
                    const matVoid = new THREE.MeshStandardMaterial({
                        color: 0x0a0a1a,
                        roughness: 0.1,
                        metalness: 0.9,
                        emissive: 0x9b59b6,
                        emissiveIntensity: 0.3
                    });
                    
                    if (rng > 0.7) {
                        // FLOATING MONOLITH - Hovering obelisk
                        const height = 3 + Math.random() * 5;
                        const mono = new THREE.Mesh(
                            new THREE.BoxGeometry(1, height, 1),
                            matVoid
                        );
                        mono.position.y = height/2 + 1.5;
                        mono.rotation.set(
                            (Math.random()-0.5)*0.4,
                            Math.random()*Math.PI*2,
                            (Math.random()-0.5)*0.4
                        );
                        
                        // Glowing edges
                        const edges = new THREE.EdgesGeometry(mono.geometry);
                        const line = new THREE.LineSegments(
                            edges,
                            new THREE.LineBasicMaterial({color: 0x00ffff, linewidth: 2})
                        );
                        line.position.copy(mono.position);
                        line.rotation.copy(mono.rotation);
                        
                        // Energy particles orbiting
                        for(let k=0; k<3; k++) {
                            const particle = new THREE.Mesh(
                                new THREE.SphereGeometry(0.1),
                                new THREE.MeshBasicMaterial({color: 0xaa00ff})
                            );
                            const angle = (k/3) * Math.PI * 2;
                            particle.position.set(
                                Math.cos(angle) * 1.5,
                                mono.position.y + (Math.random()-0.5)*height,
                                Math.sin(angle) * 1.5
                            );
                            group.add(particle);
                        }
                        
                        group.add(mono, line);
                    }
                    else if (rng > 0.5) {
                        // VOID CRYSTAL CLUSTER - Glowing purple gems
                        const mainCrystal = new THREE.Mesh(
                            new THREE.OctahedronGeometry(1.5),
                            new THREE.MeshStandardMaterial({
                                color: 0x4a0e4e,
                                emissive: 0x9b59b6,
                                emissiveIntensity: 0.7,
                                metalness: 0.9,
                                roughness: 0.1
                            })
                        );
                        mainCrystal.position.y = 2;
                        mainCrystal.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                        
                        // Surrounding smaller crystals
                        for(let k=0; k<5; k++) {
                            const small = mainCrystal.clone();
                            small.scale.setScalar(0.4 + Math.random()*0.3);
                            const angle = (k/5) * Math.PI * 2;
                            const dist = 1.5 + Math.random();
                            small.position.set(Math.cos(angle)*dist, 0.5+Math.random(), Math.sin(angle)*dist);
                            group.add(small);
                        }
                        
                        group.add(mainCrystal);
                    }
                    else if (rng > 0.3) {
                        // VOID PORTAL - Swirling energy ring
                        const portalRing = new THREE.Mesh(
                            new THREE.TorusGeometry(1.5, 0.2, 16, 32),
                            matVoid
                        );
                        portalRing.rotation.x = Math.PI/2;
                        portalRing.position.y = 2;
                        
                        // Inner vortex
                        const vortex = new THREE.Mesh(
                            new THREE.CircleGeometry(1.4, 32),
                            new THREE.MeshBasicMaterial({
                                color: 0x6600cc,
                                transparent: true,
                                opacity: 0.6
                            })
                        );
                        vortex.position.y = 2;
                        vortex.rotation.x = Math.PI/2;
                        
                        group.add(portalRing, vortex);
                    }
                    else if (rng > 0.15) {
                        // ANCIENT RUNE STONE - Mysterious marker
                        const stone = new THREE.Mesh(
                            new THREE.BoxGeometry(1.5, 3, 0.5),
                            matVoid
                        );
                        stone.position.y = 1.5;
                        stone.rotation.y = Math.random() * Math.PI;
                        
                        // Glowing runes
                        for(let k=0; k<3; k++) {
                            const rune = new THREE.Mesh(
                                new THREE.RingGeometry(0.15, 0.25, 6),
                                new THREE.MeshBasicMaterial({color: 0x00ffff})
                            );
                            rune.position.set(0, 1 + k*0.7, 0.26);
                            stone.add(rune);
                        }
                        
                        group.add(stone);
                    }
                    else {
                        // VOID SPHERE - Floating dark energy ball
                        const sphere = new THREE.Mesh(
                            new THREE.IcosahedronGeometry(1.2, 1),
                            new THREE.MeshStandardMaterial({
                                color: 0x000000,
                                emissive: 0x6600aa,
                                emissiveIntensity: 0.4,
                                wireframe: true
                            })
                        );
                        sphere.position.y = 2;
                        
                        const innerSphere = new THREE.Mesh(
                            new THREE.SphereGeometry(0.8),
                            new THREE.MeshBasicMaterial({
                                color: 0x9b59b6,
                                transparent: true,
                                opacity: 0.3
                            })
                        );
                        innerSphere.position.y = 2;
                        
                        group.add(sphere, innerSphere);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 5. CRYSTAL CAVE - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isCrystalCave) {
                    const rng = seededRandom();
                    const matCrystal = new THREE.MeshStandardMaterial({
                        color: 0xaa00ff,
                        emissive: 0xaa00ff,
                        emissiveIntensity: 0.4,
                        transparent: true,
                        opacity: 0.85,
                        metalness: 0.6,
                        roughness: 0.2
                    });
                    const matRock = new THREE.MeshStandardMaterial({color: 0x444466, roughness: 1.0});
                    
                    if (rng > 0.7) {
                        // GIANT GEODE - Hollow rock with crystals inside
                        const outer = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(2.5),
                            matRock
                        );
                        outer.scale.set(1, 0.6, 1);
                        outer.position.y = 1.2;
                        
                        // Inner crystals
                        for(let k=0; k<6; k++) {
                            const crystal = new THREE.Mesh(
                                new THREE.ConeGeometry(0.3, 1.5, 6),
                                matCrystal
                            );
                            const angle = (k/6) * Math.PI * 2;
                            crystal.position.set(
                                Math.cos(angle) * 1.5,
                                1.2,
                                Math.sin(angle) * 1.5
                            );
                            crystal.lookAt(0, 1.2, 0);
                            crystal.rotateX(Math.PI/2);
                            group.add(crystal);
                        }
                        
                        group.add(outer);
                    }
                    else if (rng > 0.5) {
                        // CRYSTAL SPIRE FOREST - Multiple tall crystals
                        const count = 5 + Math.floor(Math.random() * 4);
                        for(let k=0; k<count; k++) {
                            const height = 2 + Math.random() * 3;
                            const spire = new THREE.Mesh(
                                new THREE.OctahedronGeometry(0.5),
                                matCrystal
                            );
                            spire.scale.set(0.5, height, 0.5);
                            const angle = (k/count) * Math.PI * 2;
                            const dist = Math.random() * 1.5;
                            spire.position.set(Math.cos(angle)*dist, height, Math.sin(angle)*dist);
                            spire.rotation.y = Math.random() * Math.PI;
                            group.add(spire);
                        }
                    }
                    else if (rng > 0.3) {
                        // CRYSTAL CLUSTER - Star-shaped formation
                        const center = new THREE.Mesh(
                            new THREE.OctahedronGeometry(1),
                            matCrystal
                        );
                        center.position.y = 1;
                        
                        // 8 radiating crystals
                        for(let k=0; k<8; k++) {
                            const shard = new THREE.Mesh(
                                new THREE.ConeGeometry(0.25, 1.5, 6),
                                matCrystal
                            );
                            const angle = (k/8) * Math.PI * 2;
                            shard.position.set(Math.cos(angle)*1.2, 1, Math.sin(angle)*1.2);
                            shard.lookAt(center.position);
                            shard.rotateX(-Math.PI/2);
                            group.add(shard);
                        }
                        
                        group.add(center);
                    }
                    else if (rng > 0.15) {
                        // GLOWING BOULDER - Rock with crystal veins
                        const rock = new THREE.Mesh(
                            new THREE.DodecahedronGeometry(1.8),
                            matRock
                        );
                        rock.position.y = 1;
                        
                        // Crystal shards protruding
                        for(let k=0; k<4; k++) {
                            const shard = new THREE.Mesh(
                                new THREE.ConeGeometry(0.2, 1, 6),
                                matCrystal
                            );
                            shard.position.set(
                                (Math.random()-0.5)*1.5,
                                1 + Math.random(),
                                (Math.random()-0.5)*1.5
                            );
                            shard.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                            group.add(shard);
                        }
                        
                        group.add(rock);
                    }
                    else {
                        // FLOATING CRYSTAL SHARDS - Levitating pieces
                        for(let k=0; k<4; k++) {
                            const shard = new THREE.Mesh(
                                new THREE.TetrahedronGeometry(0.6),
                                matCrystal
                            );
                            shard.position.set(
                                (Math.random()-0.5)*2,
                                1.5 + Math.random() * 2,
                                (Math.random()-0.5)*2
                            );
                            shard.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                            group.add(shard);
                        }
                    }
                }
                
                // ═══════════════════════════════════════════
                // 6. NEON CITY - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isNeonCity) {
                    const rng = seededRandom();
                    const matBuilding = new THREE.MeshStandardMaterial({color: 0x1a1a2e, roughness: 0.6, metalness: 0.3});
                    const matNeonBlue = new THREE.MeshBasicMaterial({color: 0x00d9ff, emissive: 0x00d9ff, emissiveIntensity: 1});
                    const matNeonPink = new THREE.MeshBasicMaterial({color: 0xff006e, emissive: 0xff006e, emissiveIntensity: 1});
                    const matNeonGreen = new THREE.MeshBasicMaterial({color: 0x39ff14, emissive: 0x39ff14, emissiveIntensity: 1});
                    
                    if (rng > 0.7) {
                        // SKYSCRAPER WITH NEON - Tall building with glowing elements
                        const height = 5 + Math.random() * 5;
                        const building = new THREE.Mesh(
                            new THREE.BoxGeometry(2, height, 2),
                            matBuilding
                        );
                        building.position.y = height/2;
                        
                        // Neon strip on sides
                        for(let k=0; k<4; k++) {
                            const strip = new THREE.Mesh(
                                new THREE.BoxGeometry(2.1, 0.1, 0.05),
                                k % 2 === 0 ? matNeonBlue : matNeonPink
                            );
                            strip.position.set(0, (k+1)*(height/5), 1.01);
                            building.add(strip);
                        }
                        
                        // Rooftop antenna
                        const antenna = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.1, 2, 8),
                            matBuilding
                        );
                        antenna.position.y = height/2 + 1;
                        building.add(antenna);
                        
                        // Blinking light
                        const light = new THREE.Mesh(
                            new THREE.SphereGeometry(0.2),
                            matNeonGreen
                        );
                        light.position.y = height/2 + 2;
                        building.add(light);
                        
                        group.add(building);
                    }
                    else if (rng > 0.5) {
                        // NEON BILLBOARD - Standing advertisement
                        const stand = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.2, 3, 8),
                            matBuilding
                        );
                        stand.position.y = 1.5;
                        
                        const board = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 2, 0.2),
                            matBuilding
                        );
                        board.position.y = 3.5;
                        
                        // Neon frame
                        const frame = new THREE.Mesh(
                            new THREE.BoxGeometry(3.2, 2.2, 0.1),
                            matNeonPink
                        );
                        frame.position.y = 3.5;
                        
                        group.add(stand, board, frame);
                    }
                    else if (rng > 0.3) {
                        // STREET LAMP - Cyberpunk style
                        const pole = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.15, 0.15, 4, 8),
                            matBuilding
                        );
                        pole.position.y = 2;
                        
                        const lamp = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 0.3, 0.5),
                            matBuilding
                        );
                        lamp.position.y = 4.2;
                        
                        // Glowing light
                        const glow = new THREE.Mesh(
                            new THREE.SphereGeometry(0.4),
                            matNeonBlue
                        );
                        glow.position.y = 4;
                        
                        group.add(pole, lamp, glow);
                    }
                    else if (rng > 0.15) {
                        // HOLOGRAM PROJECTOR - Sci-fi display
                        const base = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.8, 0.8, 0.3, 16),
                            matBuilding
                        );
                        base.position.y = 0.15;
                        
                        // Hologram
                        const holo = new THREE.Mesh(
                            new THREE.PlaneGeometry(2, 2),
                            new THREE.MeshBasicMaterial({
                                color: 0x00ffff,
                                transparent: true,
                                opacity: 0.4,
                                side: THREE.DoubleSide
                            })
                        );
                        holo.position.y = 2;
                        
                        // Projection beam
                        const beam = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.5, 2, 8, 1, true),
                            new THREE.MeshBasicMaterial({
                                color: 0x00ffff,
                                transparent: true,
                                opacity: 0.2,
                                side: THREE.DoubleSide
                            })
                        );
                        beam.position.y = 1;
                        
                        group.add(base, holo, beam);
                    }
                    else {
                        // TRAFFIC BARRIER - Cyberpunk roadblock
                        const barrier = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.5, 0.3),
                            matBuilding
                        );
                        barrier.position.y = 0.5;
                        
                        // Warning stripes
                        for(let k=0; k<5; k++) {
                            const stripe = new THREE.Mesh(
                                new THREE.BoxGeometry(0.5, 0.52, 0.32),
                                k % 2 === 0 ? matNeonPink : matYellow
                            );
                            stripe.position.set(-1.25 + k*0.625, 0.5, 0);
                            group.add(stripe);
                        }
                        
                        group.add(barrier);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 7. TOXIC SWAMP - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isToxicSwamp) {
                    const rng = seededRandom();
                    const matSlime = new THREE.MeshBasicMaterial({color: 0x7fff00, emissive: 0x7fff00, emissiveIntensity: 0.5});
                    const matDeadTree = new THREE.MeshStandardMaterial({color: 0x3a2a1a, roughness: 1.0});
                    const matToxic = new THREE.MeshBasicMaterial({color: 0x66ff00, transparent: true, opacity: 0.6});
                    
                    if (rng > 0.7) {
                        // TOXIC MUSHROOM - Glowing fungus
                        const stem = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.6, 1.5, 16),
                            new THREE.MeshStandardMaterial({color: 0x44aa44, roughness: 0.8})
                        );
                        stem.position.y = 0.75;
                        
                        const cap = new THREE.Mesh(
                            new THREE.SphereGeometry(1.5, 16, 16),
                            matSlime
                        );
                        cap.scale.y = 0.5;
                        cap.position.y = 2;
                        
                        // Toxic spots
                        for(let k=0; k<5; k++) {
                            const spot = new THREE.Mesh(
                                new THREE.CircleGeometry(0.2 + Math.random()*0.2, 8),
                                new THREE.MeshBasicMaterial({color: 0x00ff00})
                            );
                            spot.position.set(
                                (Math.random()-0.5)*1.5,
                                2 + (Math.random()-0.5)*0.2,
                                (Math.random()-0.5)*1.5
                            );
                            spot.lookAt(0, 2, 0);
                            group.add(spot);
                        }
                        
                        // Dripping slime
                        for(let k=0; k<3; k++) {
                            const drip = new THREE.Mesh(
                                new THREE.ConeGeometry(0.1, 0.5, 8),
                                matSlime
                            );
                            drip.position.set(
                                (Math.random()-0.5)*1.2,
                                1.5,
                                (Math.random()-0.5)*1.2
                            );
                            group.add(drip);
                        }
                        
                        group.add(stem, cap);
                    }
                    else if (rng > 0.5) {
                        // DEAD SWAMP TREE - Gnarled trunk
                        const trunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.6, 3.5, 8),
                            matDeadTree
                        );
                        trunk.position.y = 1.75;
                        trunk.rotation.z = (Math.random()-0.5)*0.4;
                        
                        // Twisted branches
                        for(let k=0; k<3; k++) {
                            const branch = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.15, 0.1, 1.5, 6),
                                matDeadTree
                            );
                            branch.position.set(
                                (Math.random()-0.5)*0.5,
                                2.5 + Math.random(),
                                0
                            );
                            branch.rotation.set(0, k*Math.PI/2, Math.random()*Math.PI/3);
                            trunk.add(branch);
                        }
                        
                        // Moss/vines
                        const moss = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3),
                            new THREE.MeshStandardMaterial({color: 0x228b22, roughness: 1.0})
                        );
                        moss.position.set(0, 1, 0.5);
                        trunk.add(moss);
                        
                        group.add(trunk);
                    }
                    else if (rng > 0.3) {
                        // TOXIC PUDDLE - Bubbling slime pool
                        const puddle = new THREE.Mesh(
                            new THREE.CircleGeometry(2 + Math.random(), 16),
                            matToxic
                        );
                        puddle.rotation.x = -Math.PI/2;
                        puddle.position.y = 0.05;
                        
                        // Bubbles
                        for(let k=0; k<4; k++) {
                            const bubble = new THREE.Mesh(
                                new THREE.SphereGeometry(0.2 + Math.random()*0.2),
                                matSlime
                            );
                            bubble.position.set(
                                (Math.random()-0.5)*1.8,
                                0.1,
                                (Math.random()-0.5)*1.8
                            );
                            group.add(bubble);
                        }
                        
                        group.add(puddle);
                    }
                    else if (rng > 0.15) {
                        // TOXIC BARREL - Leaking container
                        const barrel = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.6, 0.6, 1.5, 16),
                            new THREE.MeshStandardMaterial({color: 0x444444, metalness: 0.7, roughness: 0.3})
                        );
                        barrel.position.y = 0.75;
                        barrel.rotation.z = (Math.random()-0.5)*0.5;
                        
                        // Warning symbol
                        const symbol = new THREE.Mesh(
                            new THREE.CircleGeometry(0.4, 3),
                            new THREE.MeshBasicMaterial({color: 0xffff00})
                        );
                        symbol.position.set(0, 0.75, 0.61);
                        barrel.add(symbol);
                        
                        // Leak
                        const leak = new THREE.Mesh(
                            new THREE.ConeGeometry(0.2, 0.6, 8),
                            matSlime
                        );
                        leak.position.y = 0.2;
                        
                        group.add(barrel, leak);
                    }
                    else {
                        // MUTANT PLANT - Carnivorous vegetation
                        const stem = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.3, 0.2, 2, 8),
                            new THREE.MeshStandardMaterial({color: 0x2d5a2d, roughness: 0.9})
                        );
                        stem.position.y = 1;
                        
                        // Mouth (open sphere)
                        const mouth = new THREE.Mesh(
                            new THREE.SphereGeometry(0.8, 16, 16, 0, Math.PI*2, 0, Math.PI/2),
                            new THREE.MeshStandardMaterial({color: 0xff0066, roughness: 0.5, side: THREE.DoubleSide})
                        );
                        mouth.position.y = 2.5;
                        
                        // Teeth
                        for(let k=0; k<8; k++) {
                            const tooth = new THREE.Mesh(
                                new THREE.ConeGeometry(0.1, 0.3, 4),
                                new THREE.MeshStandardMaterial({color: 0xffffff})
                            );
                            const angle = (k/8) * Math.PI * 2;
                            tooth.position.set(Math.cos(angle)*0.7, 2.5, Math.sin(angle)*0.7);
                            tooth.lookAt(0, 2.5, 0);
                            tooth.rotateX(-Math.PI/2);
                            group.add(tooth);
                        }
                        
                        group.add(stem, mouth);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 8. SPACE STATION - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else if (isSpaceStation) {
                    const rng = seededRandom();
                    const matMetal = new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.9, roughness: 0.2});
                    const matTech = new THREE.MeshStandardMaterial({color: 0x333333, metalness: 0.8, roughness: 0.3});
                    const matLight = new THREE.MeshBasicMaterial({color: 0x00aaff, emissive: 0x00aaff, emissiveIntensity: 1});
                    
                    if (rng > 0.7) {
                        // CARGO CONTAINER - Stacked shipping crate
                        const container1 = new THREE.Mesh(
                            new THREE.BoxGeometry(2.5, 2, 3),
                            matMetal
                        );
                        container1.position.y = 1;
                        
                        // Corner reinforcements
                        for(let corner of [[1.3,1,1.6], [-1.3,1,1.6], [1.3,1,-1.6], [-1.3,1,-1.6]]) {
                            const reinforce = new THREE.Mesh(
                                new THREE.BoxGeometry(0.2, 2.2, 0.2),
                                matTech
                            );
                            reinforce.position.set(...corner);
                            group.add(reinforce);
                        }
                        
                        // Status light
                        const light = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.3, 0.1),
                            matLight
                        );
                        light.position.set(1, 1, 1.51);
                        
                        // Maybe stacked
                        if(Math.random() > 0.5) {
                            const container2 = container1.clone();
                            container2.position.y = 3;
                            container2.rotation.y = Math.PI/2;
                            group.add(container2);
                        }
                        
                        group.add(container1, light);
                    }
                    else if (rng > 0.5) {
                        // ANTENNA ARRAY - Communications dish
                        const pole = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.2, 0.2, 4, 8),
                            matMetal
                        );
                        pole.position.y = 2;
                        
                        const dish = new THREE.Mesh(
                            new THREE.SphereGeometry(1.2, 16, 16, 0, Math.PI*2, 0, Math.PI/2),
                            matMetal
                        );
                        dish.rotation.x = Math.PI;
                        dish.position.y = 4.5;
                        
                        // Receiver
                        const receiver = new THREE.Mesh(
                            new THREE.ConeGeometry(0.2, 0.8, 8),
                            matTech
                        );
                        receiver.position.set(0, 4, 0.5);
                        receiver.rotation.x = Math.PI/4;
                        
                        group.add(pole, dish, receiver);
                    }
                    else if (rng > 0.3) {
                        // TECH CONSOLE - Control panel
                        const base = new THREE.Mesh(
                            new THREE.BoxGeometry(2, 1.5, 1),
                            matTech
                        );
                        base.position.y = 0.75;
                        base.rotation.y = Math.random() * Math.PI * 2;
                        
                        // Screen
                        const screen = new THREE.Mesh(
                            new THREE.PlaneGeometry(1.5, 1),
                            new THREE.MeshBasicMaterial({
                                color: 0x00ffaa,
                                emissive: 0x00ffaa,
                                emissiveIntensity: 0.5
                            })
                        );
                        screen.position.set(0, 1.2, 0.51);
                        base.add(screen);
                        
                        // Buttons
                        for(let k=0; k<4; k++) {
                            const button = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.1, 0.1, 0.1, 8),
                                matLight
                            );
                            button.rotation.x = Math.PI/2;
                            button.position.set(-0.6 + k*0.4, 0.5, 0.51);
                            base.add(button);
                        }
                        
                        group.add(base);
                    }
                    else if (rng > 0.15) {
                        // POWER GENERATOR - Energy core
                        const core = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.8, 0.8, 2, 16),
                            matMetal
                        );
                        core.position.y = 1;
                        
                        // Glowing rings
                        for(let k=0; k<3; k++) {
                            const ring = new THREE.Mesh(
                                new THREE.TorusGeometry(0.9, 0.1, 16, 32),
                                matLight
                            );
                            ring.position.y = 0.5 + k*0.6;
                            ring.rotation.x = Math.PI/2;
                            group.add(ring);
                        }
                        
                        // Exhaust pipes
                        for(let k=0; k<4; k++) {
                            const pipe = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.15, 0.15, 1, 8),
                                matTech
                            );
                            const angle = (k/4) * Math.PI * 2;
                            pipe.position.set(Math.cos(angle)*0.95, 2, Math.sin(angle)*0.95);
                            group.add(pipe);
                        }
                        
                        group.add(core);
                    }
                    else {
                        // ROBOTIC ARM - Mechanical appendage
                        const base = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.6, 0.8, 16),
                            matTech
                        );
                        base.position.y = 0.4;
                        
                        const arm1 = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 2, 0.3),
                            matMetal
                        );
                        arm1.position.y = 1.8;
                        
                        const joint = new THREE.Mesh(
                            new THREE.SphereGeometry(0.25),
                            matTech
                        );
                        joint.position.y = 2.8;
                        
                        const arm2 = new THREE.Mesh(
                            new THREE.BoxGeometry(0.25, 1.5, 0.25),
                            matMetal
                        );
                        arm2.position.set(0, 3.5, 0);
                        arm2.rotation.z = Math.PI/6;
                        
                        // Claw
                        const claw = new THREE.Mesh(
                            new THREE.BoxGeometry(0.5, 0.2, 0.2),
                            matTech
                        );
                        claw.position.set(0, 4.2, 0);
                        
                        group.add(base, arm1, joint, arm2, claw);
                    }
                }
 
		// ═══════════════════════════════════════════
                // 9. HARVEST VALLEY (FARM) - KEEP AS IS
                // ═══════════════════════════════════════════
                else if (isFarm) {
                    const rng = seededRandom();
                    
                    if (rng > 0.8) {
                        // HAY BALE
                        const bale = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 2, 16), matHay);
                        bale.rotation.z = Math.PI / 2;
                        bale.position.y = 1.0;
                        group.add(bale);
                        
                        if(Math.random() > 0.5) {
                            const bale2 = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.1, 2, 16), matHay);
                            bale2.rotation.z = Math.PI / 2;
                            bale2.rotation.y = 0.5;
                            bale2.position.set(0, 2.2, 0);
                            group.add(bale2);
                        }
                    } 
                    else if (rng > 0.5) {
                        // OAK TREE
                        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.7, 2.5, 8), matWood);
                        trunk.position.y = 1.25;
                        const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5), matOakLeaf);
                        leaves.position.y = 3.5;
                        group.add(trunk, leaves);
                    } 
                    else if (rng > 0.35) {
                        // PUMPKIN PATCH
                        for(let k=0; k<3; k++) {
                            const pumpkin = new THREE.Mesh(new THREE.SphereGeometry(0.8, 10, 8), matPumpkin);
                            pumpkin.scale.y = 0.7;
                            pumpkin.position.set((Math.random()-0.5)*2, 0.5, (Math.random()-0.5)*2);
                            const stem = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.5), matGreen);
                            stem.position.y = 0.7;
                            pumpkin.add(stem);
                            group.add(pumpkin);
                        }
                    } 
                    else if (rng > 0.15) {
                        // CORN STALKS
                        for(let k=0; k<5; k++) {
                            const stalk = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 3 + Math.random()), matCorn);
                            stalk.position.set((Math.random()-0.5)*1.5, 1.5, (Math.random()-0.5)*1.5);
                            stalk.rotation.z = (Math.random()-0.5)*0.2;
                            group.add(stalk);
                        }
                    } 
                    else {
                        // WOODEN FENCE
                        const post1 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 0.3), matFence);
                        post1.position.set(-1.5, 1, 0);
                        const post2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 2, 0.3), matFence);
                        post2.position.set(1.5, 1, 0);
                        const rail1 = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.2, 0.1), matFence);
                        rail1.position.set(0, 1.5, 0);
                        const rail2 = new THREE.Mesh(new THREE.BoxGeometry(3.2, 0.2, 0.1), matFence);
                        rail2.position.set(0, 0.8, 0);
                        group.add(post1, post2, rail1, rail2);
                    }
                }
                
                // ═══════════════════════════════════════════
                // 11. JUNGLE TEMPLE - Tropical Rainforest
                // ═══════════════════════════════════════════
                else if (isJungle) {
                    const rng = seededRandom();
                    
                    if (rng > 0.75) {
                        // KAPOK TREE - Massive jungle tree with buttress roots
                        const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 1.5, 8, 8), matWood);
                        trunk.position.y = 4;
                        
                        // Buttress roots (flared base)
                        for(let k=0; k<4; k++) {
                            const root = new THREE.Mesh(new THREE.ConeGeometry(0.6, 2, 3), matWood);
                            root.rotation.z = k * (Math.PI/2);
                            root.rotation.y = k * (Math.PI/2);
                            root.position.set(
                                Math.cos(k * Math.PI/2) * 1.2,
                                1,
                                Math.sin(k * Math.PI/2) * 1.2
                            );
                            group.add(root);
                        }
                        
                        // Canopy
                        const leaves1 = new THREE.Mesh(new THREE.DodecahedronGeometry(3.5), matJungleLeaf);
                        leaves1.position.y = 8;
                        const leaves2 = new THREE.Mesh(new THREE.DodecahedronGeometry(2.5), matJungleLeaf);
                        leaves2.position.y = 10;
                        
                        group.add(trunk, leaves1, leaves2);
                        
                        // ADD VINES TO THIS TREE (hanging from canopy)
                        for(let k=0; k<2; k++) {
                            const vineAngle = Math.random() * Math.PI * 2;
                            const vineRadius = 1 + Math.random() * 2; // Hang from edge of canopy
                            const vine = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.05, 0.08, 5 + Math.random() * 2, 6),
                                matVine
                            );
                            vine.position.set(
                                Math.cos(vineAngle) * vineRadius,
                                8, // Start from canopy height
                                Math.sin(vineAngle) * vineRadius
                            );
                            vine.rotation.z = (Math.random()-0.5) * 0.2;
                            group.add(vine);
                            
                            // Leaves on vine
                            for(let j=0; j<3; j++) {
                                const leaf = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.3, 0.5, 0.01),
                                    matJungleLeaf
                                );
                                leaf.position.y = -1.5 - j * 1.5;
                                leaf.rotation.x = Math.random() * Math.PI/4;
                                vine.add(leaf);
                            }
                        }
                    }
                    else if (rng > 0.55) {
                        // BAMBOO GROVE
                        for(let k=0; k<5; k++) {
                            const height = 4 + Math.random() * 3;
                            const bamboo = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.15, 0.15, height, 8),
                                matBamboo
                            );
                            bamboo.position.set(
                                (Math.random()-0.5) * 2,
                                height/2,
                                (Math.random()-0.5) * 2
                            );
                            
                            // Bamboo segments (rings)
                            for(let j=0; j<Math.floor(height); j++) {
                                const ring = new THREE.Mesh(
                                    new THREE.TorusGeometry(0.18, 0.05, 4, 8),
                                    new THREE.MeshStandardMaterial({color: 0x556b2f})
                                );
                                ring.rotation.x = Math.PI/2;
                                ring.position.y = j * 1 - height/2 + 0.5;
                                bamboo.add(ring);
                            }
                            
                            group.add(bamboo);
                        }
                    }
                    else if (rng > 0.40) {
                        // ANCIENT STONE RUINS - Temple remnants
                        // Base platform
                        const base = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.5, 3),
                            matStone
                        );
                        base.position.y = 0.25;
                        
                        // Broken pillar
                        const pillar = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.5, 0.6, 3, 8),
                            matStone
                        );
                        pillar.position.y = 1.5;
                        pillar.rotation.z = 0.2; // Tilted
                        
                        // Moss coverage
                        const moss1 = new THREE.Mesh(
                            new THREE.BoxGeometry(3.1, 0.1, 3.1),
                            matMoss
                        );
                        moss1.position.y = 0.55;
                        
                        const moss2 = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.55, 0.65, 3.1, 8),
                            matMoss
                        );
                        moss2.position.copy(pillar.position);
                        moss2.rotation.z = 0.2;
                        
                        group.add(base, pillar, moss1, moss2);
                    }
                    else if (rng > 0.25) {
                        // SMALL JUNGLE TREE (with vines)
                        const smallTrunk = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.5, 5, 8),
                            matWood
                        );
                        smallTrunk.position.y = 2.5;
                        group.add(smallTrunk);
                        
                        const smallCanopy = new THREE.Mesh(
                            new THREE.SphereGeometry(2, 8, 6),
                            matJungleLeaf
                        );
                        smallCanopy.position.y = 5.5;
                        group.add(smallCanopy);
                        
                        // Vines hanging from THIS tree
                        for(let k=0; k<2; k++) {
                            const vineAngle = Math.random() * Math.PI * 2;
                            const vineRadius = 0.8 + Math.random();
                            const vine = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.04, 0.06, 4 + Math.random() * 2, 6),
                                matVine
                            );
                            vine.position.set(
                                Math.cos(vineAngle) * vineRadius,
                                5.5, // Canopy height
                                Math.sin(vineAngle) * vineRadius
                            );
                            vine.rotation.z = (Math.random()-0.5) * 0.3;
                            group.add(vine);
                            
                            // Leaves on vine
                            for(let j=0; j<3; j++) {
                                const leaf = new THREE.Mesh(
                                    new THREE.BoxGeometry(0.25, 0.4, 0.01),
                                    matJungleLeaf
                                );
                                leaf.position.y = -1 - j * 1.2;
                                leaf.rotation.x = Math.random() * Math.PI/4;
                                vine.add(leaf);
                            }
                        }
                    }
                    else if (rng > 0.10) {
                        // TROPICAL FERNS - Large ground cover
                        for(let k=0; k<6; k++) {
                            const stem = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.05, 0.05, 1.5),
                                matVine
                            );
                            stem.position.set(
                                (Math.random()-0.5) * 2,
                                0.75,
                                (Math.random()-0.5) * 2
                            );
                            stem.rotation.z = (Math.random()-0.5) * 0.5;
                            
                            // Fern fronds
                            const frond = new THREE.Mesh(
                                new THREE.BoxGeometry(0.1, 2, 0.01),
                                matJungleLeaf
                            );
                            frond.position.y = 0.75;
                            frond.rotation.z = k * (Math.PI/3);
                            stem.add(frond);
                            
                            group.add(stem);
                        }
                    }
                    else {
                        // ORCHID FLOWERS - Colorful jungle blooms
                        for(let k=0; k<4; k++) {
                            const stem = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.03, 0.03, 1),
                                matGreen
                            );
                            stem.position.set(
                                (Math.random()-0.5) * 1,
                                0.5,
                                (Math.random()-0.5) * 1
                            );
                            
                            // Flower petals
                            for(let j=0; j<5; j++) {
                                const petal = new THREE.Mesh(
                                    new THREE.SphereGeometry(0.15, 6, 4),
                                    matOrchid
                                );
                                petal.scale.set(1, 0.3, 0.6);
                                petal.position.set(
                                    Math.cos(j * Math.PI*2/5) * 0.2,
                                    1,
                                    Math.sin(j * Math.PI*2/5) * 0.2
                                );
                                petal.rotation.x = Math.PI/4;
                                stem.add(petal);
                            }
                            
                            group.add(stem);
                        }
                    }
                }

                // ═══════════════════════════════════════════
                // 12. MUSHROOM FOREST - Fantasy Fungi Theme
                // ═══════════════════════════════════════════
                else if (isMushroom) {
                    const rng = seededRandom();
                    
                    if (rng > 0.83) {
                        // 1. GIANT RED MUSHROOM - Classic toadstool
                        const stem = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.6, 0.8, 3, 12),
                            matMushroomStem
                        );
                        stem.position.y = 1.5;
                        
                        // Cap (hemisphere)
                        const cap = new THREE.Mesh(
                            new THREE.SphereGeometry(2.5, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2),
                            matMushroomRed
                        );
                        cap.position.y = 3.5;
                        cap.scale.y = 0.6;
                        
                        // White spots on cap
                        for(let k=0; k<8; k++) {
                            const angle = (k / 8) * Math.PI * 2;
                            const radius = 1 + Math.random() * 0.8;
                            const spot = new THREE.Mesh(
                                new THREE.SphereGeometry(0.2 + Math.random() * 0.2, 8, 8),
                                matMushroomSpots
                            );
                            spot.position.set(
                                Math.cos(angle) * radius,
                                3.8,
                                Math.sin(angle) * radius
                            );
                            group.add(spot);
                        }
                        
                        // Gills under cap
                        const gills = new THREE.Mesh(
                            new THREE.CylinderGeometry(2.3, 0.5, 0.3, 16),
                            new THREE.MeshStandardMaterial({ color: 0xffd7a8, roughness: 0.9 })
                        );
                        gills.position.y = 3.2;
                        
                        group.add(stem, cap, gills);
                    }
                    else if (rng > 0.66) {
                        // 2. GLOWING MUSHROOM CLUSTER - Bioluminescent fungi
                        const clusterCount = 4 + Math.floor(Math.random() * 3);
                        for(let k=0; k<clusterCount; k++) {
                            const height = 1 + Math.random() * 2;
                            const stem = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.15, 0.2, height, 8),
                                matMushroomStem
                            );
                            const angle = (k / clusterCount) * Math.PI * 2;
                            const dist = Math.random() * 1.2;
                            stem.position.set(
                                Math.cos(angle) * dist,
                                height/2,
                                Math.sin(angle) * dist
                            );
                            
                            // Glowing cap
                            const cap = new THREE.Mesh(
                                new THREE.SphereGeometry(0.4, 12, 12, 0, Math.PI * 2, 0, Math.PI / 2),
                                matMushroomGlow
                            );
                            cap.position.y = height;
                            cap.scale.y = 0.5;
                            stem.add(cap);
                            
                            // Add point light for glow effect
                            const light = new THREE.PointLight(0x88ffaa, 0.3, 5);
                            light.position.y = height;
                            stem.add(light);
                            
                            group.add(stem);
                        }
                    }
                    else if (rng > 0.50) {
                        // 3. BLUE CAP MUSHROOM - Magical blue fungi
                        const stem = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.4, 0.5, 2.5, 12),
                            matMushroomStem
                        );
                        stem.position.y = 1.25;
                        
                        // Wide flat cap
                        const cap = new THREE.Mesh(
                            new THREE.CylinderGeometry(2, 1.5, 0.8, 16),
                            matMushroomBlue
                        );
                        cap.position.y = 3;
                        
                        // Spiral pattern on cap
                        for(let k=0; k<12; k++) {
                            const angle = (k / 12) * Math.PI * 2;
                            const radius = 0.5 + (k / 12) * 1.2;
                            const dot = new THREE.Mesh(
                                new THREE.SphereGeometry(0.1, 6, 6),
                                matMushroomSpots
                            );
                            dot.position.set(
                                Math.cos(angle) * radius,
                                3.5,
                                Math.sin(angle) * radius
                            );
                            group.add(dot);
                        }
                        
                        group.add(stem, cap);
                    }
                    else if (rng > 0.33) {
                        // 4. PURPLE SHELF MUSHROOMS - Growing on old log
                        // Dead log
                        const log = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.6, 0.5, 3, 8),
                            matWood
                        );
                        log.rotation.z = Math.PI / 2;
                        log.position.set(0, 0.5, 0);
                        
                        // Moss on log
                        const moss = new THREE.Mesh(
                            new THREE.BoxGeometry(3, 0.2, 1.2),
                            matMoss
                        );
                        moss.position.y = 0.7;
                        
                        // Shelf mushrooms growing from side
                        for(let k=0; k<4; k++) {
                            const shelf = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.6, 0.1, 0.3, 12, 1, false, 0, Math.PI),
                                matMushroomPurple
                            );
                            shelf.rotation.x = -Math.PI / 2;
                            shelf.rotation.z = Math.PI / 2;
                            shelf.position.set(
                                -1 + k * 0.7,
                                0.5 + Math.random() * 0.3,
                                0.6
                            );
                            group.add(shelf);
                        }
                        
                        group.add(log, moss);
                    }
                    else if (rng > 0.17) {
                        // 5. FAIRY RING - Circle of small mushrooms
                        const ringRadius = 2;
                        const mushroomCount = 10;
                        
                        for(let k=0; k<mushroomCount; k++) {
                            const angle = (k / mushroomCount) * Math.PI * 2;
                            const x = Math.cos(angle) * ringRadius;
                            const z = Math.sin(angle) * ringRadius;
                            
                            const smallStem = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.1, 0.12, 0.5, 8),
                                matMushroomStem
                            );
                            smallStem.position.set(x, 0.25, z);
                            
                            const smallCap = new THREE.Mesh(
                                new THREE.SphereGeometry(0.25, 8, 8, 0, Math.PI * 2, 0, Math.PI / 2),
                                matMushroomRed
                            );
                            smallCap.position.set(x, 0.55, z);
                            smallCap.scale.y = 0.6;
                            
                            // Random spot
                            if(Math.random() > 0.5) {
                                const spot = new THREE.Mesh(
                                    new THREE.SphereGeometry(0.08, 6, 6),
                                    matMushroomSpots
                                );
                                spot.position.set(x, 0.65, z);
                                group.add(spot);
                            }
                            
                            group.add(smallStem, smallCap);
                        }
                        
                        // Glowing center
                        const centerGlow = new THREE.Mesh(
                            new THREE.SphereGeometry(0.3, 12, 12),
                            matMushroomGlow
                        );
                        centerGlow.position.y = 0.3;
                        group.add(centerGlow);
                    }
                    else {
                        // 6. GIANT PUFFBALL - Spherical mushroom
                        const puffball = new THREE.Mesh(
                            new THREE.SphereGeometry(1.5, 16, 16),
                            new THREE.MeshStandardMaterial({ 
                                color: 0xf0e68c,
                                roughness: 0.95
                            })
                        );
                        puffball.position.y = 1.2;
                        puffball.scale.y = 0.8;
                        
                        // Texture bumps
                        for(let k=0; k<15; k++) {
                            const bump = new THREE.Mesh(
                                new THREE.SphereGeometry(0.15, 6, 6),
                                new THREE.MeshStandardMaterial({ 
                                    color: 0xdaa520,
                                    roughness: 1.0
                                })
                            );
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.random() * Math.PI / 2;
                            bump.position.set(
                                Math.sin(phi) * Math.cos(theta) * 1.4,
                                1.2 + Math.cos(phi) * 1.2 * 0.8,
                                Math.sin(phi) * Math.sin(theta) * 1.4
                            );
                            group.add(bump);
                        }
                        
                        // Small stems at base
                        for(let k=0; k<3; k++) {
                            const baseAngle = (k / 3) * Math.PI * 2;
                            const baseStem = new THREE.Mesh(
                                new THREE.CylinderGeometry(0.15, 0.2, 0.4, 8),
                                matMushroomStem
                            );
                            baseStem.position.set(
                                Math.cos(baseAngle) * 1.2,
                                0.2,
                                Math.sin(baseAngle) * 1.2
                            );
                            group.add(baseStem);
                        }
                        
                        group.add(puffball);
                    }
                }

                // ═══════════════════════════════════════════
                // 10. CANYON (DEFAULT) - COMPLETE REWORK
                // ═══════════════════════════════════════════
                else {
                    const rng = seededRandom();
                    
                    if (rng > 0.7) {
                        // SAGUARO CACTUS - Tall with arms
                        const main = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 5, 8), matCactus);
                        main.position.y = 2.5;
                        
                        // Left arm
                        const arm1 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2, 8), matCactus);
                        arm1.position.set(-1, 3, 0);
                        arm1.rotation.z = Math.PI/2;
                        const arm1up = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8), matCactus);
                        arm1up.position.set(-2, 3.75, 0);
                        
                        // Right arm
                        const arm2 = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8), matCactus);
                        arm2.position.set(1, 2.5, 0);
                        arm2.rotation.z = -Math.PI/2;
                        const arm2up = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2, 8), matCactus);
                        arm2up.position.set(1.75, 3.5, 0);
                        
                        // Flowers on top
                        const flower = new THREE.Mesh(
                            new THREE.ConeGeometry(0.3, 0.4, 8),
                            new THREE.MeshStandardMaterial({color: 0xff69b4, roughness: 0.5})
                        );
                        flower.position.y = 5.2;
                        
                        group.add(main, arm1, arm1up, arm2, arm2up, flower);
                    }
                    else if (rng > 0.5) {
                        // DESERT ROCK FORMATION - Layered sandstone
                        const layers = 4 + Math.floor(Math.random()*3);
                        for(let k=0; k<layers; k++) {
                            const width = 2.5 - k*0.3;
                            const layer = new THREE.Mesh(
                                new THREE.BoxGeometry(width, 0.8, width),
                                new THREE.MeshStandardMaterial({
                                    color: 0xd2691e - k*0x101010,
                                    roughness: 1.0
                                })
                            );
                            layer.position.y = k*0.8 + 0.4;
                            layer.rotation.y = k * 0.3;
                            group.add(layer);
                        }
                    }
                    else if (rng > 0.3) {
                        // TUMBLEWEED - Desert plant ball
                        const tumbleweed = new THREE.Mesh(
                            new THREE.IcosahedronGeometry(1, 1),
                            new THREE.MeshStandardMaterial({
                                color: 0x8b7355,
                                wireframe: true
                            })
                        );
                        tumbleweed.position.y = 1;
                        group.add(tumbleweed);
                    }
                    else if (rng > 0.15) {
                        // BARREL CACTUS - Round spiky plant
                        const body = new THREE.Mesh(
                            new THREE.SphereGeometry(1, 12, 8),
                            matCactus
                        );
                        body.scale.y = 0.7;
                        body.position.y = 0.7;
                        
                        // Spines (vertical ridges)
                        for(let k=0; k<12; k++) {
                            const angle = (k/12) * Math.PI * 2;
                            const spine = new THREE.Mesh(
                                new THREE.BoxGeometry(0.05, 1.4, 0.05),
                                new THREE.MeshStandardMaterial({color: 0xffffff})
                            );
                            spine.position.set(Math.cos(angle)*0.95, 0.7, Math.sin(angle)*0.95);
                            group.add(spine);
                        }
                        
                        // Flower on top
                        const flower = new THREE.Mesh(
                            new THREE.ConeGeometry(0.2, 0.3, 6),
                            matYellow
                        );
                        flower.position.y = 1.4;
                        
                        group.add(body, flower);
                    }
                    else {
                        // DESERT BONES - Skull decoration
                        const skull = new THREE.Mesh(
                            new THREE.SphereGeometry(0.6),
                            new THREE.MeshStandardMaterial({color: 0xf5f5dc, roughness: 0.9})
                        );
                        skull.scale.set(1, 0.8, 1);
                        skull.position.y = 0.5;
                        
                        // Eye sockets
                        const eye1 = new THREE.Mesh(
                            new THREE.SphereGeometry(0.15),
                            new THREE.MeshStandardMaterial({color: 0x000000})
                        );
                        eye1.position.set(-0.2, 0.5, 0.5);
                        const eye2 = eye1.clone();
                        eye2.position.set(0.2, 0.5, 0.5);
                        
                        // Horns
                        const horn1 = new THREE.Mesh(
                            new THREE.ConeGeometry(0.1, 0.5, 6),
                            new THREE.MeshStandardMaterial({color: 0xdeb887})
                        );
                        horn1.position.set(-0.5, 0.8, 0);
                        horn1.rotation.z = Math.PI/4;
                        const horn2 = horn1.clone();
                        horn2.position.set(0.5, 0.8, 0);
                        horn2.rotation.z = -Math.PI/4;
                        
                        group.add(skull, eye1, eye2, horn1, horn2);
                    }
                }

                scene.add(group);
                mapProps.push(group); // Add to mapProps so decorations are cleaned up when map changes
            }
        }

	function createStarfield() {
            const starGeo = new THREE.BufferGeometry();
            const starCount = graphicsMode === 2 ? 2000 : (graphicsMode === 1 ? 1000 : 500);
            const posArray = new Float32Array(starCount * 3);
            
            for(let i=0; i<starCount * 3; i++) {
                // Spread stars far away (between 400 and 800 units)
                posArray[i] = (Math.random() - 0.5) * 1600; 
            }
            
            starGeo.setAttribute('position', new THREE.BufferAttribute(posArray, 3));
            
            // White stars that ignore light/shadows
            const starMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: graphicsMode === 2 ? 2.0 : 1.5,
                transparent: true,
                opacity: graphicsMode === 0 ? 0.5 : 0.8
            });
            
            const starMesh = new THREE.Points(starGeo, starMat);
            starMesh.position.y = 50; // Lift them up a bit
            scene.add(starMesh);
            window.starfield = starMesh; // Store for animations
        }
        
        // Atmospheric Particles (Dust, Embers, Snow, etc.)
        function createAtmosphericParticles(mapIndex) {
            if (graphicsMode === 0) return; // Skip on low settings
            
            // Remove old particles
            if (window.atmosphericParticles) {
                scene.remove(window.atmosphericParticles);
            }
            
            const particleCount = graphicsMode === 2 ? 500 : 200;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];
            
            for(let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 200;
                positions[i * 3 + 1] = Math.random() * 100;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 200;
                
                // Random drift velocity
                velocities.push({
                    x: (Math.random() - 0.5) * 0.1,
                    y: (Math.random() - 0.5) * 0.1,
                    z: (Math.random() - 0.5) * 0.1
                });
            }
            
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Different particles per map
            let color, size;
            if (mapIndex === 1) { // Frozen - Snowflakes
                color = 0xffffff;
                size = 0.5;
            } else if (mapIndex === 2) { // Volcano - Embers
                color = 0xff6600;
                size = 0.3;
            } else if (mapIndex === 5) { // Crystal Cave - Glowing dust
                color = 0xaa00ff;
                size = 0.4;
            } else if (mapIndex === 7) { // Toxic Swamp - Green spores
                color = 0x00ff00;
                size = 0.3;
            } else if (mapIndex === 10) { // Jungle - Fireflies
                color = 0xffff00;
                size = 0.4;
            } else { // Default - Dust
                color = 0xcccccc;
                size = 0.2;
            }
            
            const material = new THREE.PointsMaterial({
                color: color,
                size: size,
                transparent: true,
                opacity: 0.6,
                blending: THREE.AdditiveBlending
            });
            
            const particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
            
            window.atmosphericParticles = particleSystem;
            window.particleVelocities = velocities;
        }

        let scene, camera, renderer, raycaster, mouse;
        var gold=650, lives=20, wave=0, activeWave=false;
	let lastSpendTime = 0;
        let spawningFinished = true; 
        let enemies=[], towers=[], projectiles=[], particles=[], mapProps=[];
        let selectedType=null, selectedTower=null, selectedEnemyId=null;
        let hoverMesh, rangeRing, deadZoneRing;
        let gameRunning = false;
        let isPaused = false;
        let selectedMapIndex = 0;
        let currentWaypoints = [];
        let graphicsHigh = true;
        let prevMenu = null;
        let autoWave = false;
        let isPanning = false;
        let panStart = new THREE.Vector2();
        let graphicsMode = 3; // 0=Low, 1=Medium, 2=High, 3=Ultra, 4=Custom
        
        // Track graphics state for shadow restart warning
        let previousGraphicsMode = 3;
        let previousShadowsEnabled = true;
        let pendingGraphicsChange = false;

        // Advanced graphics settings
        let advancedGraphicsSettings = {
            shadowsEnabled: true,
            shadowResolution: 4096,
            shadowSoftness: 2,
            lightingQuality: 1.0,
            bloomEnabled: true,
            bloomIntensity: 1.5,
            ssaoEnabled: true,
            ssaoIntensity: 1.0,
            motionBlurEnabled: false,
            motionBlurStrength: 0.5,
            dofEnabled: false,
            dofStrength: 0.5,
            particleMultiplier: 1.0,
            postProcessingEnabled: true,
            renderDistance: 1.0,
            lodBias: 1.0,
            pixelRatio: 2.0,
            antiAliasing: true,
            colorCorrection: true
        };

        // Achievement tracking
        let achievementsData = {
            first_blood: { unlocked: false, progress: 0, total: 1 },
            tower_master: { unlocked: false, progress: 0, total: 10 },
            wave_warrior: { unlocked: false, progress: 0, total: 50 },
            millionaire: { unlocked: false, progress: 0, total: 1000000 },
            no_damage: { unlocked: false, progress: 0, total: 1 },
            speed_demon: { unlocked: false, progress: 0, total: 1 },
            collector: { unlocked: false, progress: 0, total: 20 },
            survivor: { unlocked: false, progress: 0, total: 100 }
        };
        let totalKills = 0;
        let totalGoldEarned = 0;
        let wavesCompleted = 0
        let shadowsEnabled = true;
	let composer, bloomPass; // For visual effects
        let shakeEnabled = true;
        let dmgTextEnabled = true;
	let healthBarsEnabled = true;
        let showFPSCounter = true; // Default ON
        let bloomStrength = 1.5; // Default
        let cameraFOV = 45;
        let shakeIntensity = 0;
        let shakeDecay = 0.8; // How fast shake stops
        let originalCamPos = new THREE.Vector3(); // Stores position before shaking
        let currentGamemode = 'shared';
	let playerWallets = [0, 0, 0, 0]; // Stores gold for P1, P2, P3, P4
	let allPlayers = []; // Stores the player list from the server
	let myPlayerIndex = 0; // 0=Host, 1=Joiner1, etc.
	const PLAYER_COLORS = ['#e67e22', '#3498db', '#2ecc71', '#9b59b6']; // Orange, Blue, Green, Purple
	let TOWER_ICONS = {};
	let ENEMY_ICONS = {};
	let previewScene, previewCam, previewRenderer, previewModel;
	let isPreviewing = false;
	let lastSyncTime = 0;
	let isMultiplayerMode = false; // Track if in multiplayer

        // Performance Monitoring Variables
        let fpsCounter = { frames: 0, lastTime: performance.now(), fps: 60 };
        let pingMonitor = { lastPing: 0, samples: [], lastPingTime: 0 };
        let hostPing = 0;
        let serverLocation = 'UNKNOWN';
        let mpWarningShown = false;

        // Helper function to check if in multiplayer mode
        function checkIsMultiplayerMode() {
            return isMultiplayerMode === true;
        }

        function init() {
            loadAchievements();
            loadData();     // Load Almanac
	    initPreviewSystem();

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111111);
            scene.fog = new THREE.FogExp2(0x111111, 0.007);

            camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 1, 1000);
            camera.position.set(0, 110, 50); 
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ 
                antialias: true, 
                preserveDrawingBuffer: true,
                powerPreference: "high-performance",
                alpha: false,
                stencil: false
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Cap at 2x
            
            // Enhanced rendering settings
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.outputEncoding = THREE.sRGBEncoding;
            
            document.body.appendChild(renderer.domElement);
	    initMobileControls();
	    initPostProcessing();

            // ============ ENHANCED LIGHTING SYSTEM ============
            
            // 1. Ambient Light (Base illumination)
            const amb = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(amb);
            
            // 2. Main Directional Light (Sun)
            const dir = new THREE.DirectionalLight(0xffffff, 0.8);
            dir.position.set(-30, 80, 20);
            dir.castShadow = true;
            dir.shadow.mapSize.set(4096, 4096); // Higher quality shadows
            dir.shadow.camera.left = -100;
            dir.shadow.camera.right = 100;
            dir.shadow.camera.top = 100;
            dir.shadow.camera.bottom = -100;
            dir.shadow.camera.near = 0.5;
            dir.shadow.camera.far = 200;
            dir.shadow.bias = -0.0001;
            scene.add(dir);
            
            // 3. Hemisphere Light (Sky/Ground color blend)
            const hemi = new THREE.HemisphereLight(0x87ceeb, 0x8b4513, 0.3);
            hemi.position.set(0, 50, 0);
            scene.add(hemi);
            
            // 4. Rim Light (Back lighting for depth)
            const rim = new THREE.DirectionalLight(0x6699ff, 0.3);
            rim.position.set(50, 30, -50);
            scene.add(rim);
            
            // Store lights for quality adjustments
            window.mainLights = { amb, dir, hemi, rim };
	    createStarfield();

	    loadCustomIcons();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            
            window.addEventListener('resize', onResize);
            window.addEventListener('wheel', (e) => {
                camera.position.y += e.deltaY * 0.05;
                camera.position.y = Math.max(30, Math.min(180, camera.position.y));
            });
            
            renderer.domElement.addEventListener('mousemove', onMM);
            renderer.domElement.addEventListener('mousedown', onMD);
            renderer.domElement.addEventListener('mouseup', onMU);
	    
	    loadMap(0);
            initUI();
	    loadSettings(); // NEW: Load Volume & Graphics
            animate();
            
            // Audio init on any click
            ['click', 'touchstart'].forEach(evt => 
    	    window.addEventListener(evt, () => AudioSys.init(), {once:true})
	    );
            
            // CRITICAL: Notify CrazyGames that loading is complete
            // Main menu is now visible and ready
            notifyLoadingComplete();
        }

        // --- ALMANAC ---
        function showAlmanac() {
            hideAllScreens();
            document.getElementById('almanac-menu').style.display = 'flex';
            renderAlmanac('towers'); // Default tab
        }

        function renderAlmanac(tab) {
            const grid = document.getElementById('almanac-grid');
            grid.innerHTML = '';
            document.getElementById('almanac-details').style.display = 'none';

            if(tab === 'towers') {
                Object.keys(TOWERS).forEach(k => {
                    const t = TOWERS[k];
                    const unlockedLvl = unlocks.towers[k];
                    const item = document.createElement('div');
                    item.className = 'almanac-item';
                    
                    // NEW: Use the 3D Tower Icon
                    item.innerHTML = `
                        <img src="${TOWER_ICONS[k]}" onerror="this.src='assets/towers/placeholder.png'" style="width:64px; height:64px; object-fit:contain; filter:drop-shadow(0 4px 6px rgba(0,0,0,0.5)); margin-bottom:5px;">
                        <span style="color:${unlockedLvl>0?'white':'#555'}; font-size:12px;">${t.name}</span>
                    `;
                    
                    item.onclick = () => showTowerDetails(k, t, unlockedLvl);
                    grid.appendChild(item);
                });
            } else {
                Object.keys(ENEMIES).forEach(k => {
                    const e = ENEMIES[k];
                    const unlocked = unlocks.enemies.includes(k);
                    const item = document.createElement('div');
                    item.className = unlocked ? 'almanac-item' : 'almanac-item locked';
                    
                    // NEW: Use the 3D Enemy Icon (or a mystery box if locked)
                    let iconHtml;
                    if(unlocked) {
                        iconHtml = `<img src="${ENEMY_ICONS[k]}" onerror="this.src='assets/enemies/placeholder.png'" style="width:64px; height:64px; object-fit:contain; filter:drop-shadow(0 4px 6px rgba(0,0,0,0.5)); margin-bottom:5px;">`;
                    } else {
                        // Mystery Box for locked enemies
                        iconHtml = `<div style="width:64px; height:64px; background:#222; border-radius:8px; display:flex; align-items:center; justify-content:center; margin-bottom:5px; font-size:30px; color:#444;">?</div>`;
                    }

                    item.innerHTML = `
                        ${iconHtml}
                        <span style="font-size:12px;">${unlocked ? k.toUpperCase() : '???'}</span>
                    `;
                    
                    if(unlocked) item.onclick = () => showEnemyDetails(k, e);
                    grid.appendChild(item);
                });
            }
        }

	// Prevent scrolling inside these panels from zooming the game camera
        ['tower-panel', 'tower-grid-container', 'inspect-panel', 'settings-modal'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('wheel', function(e) {
                    e.stopPropagation(); // Stop the event from reaching the Game Camera
                }, { passive: false });
            }
        });

	function toggleHealthBars() {
            healthBarsEnabled = !healthBarsEnabled;
            document.getElementById('set-hp-btn').innerText = healthBarsEnabled ? "ON" : "OFF";
            saveSettings();
            
            // Apply immediately
            enemies.forEach(e => {
                if(e.hpGroup) e.hpGroup.visible = healthBarsEnabled;
            });
        }

        function setBloomStrength(val) {
            bloomStrength = val / 10; // Slider 0-50 becomes 0.0 - 5.0
            if(bloomPass) bloomPass.strength = bloomStrength;
            saveSettings();
        }

        function setFOV(val) {
            cameraFOV = parseInt(val);
            camera.fov = cameraFOV;
            camera.updateProjectionMatrix();
            saveSettings();
        }

	function startPreview(key, isEnemy) {
            const container = document.getElementById('preview-stage');
            if(!container) return;

            if(previewModel) previewScene.remove(previewModel);
            isPreviewing = false;

            setTimeout(() => {
                const w = container.clientWidth || 300; 
                const h = container.clientHeight || 200;
                if (w === 0 || h === 0) return; 

                previewRenderer.setSize(w, h);
                previewCam.aspect = w / h;
                previewCam.updateProjectionMatrix();
                
                container.innerHTML = '';
                container.appendChild(previewRenderer.domElement);

                // Create & Center Model
                if(isEnemy) {
                    const def = ENEMIES[key];
                    previewModel = createEnemyModel(key, def.color, 0.8); 
                } else {
                    previewModel = createTowerModel(key, 1);
                }
                
                // --- FIX: Center the preview model ---
                centerModel(previewModel);
                // -------------------------------------

                previewCam.position.set(0, 2, 6); // Move camera closer
                previewCam.lookAt(0, 0, 0);       // Look at absolute center

                previewScene.add(previewModel);
                isPreviewing = true;
            }, 50); 
        }

function showTowerDetails(key, t, maxLvl) {
    const det = document.getElementById('almanac-details');
    det.style.display = 'block';
    let html = `
                <div id="preview-stage" style="
                    width:100%; height:200px; 
                    background: radial-gradient(circle, #2c3e50 0%, #000 90%); 
                    border-radius:8px; margin-bottom:15px; 
                    display:flex; justify-content:center; align-items:center; 
                    border:1px solid #444; box-shadow: inset 0 0 20px #000;">
                </div>
                <h2 style="color:#${t.color.toString(16)}">${t.name}</h2>
            `;
    
    // --- NEW: Tower Descriptions ---
    let desc = "";
    switch(key) {
        case 'gunner':
            desc = "The basic tower. Reliable mid-range shooter with decent damage and fire rate.";
            break;
        case 'sniper':
            desc = "Long-range precision attacker with high single-target damage but slow rate of fire.";
            break;
        case 'minigun':
            desc = "Rapid-fire tower that unleashes constant bullets at close range, ideal for shredding fast enemies.";
            break;
        case 'mortar':
            desc = "Fires explosive shells that deal area damage — excellent for groups of enemies.";
            break;
        case 'laser':
            desc = "Continuous beam weapon. Deals constant direct damage over a short period to a single enemy.";
            break;
        case 'plasma':
            desc = "Launches slow, high-energy bursts that deal splash damage to multiple targets.";
            break;
        case 'ice':
            desc = "Freezes and slows enemies in range. Has a chance to stun and delay their movement.";
            break;
        case 'farm':
            desc = "Generates additional gold every few seconds. Boost your economy to build faster.";
            break;
	case 'tesla':
            desc = "Uses high-voltage arcs to zap enemies. The attack chains to nearby targets, making it great for clusters.";
            break;
        default:
            desc = "No description.";
    }

    html += `<p style="font-style:italic; color:#ccc">${desc}</p>`;

    // --- Existing Info ---
    html += `<p>Cost: $${t.cost} | Range: ${t.range} | Speed: ${t.rate}</p>`;
    if(key === 'ice') html += `<p style="color:#00cec9">Base: 0.5s Slow / 10% Stun</p>`;
    if(key === 'farm') html += `<p style="color:#2ecc71">Base: $40 / 5s</p>`;
    
    html += `<h3>Upgrades</h3>`;
    for(let i=1; i<=5; i++) {
        if(i <= maxLvl) {
            let d = t.dmg * Math.pow(1.5, i-1);
            let spd = t.rate * Math.pow(0.8, i-1);
            let extras = "";
            if(key==='ice') extras = ` | Slow ${ (0.5 + (i-1)*0.1).toFixed(1) }s`;
            if(key==='farm') extras = ` | Income $${ 40 + (i-1)*30 }`;
            if(key==='tesla') extras = ` | Chains: ${ t.chain + (i%2===0 && i>0 ? Math.floor(i/2) : Math.floor((i-1)/2)) }`;
            
            html += `<div style="margin-bottom:5px; color:#aaa;">Lvl ${i}: Dmg ${Math.floor(d)} | Spd ${spd.toFixed(2)}s${extras}</div>`;
        } else {
            html += `<div style="margin-bottom:5px; color:#444;">Lvl ${i}: Locked</div>`;
        }
    }
    det.innerHTML = html;
	startPreview(key, false);
}


        function showEnemyDetails(key, e) {
            const det = document.getElementById('almanac-details');
            det.style.display = 'block';
            
            // 1. Inject the "Preview Stage" div
            det.innerHTML = `
                <div id="preview-stage" style="
                    width:100%; height:200px; 
                    background: radial-gradient(circle, #2c3e50 0%, #000 90%); 
                    border-radius:8px; margin-bottom:15px; 
                    display:flex; justify-content:center; align-items:center; 
                    border:1px solid #444; box-shadow: inset 0 0 20px #000;">
                </div>
                <h2 style="color:#${e.color.toString(16)}">${key.toUpperCase()}</h2>
                <p>Base Health: ${e.hp}</p>
                <p>Speed: ${e.speed}</p>
                <p>Score: ${e.score}</p>
                ${e.type==='boss' ? '<p style="color:#e74c3c; font-weight:bold;">BOSS CLASS</p>' : ''}
            `;

            // 2. Activate the 3D Preview
            startPreview(key, true);
        }

	function openSettingsTab(tabName) {
            // 1. Hide all contents
            ['graphics', 'audio', 'gameplay'].forEach(t => {
                document.getElementById('tab-content-' + t).style.display = 'none';
                document.getElementById('tab-btn-' + t).classList.remove('active');
            });

            // 2. Show selected content
            document.getElementById('tab-content-' + tabName).style.display = 'flex';
            document.getElementById('tab-btn-' + tabName).classList.add('active');
        }

        // --- SETTINGS ---
        function showSettings() {
            if(document.getElementById('pause-menu').style.display === 'flex') prevMenu = 'pause';
            else prevMenu = 'main';
            
            // Save current graphics state before opening settings
            previousGraphicsMode = graphicsMode;
            previousShadowsEnabled = advancedGraphicsSettings.shadowsEnabled;
            pendingGraphicsChange = false;
            
            hideAllScreens();
            document.getElementById('settings-menu').style.display = 'flex';
            
            // Reset to Graphics tab by default
            openSettingsTab('graphics'); 
        }
        
        // ============================================================================
        // ✅ MISSING FUNCTIONS - SKILL TREE & TROPHY ROAD
        // ============================================================================
        
        function openSkillTree() {
            console.log('🌳 Opening skill tree...');
            hideAllScreens();
            const skillModal = document.getElementById('skill-tree-modal');
            if (skillModal) {
                skillModal.style.display = 'flex';
                
                // Update skill tree display
                if (typeof updateSkillTree === 'function') {
                    updateSkillTree();
                } else {
                    console.warn('⚠️ updateSkillTree function not found');
                }
            } else {
                console.error('❌ Skill tree modal not found in HTML!');
            }
        }
        
        
        function closeSkillTree() {
            const skillModal = document.getElementById('skill-tree-modal');
            if (skillModal) {
                skillModal.style.display = 'none';
            }
            document.getElementById('main-menu').style.display = 'flex';
        }
        
        function openTrophyRoad() {
            console.log('🏆 Opening trophy road...');
            const modal = document.getElementById('trophy-road-modal');
            if (modal) {
                modal.style.display = 'flex';
                buildTrophyRoadDisplay();
            } else {
                console.error('❌ Trophy road modal not found');
            }
        }
        
        function closeTrophyRoad() {
            const modal = document.getElementById('trophy-road-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }
        
        function buildTrophyRoadDisplay() {
            const container = document.getElementById('trophy-road-container');
            if (!container) {
                console.error('Trophy road container not found');
                return;
            }
            
            if (typeof playerLevel === 'undefined') {
                container.innerHTML = '<p style="text-align:center; color:#fff; padding: 40px;">⚠️ Progression system not loaded yet. Please wait...</p>';
                return;
            }
            
            let html = '<div style="padding: 20px; max-height: 70vh; overflow-y: auto;">';
            html += `<h2 style="color: #e67e22; text-align: center; margin-bottom: 10px; font-size: 32px;">Level ${playerLevel}</h2>`;
            html += `<p style="text-align: center; color: #bdc3c7; margin-bottom: 30px;">XP: ${playerXP} / ${typeof xpForLevel === 'function' ? xpForLevel(playerLevel + 1) : '???'}</p>`;
            
            // Tower Unlocks
            if (typeof towerUnlockLevels !== 'undefined') {
                html += '<h3 style="color: #3498db; margin-top: 30px; border-bottom: 2px solid #3498db; padding-bottom: 10px;">🗼 Tower Unlocks</h3>';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 15px; margin-top: 15px;">';
                
                Object.entries(towerUnlockLevels).sort((a, b) => a[1] - b[1]).forEach(([tower, level]) => {
                    const unlocked = playerLevel >= level;
                    const bgColor = unlocked ? 'rgba(46, 204, 113, 0.3)' : 'rgba(52, 73, 94, 0.5)';
                    const borderColor = unlocked ? '#2ecc71' : '#7f8c8d';
                    const textColor = unlocked ? '#2ecc71' : '#95a5a6';
                    
                    html += `
                        <div style="background: ${bgColor}; padding: 15px; border-radius: 10px; border: 2px solid ${borderColor}; text-align: center;">
                            <div style="font-size: 32px; margin-bottom: 5px;">${unlocked ? '✅' : '🔒'}</div>
                            <div style="font-weight: bold; color: ${textColor}; font-size: 14px; text-transform: uppercase;">${tower}</div>
                            <div style="font-size: 12px; color: #bdc3c7; margin-top: 5px;">Level ${level}</div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            // Branch Unlocks
            if (typeof branchUnlockLevels !== 'undefined') {
                html += '<h3 style="color: #9b59b6; margin-top: 40px; border-bottom: 2px solid #9b59b6; padding-bottom: 10px;">⚡ Branch Upgrades (Tier 5)</h3>';
                html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 15px; margin-top: 15px;">';
                
                Object.entries(branchUnlockLevels).sort((a, b) => a[1].branch1 - b[1].branch1).forEach(([tower, branches]) => {
                    const branch1Unlocked = playerLevel >= branches.branch1;
                    const branch2Unlocked = playerLevel >= branches.branch2;
                    const anyUnlocked = branch1Unlocked || branch2Unlocked;
                    
                    const bgColor = anyUnlocked ? 'rgba(155, 89, 182, 0.3)' : 'rgba(52, 73, 94, 0.5)';
                    const borderColor = anyUnlocked ? '#9b59b6' : '#7f8c8d';
                    
                    html += `
                        <div style="background: ${bgColor}; padding: 15px; border-radius: 10px; border: 2px solid ${borderColor};">
                            <div style="font-weight: bold; color: #ecf0f1; font-size: 14px; text-transform: uppercase; margin-bottom: 10px;">${tower}</div>
                            <div style="font-size: 12px; color: ${branch1Unlocked ? '#2ecc71' : '#95a5a6'}; margin-bottom: 5px;">
                                ${branch1Unlocked ? '✅' : '🔒'} Branch A (Level ${branches.branch1})
                            </div>
                            <div style="font-size: 12px; color: ${branch2Unlocked ? '#2ecc71' : '#95a5a6'};">
                                ${branch2Unlocked ? '✅' : '🔒'} Branch B (Level ${branches.branch2})
                            </div>
                        </div>
                    `;
                });
                
                html += '</div>';
            }
            
            html += '</div>';
            container.innerHTML = html;
        }
        
        function showControls() {
            hideAllScreens();
            document.getElementById('controls-menu').style.display = 'flex';
        }
        function backFromSettings() {
            // Check if shadow state changed
            const currentShadowsEnabled = advancedGraphicsSettings.shadowsEnabled;
            const shadowStateChanged = (previousShadowsEnabled !== currentShadowsEnabled);
            
            // Check graphics mode categories
            const wasLowMedium = (previousGraphicsMode === 0 || previousGraphicsMode === 1);
            const isLowMedium = (graphicsMode === 0 || graphicsMode === 1);
            const wasHighUltra = (previousGraphicsMode === 2 || previousGraphicsMode === 3);
            const isHighUltra = (graphicsMode === 2 || graphicsMode === 3);
            const wasHigh = (previousGraphicsMode === 2);
            const isHigh = (graphicsMode === 2);
            const wasUltra = (previousGraphicsMode === 3);
            const isUltra = (graphicsMode === 3);
            const wasLow = (previousGraphicsMode === 0);
            const isLow = (graphicsMode === 0);
            const wasMedium = (previousGraphicsMode === 1);
            const isMedium = (graphicsMode === 1);
            
            // Check if this is a downgrade (HIGH/ULTRA → LOW/MEDIUM)
            const isDowngrade = wasHighUltra && isLowMedium;
            
            // Check if switching between LOW and MEDIUM (no popup needed)
            const switchingLowMedium = (wasLow && isMedium) || (wasMedium && isLow);
            
            // Show popup ONLY when:
            // 1. Going from LOW/MEDIUM → HIGH/ULTRA (upgrading)
            // 2. Going HIGH ↔ ULTRA (switching between high tier)
            // 3. Shadows changed via advanced settings (BUT NOT if it's a downgrade or LOW↔MEDIUM)
            // NO popup when going HIGH/ULTRA → LOW/MEDIUM (downgrading is fine)
            // NO popup when going LOW ↔ MEDIUM (switching low tier is fine)
            const upgradingToHighTier = wasLowMedium && isHighUltra;
            const switchingHighTier = (wasHigh && isUltra) || (wasUltra && isHigh);
            // Only include shadowStateChanged if it's NOT a downgrade and NOT LOW↔MEDIUM
            const needsRestart = upgradingToHighTier || switchingHighTier || (shadowStateChanged && !isDowngrade && !switchingLowMedium);
            
            // Only show if graphics mode actually changed or shadows changed (and not downgrading or LOW↔MEDIUM)
            if(needsRestart && (graphicsMode !== previousGraphicsMode || (shadowStateChanged && !isDowngrade && !switchingLowMedium))) {
                // Show restart warning popup
                pendingGraphicsChange = true;
                hideAllScreens();
                document.getElementById('graphics-restart-warning').style.display = 'flex';
                // Block background interaction
                document.body.style.overflow = 'hidden';
                // Prevent scrolling
                document.addEventListener('wheel', preventScroll, { passive: false });
                document.addEventListener('touchmove', preventScroll, { passive: false });
                return;
            }
            
            // Clean up event listeners if they were added
            document.removeEventListener('wheel', preventScroll);
            document.removeEventListener('touchmove', preventScroll);
            
            // No restart needed, proceed normally
            hideAllScreens();
            // Ensure graphics settings are applied when returning from settings
            if (typeof applyGraphicsSettings === 'function') {
                applyGraphicsSettings();
            }
            if(prevMenu === 'pause') {
                document.getElementById('pause-menu').style.display = 'flex';
                setGameUIVisible(true);
            } else {
                document.getElementById('main-menu').style.display = 'flex';
                // Show legal links in main menu
                const legalLinks = document.getElementById('legal-links');
                if(legalLinks) legalLinks.style.display = 'block';
            }
        }
        
        function confirmGraphicsRestart() {
            // Hide first popup, show confirmation popup
            document.getElementById('graphics-restart-warning').style.display = 'none';
            document.getElementById('graphics-restart-confirm').style.display = 'flex';
        }
        
        function preventScroll(e) {
            e.preventDefault();
            e.stopPropagation();
            return false;
        }
        
        function cancelGraphicsChange() {
            // Revert graphics settings to previous state
            graphicsMode = previousGraphicsMode;
            applyGraphicsPreset(previousGraphicsMode);
            
            // Hide popups
            document.getElementById('graphics-restart-warning').style.display = 'none';
            document.getElementById('graphics-restart-confirm').style.display = 'none';
            document.body.style.overflow = '';
            
            // Remove scroll prevention
            document.removeEventListener('wheel', preventScroll);
            document.removeEventListener('touchmove', preventScroll);
            
            // Return to settings menu
            hideAllScreens();
            document.getElementById('settings-menu').style.display = 'flex';
            openSettingsTab('graphics');
        }
        
        function proceedWithRestart() {
            // Remove scroll prevention before reload
            document.removeEventListener('wheel', preventScroll);
            document.removeEventListener('touchmove', preventScroll);
            // Save settings before restart
            saveSettings();
            // Reload the page
            window.location.reload();
        }
        function toggleSettingsSound() {
            const m = AudioSys.toggle();
            // This is old toggle logic, sliders handle this now. Kept for safety.
        }
        function toggleGraphics() {
            graphicsMode = (graphicsMode + 1) % 4; // 0=Low, 1=Medium, 2=High, 3=Ultra (skip Custom when cycling)
            applyGraphicsPreset(graphicsMode);
        }
        
        function applyGraphicsPreset(preset) {
            const btn = document.getElementById('set-gfx-btn');
            if (!btn) return;
            
            graphicsMode = preset;
            let presetName = '';
            
            if (preset === 0) { // LOW
                presetName = "LOW";
                advancedGraphicsSettings = {
                    shadowsEnabled: false, shadowResolution: 512, shadowSoftness: 0,
                    lightingQuality: 0.5, bloomEnabled: false, bloomIntensity: 0,
                    ssaoEnabled: false, ssaoIntensity: 0, motionBlurEnabled: false,
                    motionBlurStrength: 0, dofEnabled: false, dofStrength: 0,
                    particleMultiplier: 0.5, postProcessingEnabled: false,
                    renderDistance: 0.7, lodBias: 0.5, pixelRatio: 0.75,
                    antiAliasing: false, colorCorrection: false
                };
            } else if (preset === 1) { // MEDIUM
                presetName = "MEDIUM";
                advancedGraphicsSettings = {
                    shadowsEnabled: true, shadowResolution: 1024, shadowSoftness: 0,
                    lightingQuality: 0.7, bloomEnabled: true, bloomIntensity: 1.0,
                    ssaoEnabled: false, ssaoIntensity: 0, motionBlurEnabled: false,
                    motionBlurStrength: 0, dofEnabled: false, dofStrength: 0,
                    particleMultiplier: 0.75, postProcessingEnabled: true,
                    renderDistance: 0.85, lodBias: 0.75, pixelRatio: 1.0,
                    antiAliasing: false, colorCorrection: false
                };
            } else if (preset === 2) { // HIGH
                presetName = "HIGH";
                advancedGraphicsSettings = {
                    shadowsEnabled: true, shadowResolution: 2048, shadowSoftness: 1,
                    lightingQuality: 0.9, bloomEnabled: true, bloomIntensity: 1.3,
                    ssaoEnabled: true, ssaoIntensity: 0.8, motionBlurEnabled: false,
                    motionBlurStrength: 0.3, dofEnabled: false, dofStrength: 0.3,
                    particleMultiplier: 1.0, postProcessingEnabled: true,
                    renderDistance: 1.0, lodBias: 1.0, pixelRatio: 1.5,
                    antiAliasing: true, colorCorrection: true
                };
            } else if (preset === 3) { // ULTRA
                presetName = "ULTRA";
                advancedGraphicsSettings = {
                    shadowsEnabled: true, shadowResolution: 4096, shadowSoftness: 2,
                    lightingQuality: 1.0, bloomEnabled: true, bloomIntensity: 1.5,
                    ssaoEnabled: true, ssaoIntensity: 1.0, motionBlurEnabled: true,
                    motionBlurStrength: 0.5, dofEnabled: true, dofStrength: 0.5,
                    particleMultiplier: 1.5, postProcessingEnabled: true,
                    renderDistance: 1.2, lodBias: 1.2, pixelRatio: 2.0,
                    antiAliasing: true, colorCorrection: true
                };
            } else { // CUSTOM
                presetName = "CUSTOM";
            }
            
            btn.innerText = presetName;
            applyGraphicsSettings();
            if (typeof updateAdvancedUI === 'function') updateAdvancedUI();
            saveSettings();
        }
        
        function applyGraphicsSettings() {
            const s = advancedGraphicsSettings;
            shadowsEnabled = s.shadowsEnabled;
            
            if (renderer) {
                renderer.shadowMap.enabled = s.shadowsEnabled;
                if (s.shadowsEnabled) {
                    if (s.shadowSoftness === 0) renderer.shadowMap.type = THREE.BasicShadowMap;
                    else if (s.shadowSoftness === 1) renderer.shadowMap.type = THREE.PCFShadowMap;
                    else renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                }
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, s.pixelRatio));
            }
            
            scene.traverse(o => {
                if (o.isLight && o.shadow) {
                    o.shadow.mapSize.width = s.shadowResolution;
                    o.shadow.mapSize.height = s.shadowResolution;
                    o.shadow.needsUpdate = true;
                }
                if (o.isMesh) {
                    o.castShadow = s.shadowsEnabled;
                    o.receiveShadow = s.shadowsEnabled;
                }
                if (o.isLight) {
                    if (o.isAmbientLight) o.intensity = 0.3 + (s.lightingQuality * 0.2);
                    if (o.isDirectionalLight) o.intensity = 0.5 + (s.lightingQuality * 0.5);
                }
            });
            
            if (bloomPass) {
                bloomPass.enabled = s.bloomEnabled && s.postProcessingEnabled;
                bloomPass.strength = s.bloomIntensity;
                bloomPass.threshold = 0.85;
                bloomPass.radius = 0.4;
            }
            
            if (window.ssaoPass) window.ssaoPass.enabled = s.ssaoEnabled && s.postProcessingEnabled;
            if (window.smaaPass) window.smaaPass.enabled = s.antiAliasing && s.postProcessingEnabled;
            if (window.colorCorrectionPass) window.colorCorrectionPass.enabled = s.colorCorrection && s.postProcessingEnabled;
            
            if (scene.fog) scene.fog.density = 0.002 / s.renderDistance;
            
            console.log(`Graphics preset applied: ${graphicsMode === 4 ? 'CUSTOM' : ['LOW', 'MEDIUM', 'HIGH', 'ULTRA'][graphicsMode]}`);
        }
        
        // Achievement System
        function checkAchievement(achievementId) {
            if (!achievementsData[achievementId]) return;
            const ach = achievementsData[achievementId];
            if (ach.unlocked) return;
            if (ach.progress >= ach.total) {
                ach.unlocked = true;
                showAchievementUnlock(achievementId);
                saveAchievements();
            }
        }
        
        function showAchievementUnlock(achievementId) {
            const achievements = {
                first_blood: { name: "First Blood", desc: "Destroy your first enemy", icon: "💀" },
                tower_master: { name: "Tower Master", desc: "Build 10 towers", icon: "🗼" },
                wave_warrior: { name: "Wave Warrior", desc: "Complete 50 waves", icon: "🌊" },
                millionaire: { name: "Millionaire", desc: "Earn 1,000,000 gold total", icon: "💰" },
                no_damage: { name: "Untouchable", desc: "Complete a map without taking damage", icon: "🛡️" },
                speed_demon: { name: "Speed Demon", desc: "Complete a wave in under 30 seconds", icon: "⚡" },
                collector: { name: "Collector", desc: "Unlock all 20 towers", icon: "📦" },
                survivor: { name: "Survivor", desc: "Reach wave 100", icon: "🏆" }
            };
            const ach = achievements[achievementId];
            if (!ach) return;
            
            const popup = document.createElement('div');
            popup.style.cssText = 'position:fixed;top:20px;right:20px;background:#2ecc71;color:#fff;padding:20px;border-radius:10px;z-index:999999;font-size:18px;font-weight:bold;box-shadow:0 4px 20px rgba(0,0,0,0.5);';
            popup.innerHTML = `<div style="font-size:40px;text-align:center;">${ach.icon}</div><div>Achievement Unlocked!</div><div style="font-size:16px;font-weight:normal;margin-top:5px;">${ach.name}</div>`;
            document.body.appendChild(popup);
            setTimeout(() => popup.remove(), 3000);
        }
        
	function openLegal(type) {
    const title = document.getElementById('legal-title');
    const content = document.getElementById('legal-content');
    const modal = document.getElementById('legal-modal');

    if (type === 'terms') {
        title.innerText = "Terms of Service";
        content.innerHTML = `
        <strong>Last Updated: February 2026</strong><br><br>
        
        <strong>1. Acceptance of Terms</strong><br>
        By accessing and playing Karlos TD, you agree to be bound by these Terms of Service. If you do not agree, please do not use this game.<br><br>
        
        <strong>2. Game Usage</strong><br>
        • The game is provided "as is" for entertainment purposes<br>
        • You must be at least 12 years old to play<br>
        • You are responsible for your gameplay and account actions<br>
        • No warranties are made regarding availability, performance, or features<br><br>
        
        <strong>3. Intellectual Property</strong><br>
        • Karlos TD, including all game code, graphics, audio, and design elements, is owned by the game developer<br>
        • You retain ownership of gameplay strategies, tower placement patterns, and user-generated content<br>
        • You may not copy, modify, distribute, or create derivative works of the game without permission<br>
        • Screenshots and gameplay videos for personal use are permitted<br><br>
        
        <strong>4. Prohibited Conduct</strong><br>
        You agree NOT to:<br>
        • Exploit bugs, glitches, or game vulnerabilities<br>
        • Use cheats, hacks, or third-party software to gain unfair advantages<br>
        • Harass, abuse, or disrupt other players in multiplayer mode<br>
        • Attempt to access unauthorized areas or data<br>
        • Use offensive names or communicate inappropriately<br>
        • Reverse engineer, decompile, or disassemble the game code<br><br>
        
        <strong>5. Multiplayer & User Content</strong><br>
        • Multiplayer sessions are temporary and may be terminated at any time<br>
        • We reserve the right to remove players who violate these terms<br>
        • You retain ownership of any gameplay strategies or tower placements<br>
        • By playing multiplayer, you consent to interaction with other players<br>
        • We are not responsible for the conduct of other players in multiplayer sessions<br><br>
        
        <strong>6. Modifications & Updates</strong><br>
        • We may update game features, balance, or content without notice<br>
        • Progression data may be reset during major updates (we will attempt to notify users when possible)<br>
        • These terms may change; continued use means acceptance<br>
        • We reserve the right to modify, suspend, or discontinue any aspect of the game<br><br>
        
        <strong>7. Limitation of Liability</strong><br>
        • The game is provided "as is" without warranties of any kind<br>
        • We are not liable for any indirect, incidental, or consequential damages<br>
        • Our total liability is limited to the amount you paid for the game (if any)<br>
        • No guarantee of uninterrupted service or data persistence<br>
        • Not responsible for loss of progress, items, or achievements due to technical issues<br><br>
        
        <strong>8. Termination</strong><br>
        • We may terminate or suspend your access to the game at any time for violations of these terms<br>
        • You may stop playing at any time<br>
        • Upon termination, your local game data may be deleted<br>
        • Multiplayer sessions may be terminated without notice<br><br>
        
        <strong>9. Disclaimers</strong><br>
        • Platform features (like CrazyGames) operate under their own terms<br>
        • Third-party services integrated into the game have their own terms and privacy policies<br>
        • We are not responsible for third-party platform outages or issues<br><br>
        
        <strong>10. Governing Law</strong><br>
        • These terms are governed by applicable local laws<br>
        • Any disputes will be resolved through appropriate legal channels<br>
        • If any provision is found unenforceable, the remaining provisions remain in effect<br><br>
        
        <strong>11. Contact</strong><br>
        For questions or concerns, visit: <a href="https://k4rl0.itch.io/karlos-td" target="_blank" style="color:#3498db;">k4rl0.itch.io/karlos-td</a>
        `;
    }

    if (type === 'privacy') {
        title.innerText = "Privacy Policy";
        content.innerHTML = `
        <strong>Last Updated: February 2026</strong><br><br>
        
        <strong>1. Information We Collect</strong><br>
        Karlos TD is designed to respect your privacy. We collect minimal information:<br><br>
        
        <strong>Locally Stored Data (Your Device Only):</strong><br>
        • Game progression and unlocked towers<br>
        • Settings preferences (audio, graphics, controls)<br>
        • Achievement progress and statistics<br>
        • Player level and experience points<br>
        • Skill tree progress and skill point allocations<br>
        <em>This data stays on your device and is never transmitted to our servers.</em><br><br>
        
        <strong>Multiplayer Session Data (Temporary):</strong><br>
        • Player display name (chosen by you)<br>
        • Temporary room codes and session identifiers<br>
        • Real-time gameplay actions (tower placement, wave progress)<br>
        • Connection quality metrics (ping, latency)<br>
        <em>This data is deleted when the multiplayer session ends and is not stored permanently.</em><br><br>
        
        <strong>2. Cookies & Local Storage</strong><br>
        • The game uses browser localStorage to save your game progress and settings<br>
        • No tracking cookies are used by the game itself<br>
        • You can clear your browser's localStorage to delete all game data<br>
        • Third-party platforms (like CrazyGames) may use their own cookies - see their privacy policies<br><br>
        
        <strong>3. What We Do NOT Collect</strong><br>
        • Personal identification (real names, emails, phone numbers)<br>
        • Passwords or login credentials<br>
        • IP addresses or precise location data<br>
        • Financial or payment information<br>
        • Browsing history or external data<br>
        • Device identifiers or advertising IDs<br>
        • Biometric data or sensitive personal information<br><br>
        
        <strong>4. Third-Party Platforms</strong><br>
        If you play on CrazyGames or similar platforms:<br>
        • They may collect analytics for performance and engagement<br>
        • They operate under their own privacy policies<br>
        • We do not control or access their data collection<br>
        • Review their privacy policies: <a href="https://www.crazygames.com/privacy-policy" target="_blank" style="color:#3498db;">CrazyGames Privacy Policy</a><br>
        • GameJolt integration (if enabled) operates under GameJolt's privacy policy<br><br>
        
        <strong>5. Data Retention</strong><br>
        • Local game data persists until you clear your browser's localStorage<br>
        • Multiplayer session data is deleted immediately when sessions end<br>
        • No data is retained on our servers after multiplayer sessions conclude<br>
        • Achievement data is stored locally and can be cleared at any time<br><br>
        
        <strong>6. Children's Privacy</strong><br>
        • We do not knowingly collect data from children under 12<br>
        • No account creation or personal information required<br>
        • Parents: Game is safe for supervised play<br>
        • If you believe we have collected data from a child under 12, please contact us<br>
        • We comply with COPPA (Children's Online Privacy Protection Act) requirements<br><br>
        
        <strong>7. Data Security</strong><br>
        • Local data is stored using browser localStorage (encrypted by the browser)<br>
        • Multiplayer uses secure WebSocket connections (WSS) for encrypted communication<br>
        • No permanent servers store your personal data<br>
        • We implement reasonable security measures, but no system is 100% secure<br>
        • You are responsible for keeping your device secure<br><br>
        
        <strong>8. International Users</strong><br>
        • If you are in the European Economic Area (EEA), you have rights under GDPR<br>
        • If you are in California, you have rights under CCPA<br>
        • You can request access to, deletion of, or correction of your data<br>
        • To exercise these rights, clear your browser's localStorage or contact us<br>
        • We do not sell your personal data to third parties<br><br>
        
        <strong>9. Your Rights</strong><br>
        • <strong>Right to Access:</strong> View your local game data through browser developer tools<br>
        • <strong>Right to Deletion:</strong> Clear your browser data to delete local progression<br>
        • <strong>Right to Correction:</strong> Reset game progress or settings as needed<br>
        • <strong>Right to Portability:</strong> Export your save data (via browser localStorage)<br>
        • Close multiplayer sessions to remove temporary data<br>
        • Use incognito/private mode for no data storage<br><br>
        
        <strong>10. Changes to This Policy</strong><br>
        • We may update this privacy policy from time to time<br>
        • Changes will be reflected in the "Last Updated" date at the top<br>
        • Significant changes will be communicated through the game or our website<br>
        • Continued use of the game after changes means you accept the updated policy<br>
        • We encourage you to review this policy periodically<br><br>
        
        <strong>11. Contact & Updates</strong><br>
        For privacy questions or to exercise your rights: <a href="https://k4rl0.itch.io/karlos-td" target="_blank" style="color:#3498db;">k4rl0.itch.io/karlos-td</a><br>
        We will respond to privacy inquiries within a reasonable timeframe.
        `;
    }

    modal.style.display = "flex";
}

function closeLegal() {
    document.getElementById('legal-modal').style.display = "none";
}

        function trackKill() {
            totalKills++;
            achievementsData.first_blood.progress = Math.max(1, achievementsData.first_blood.progress);
            checkAchievement('first_blood');
            saveAchievements();
        }
        
        function trackTowerBuild() {
            if (achievementsData.tower_master.progress < towers.length) {
                achievementsData.tower_master.progress = towers.length;
                checkAchievement('tower_master');
            }
            saveAchievements();
        }
        
        function trackWaveComplete() {
            wavesCompleted++;
            achievementsData.wave_warrior.progress = wavesCompleted;
            achievementsData.survivor.progress = wavesCompleted;
            checkAchievement('wave_warrior');
            checkAchievement('survivor');
            saveAchievements();
        }
        
        function trackGoldEarned(amount) {
            totalGoldEarned += amount;
            achievementsData.millionaire.progress = totalGoldEarned;
            checkAchievement('millionaire');
            saveAchievements();
        }
        
        function saveAchievements() {
            try {
                localStorage.setItem('achievements', JSON.stringify(achievementsData));
                localStorage.setItem('achievementStats', JSON.stringify({ totalKills, totalGoldEarned, wavesCompleted }));
            } catch(e) {}
        }
        
        function loadAchievements() {
            try {
                const saved = localStorage.getItem('achievements');
                if (saved) Object.assign(achievementsData, JSON.parse(saved));
                const stats = localStorage.getItem('achievementStats');
                if (stats) {
                    const s = JSON.parse(stats);
                    totalKills = s.totalKills || 0;
                    totalGoldEarned = s.totalGoldEarned || 0;
                    wavesCompleted = s.wavesCompleted || 0;
                }
            } catch(e) {}
        }
        
        function openAchievements() {
            const modal = document.getElementById('achievements-modal');
            if (modal) {
                modal.style.display = 'flex';
                refreshAchievementsUI();
            }
        }
        
        // Separate function to refresh the achievements list without opening the modal
        window.refreshAchievementsUI = function() {
            const list = document.getElementById('achievements-list');
            if (!list) return;
            
            list.innerHTML = '';
            
            // Use achievements from progression.js if available
            if (typeof window.achievements !== 'undefined' && window.achievements.length > 0) {
                console.log(`📋 Showing ${window.achievements.length} achievements from progression.js`);
                
                // Count unlocked achievements
                const unlockedCount = window.achievements.filter(ach => ach.unlocked).length;
                const totalCount = window.achievements.length;
                
                // Add progress header
                const header = document.createElement('div');
                header.style.cssText = `
                    background: linear-gradient(135deg, #9b59b6, #8e44ad);
                    padding: 15px;
                    border-radius: 10px;
                    margin-bottom: 15px;
                    text-align: center;
                    font-size: 18px;
                    font-weight: bold;
                    color: white;
                `;
                header.innerHTML = `🏆 ${unlockedCount}/${totalCount} Achievements Unlocked`;
                list.appendChild(header);
                
                window.achievements.forEach(ach => {
                    const item = document.createElement('div');
                    item.style.cssText = `background:${ach.unlocked ? '#2ecc71' : '#34495e'};padding:15px;border-radius:10px;display:flex;align-items:center;gap:15px;margin-bottom:10px;transition:all 0.3s;`;
                    item.innerHTML = `
                        <div style="font-size:30px;">${ach.icon}</div>
                        <div style="flex:1;">
                            <div style="font-weight:bold;font-size:16px;">${ach.name}</div>
                            <div style="font-size:14px;opacity:0.8;">${ach.desc}</div>
                        </div>
                        <div style="font-size:20px;">${ach.unlocked ? '✓' : '🔒'}</div>
                    `;
                    list.appendChild(item);
                });
            } else {
                // Fallback to old system
                console.log('⚠️ Using fallback achievements (progression.js not loaded)');
                
                const achievements = {
                    first_blood: { name: "First Blood", desc: "Destroy your first enemy", icon: "💀" },
                    tower_master: { name: "Tower Master", desc: "Build 10 towers", icon: "🗼" },
                    wave_warrior: { name: "Wave Warrior", desc: "Complete 50 waves", icon: "🌊" },
                    millionaire: { name: "Millionaire", desc: "Earn 1,000,000 gold total", icon: "💰" },
                    no_damage: { name: "Untouchable", desc: "Complete a map without taking damage", icon: "🛡️" },
                    speed_demon: { name: "Speed Demon", desc: "Complete a wave in under 30 seconds", icon: "⚡" },
                    collector: { name: "Collector", desc: "Unlock all 20 towers", icon: "📦" },
                    survivor: { name: "Survivor", desc: "Reach wave 100", icon: "🏆" }
                };
                
                Object.keys(achievements).forEach(id => {
                    const ach = achievements[id];
                    const data = achievementsData[id];
                    const unlocked = data && data.unlocked;
                    const progress = data ? data.progress : 0;
                    const total = data ? data.total : 1;
                    
                    const item = document.createElement('div');
                    item.style.cssText = `background:${unlocked ? '#2ecc71' : '#34495e'};padding:15px;border-radius:10px;display:flex;align-items:center;gap:15px;`;
                    item.innerHTML = `
                        <div style="font-size:30px;">${ach.icon}</div>
                        <div style="flex:1;">
                            <div style="font-weight:bold;font-size:16px;">${ach.name}</div>
                            <div style="font-size:14px;opacity:0.8;">${ach.desc}</div>
                            ${!unlocked ? `<div style="font-size:12px;margin-top:5px;">Progress: ${progress}/${total}</div>` : ''}
                        </div>
                        <div style="font-size:20px;">${unlocked ? '✓' : '🔒'}</div>
                    `;
                    list.appendChild(item);
                });
            }
        };
        
        function closeAchievements() {
            const modal = document.getElementById('achievements-modal');
            if (modal) modal.style.display = 'none';
        }
        
        // Advanced Graphics UI
        function openAdvancedGraphics() {
            const modal = document.getElementById('advanced-graphics-modal');
            if (modal) {
                modal.style.display = 'flex';
                updateAdvancedUI();
            }
        }
        
        function closeAdvancedGraphics() {
            const modal = document.getElementById('advanced-graphics-modal');
            if (modal) modal.style.display = 'none';
        }
        
        function updateAdvancedUI() {
            const s = advancedGraphicsSettings;
            const setVal = (id, val) => { const el = document.getElementById(id); if (el) el.value = val; };
            const setChecked = (id, val) => { const el = document.getElementById(id); if (el) el.checked = val; };
            
            setChecked('adv-shadows', s.shadowsEnabled);
            setVal('adv-shadow-res', s.shadowResolution);
            setVal('adv-shadow-soft', s.shadowSoftness);
            setVal('adv-lighting', s.lightingQuality);
            setChecked('adv-bloom', s.bloomEnabled);
            setVal('adv-bloom-int', s.bloomIntensity);
            setChecked('adv-ssao', s.ssaoEnabled);
            setVal('adv-ssao-int', s.ssaoIntensity);
            setChecked('adv-post', s.postProcessingEnabled);
            setVal('adv-render-dist', s.renderDistance);
            setVal('adv-pixel', s.pixelRatio);
            setChecked('adv-aa', s.antiAliasing);
        }
        
        function updateAdvancedSetting(setting, value) {
            advancedGraphicsSettings[setting] = value;
            graphicsMode = 4; // Switch to CUSTOM
            const btn = document.getElementById('set-gfx-btn');
            if (btn) btn.innerText = "CUSTOM";
            applyGraphicsSettings();
            saveSettings();
            
            // Track if shadows were changed (for restart warning)
            if(setting === 'shadowsEnabled') {
                pendingGraphicsChange = (previousShadowsEnabled !== value);
            }
        }
	function toggleShake() {
            shakeEnabled = !shakeEnabled;
            document.getElementById('set-shake-btn').innerText = shakeEnabled ? "ON" : "OFF";
	    saveSettings(); // Save it!
        }

        function toggleDmgText() {
            dmgTextEnabled = !dmgTextEnabled;
            document.getElementById('set-dmg-btn').innerText = dmgTextEnabled ? "ON" : "OFF";
	    saveSettings(); // Save it!
        }
        
        // Helper to trigger shake (Call this when explosions happen!)
        let activeShake = null; // Track active shake interval
        
        function addTrauma(amount) {
    if(!shakeEnabled) return;
    
    // Clear any existing shake
    if(activeShake) {
        clearInterval(activeShake);
        activeShake = null;
    }

    // 1. Capture where the camera IS RIGHT NOW
    const startPos = camera.position.clone(); 
    
    const shakeDuration = 200; 
    const shakeIntensity = amount * 2; 

    activeShake = setInterval(() => {
        // 2. Shake relative to the SAVED position, not the current one
        // This prevents the camera from drifting away
        camera.position.x = startPos.x + (Math.random()-0.5) * shakeIntensity;
        camera.position.y = startPos.y + (Math.random()-0.5) * shakeIntensity;
        camera.position.z = startPos.z + (Math.random()-0.5) * shakeIntensity;
    }, 16);

    setTimeout(() => {
        clearInterval(activeShake);
        activeShake = null;
        // 3. Restore the camera to exactly where it was before the shake
        camera.position.copy(startPos); 
    }, shakeDuration);
}
        function toggleAutoStart() {
            autoWave = !autoWave;
            document.getElementById('set-auto-btn').innerText = autoWave ? "ON" : "OFF";
	    saveSettings(); // Save it!
        }
        
        function toggleFPSCounter() {
            showFPSCounter = !showFPSCounter;
            const btn = document.getElementById('set-fps-btn');
            const fpsEl = document.getElementById('fps-counter');
            
            if (btn) btn.innerText = showFPSCounter ? "ON" : "OFF";
            if (fpsEl) fpsEl.style.display = showFPSCounter ? 'block' : 'none';
            
            saveSettings(); // Save it!
        }

        // --- MENU NAVIGATION ---
        function goToMainMenu() {
            // Notify CrazyGames that gameplay stopped
            notifyGameplayStop();
            
            // Hide invite button when leaving multiplayer
            hideInviteButton();
            
            resetGame();
            loadMap(0); // Load dummy map for background
            
            // --- FIX: Reset game state ---
            gameRunning = false;
            isPaused = false;
            isMultiplayerMode = false;
            // -----------------------------
            
            // --- FIX: Re-enable XP bar clickability ---
            const xpBar = document.getElementById('player-level-container');
            if (xpBar) {
                xpBar.style.pointerEvents = 'auto';
                xpBar.style.cursor = 'pointer';
            }
            // -----------------------------------------
            
            // --- FIX: Reset Gamemode to Shared for Single Player ---
            currentGamemode = 'shared'; 
            // -------------------------------------------------------

            // --- FIX: RESTORE SINGLE PLAYER LOGIC ---
            // 1. Reset Map Selector to Single Player Mode
            window.selectMap = function(idx) {
                selectedMapIndex = idx;
                hideAllScreens();
                document.getElementById('diff-select').style.display = 'flex';
            }

            // 2. Reset Start Game to Single Player Mode
            window.startGame = function(diff) {
                hideAllScreens();
                setGameUIVisible(true);

		// --- NEW: Set Info Panel Text (Solo) ---
    		document.getElementById('info-map-name').innerText = MAPS[selectedMapIndex].name;
    		document.getElementById('info-diff').innerText = diff.toUpperCase();
    
    		// Color code difficulty
    		const diffColor = (diff==='easy'?'#2ecc71':(diff==='medium'?'#f1c40f':'#e74c3c'));
    		document.getElementById('info-diff').style.color = diffColor;
    
    		document.getElementById('info-mode').innerText = "SOLO";

                // Ensure Single Player uses Shared logic
                currentGamemode = 'shared';

                // Diff Config (original values restored)
                if(diff === 'easy') { GAME_CONFIG = { maxWaves:20, hpMult:0.7, costMult:0.85, gold:800 }; }
                else if(diff === 'medium') { GAME_CONFIG = { maxWaves:40, hpMult:0.9, costMult:1.0, gold:650 }; }
                else { GAME_CONFIG = { maxWaves:60, hpMult:1.1, costMult:1.2, gold:500 }; }
                
                gold = GAME_CONFIG.gold;
                // Reset multiplayer wallets to match just in case
                goldHost = gold;
                goldJoiner = gold;

                document.getElementById('ui-max-wave').innerText = GAME_CONFIG.maxWaves;
                
                resetGame();

		if (typeof applySkillBonuses === 'function') {
        	applySkillBonuses();
    		}

                loadMap(selectedMapIndex);
                // Graphics settings are applied in loadMap, but ensure they're still active
                if (typeof applyGraphicsSettings === 'function') {
                    applyGraphicsSettings();
                }
                camera.position.set(0, 110, 50);
                camera.lookAt(0, 0, 0);
                AudioSys.playMusic(MAPS[selectedMapIndex].track);
                
                // Populate tower grid with new UI
                populateTowerGrid();

                gameRunning = true; 
                isPaused = false;
                updateUI();
            };
            // ----------------------------------------

            hideAllScreens();
            document.getElementById('main-menu').style.display = 'flex';
            AudioSys.playMusic('menu');
            
            // Ensure graphics settings are applied when returning to menu
            if (typeof applyGraphicsSettings === 'function') {
                applyGraphicsSettings();
            }
            
            // Update XP bar when returning to menu
            if (typeof window.updateXPBar === 'function') {
                window.updateXPBar();
            } else if (typeof window.updateXPBarDirect === 'function') {
                window.updateXPBarDirect();
            }
            
            // Show legal links in main menu
            const legalLinks = document.getElementById('legal-links');
            if(legalLinks) legalLinks.style.display = 'block';

	    // ✅ FIX 3: Ensure Multiplayer stats are gone
    const serverLoc = document.getElementById('server-location');
    const pingDisp = document.getElementById('ping-display');
    if(serverLoc) serverLoc.style.display = 'none';
    if(pingDisp) pingDisp.style.display = 'none';
            
            // Disconnect socket if we leave MP so it doesn't interfere
            if(socket) {
                socket.disconnect();
                socket = null;
                myRoomId = null;
                myRole = null;
            }
        }
        function showLevelSelect() {
            hideAllScreens();
            document.getElementById('level-select').style.display = 'flex';
            AudioSys.init();
	    balanceMapGrid();
        }
        window.selectMap = function(idx) {
            selectedMapIndex = idx;
            hideAllScreens();
            document.getElementById('diff-select').style.display = 'flex';
        }
        function hideAllScreens() {
    isPreviewing = false;
    const screens = document.querySelectorAll('.fullscreen-modal');
    screens.forEach(s => s.style.display = 'none');

    const uiLayer = document.getElementById('ui-layer');
    Array.from(uiLayer.children).forEach(d => {
        // ✅ FIX 1: REMOVED 'legal-links' from this list. 
        // Now they will automatically hide when we enter the game.
        if(!d.classList.contains('fullscreen-modal') 
           && d.id !== 'fps-counter' 
           && d.id !== 'performance-stats') { 
            d.style.display = 'none';
        }
    });

    // Also force hide the multiplayer stats when switching screens
    const serverLoc = document.getElementById('server-location');
    const pingDisp = document.getElementById('ping-display');
    if(serverLoc) serverLoc.style.display = 'none';
    if(pingDisp) pingDisp.style.display = 'none';

    document.getElementById('menu-btn').style.display = 'none';
    
    // Ensure XP bar stays visible
    const xpBar = document.getElementById('player-level-container');
    if(xpBar) xpBar.style.display = 'flex';
}

        function setGameUIVisible(visible) {
            const display = visible ? 'flex' : 'none';
            const blockDisplay = visible ? 'block' : 'none';
            
            document.getElementById('stats-bar').style.display = display;
            document.getElementById('wave-controls').style.display = display;
            
            // --- YOU ADDED THIS LINE (PERFECT) ---
            document.getElementById('tower-dock').style.display = display; 
            // -------------------------------------

            document.getElementById('menu-btn').style.display = blockDisplay;
            document.getElementById('game-info-panel').style.display = blockDisplay;
            document.getElementById('controls-hint').style.display = blockDisplay;
            
            if (!visible) document.getElementById('inspect-panel').style.display = 'none';
        }

        window.startGame = function(diff) {
    hideAllScreens();
    setGameUIVisible(true);
    
    // ✅ FIX: Force Multiplayer Stats to SHOW if we are in Multiplayer
    if (isMultiplayerMode) {
        const locEl = document.getElementById('server-location');
        const pingEl = document.getElementById('ping-counter'); // Note: ID is ping-counter in your HTML
        
        if(locEl) locEl.style.display = 'block';
        if(pingEl) pingEl.style.display = 'block';
        
        // Optional: Update the text color to show it's active
        if(locEl) locEl.style.color = '#00ff00';
    }

    // Set to singleplayer mode
    isMultiplayerMode = false;
    
    // Set Info Panel
    document.getElementById('info-map-name').innerText = MAPS[selectedMapIndex].name;
    document.getElementById('info-diff').innerText = diff.toUpperCase();
    const diffColor = (diff==='easy'?'#2ecc71':(diff==='medium'?'#f1c40f':'#e74c3c'));
    document.getElementById('info-diff').style.color = diffColor;
    document.getElementById('info-mode').innerText = "SOLO";

    // 1. Configure Difficulty (Sets Base Gold) - original values restored
    if(diff === 'easy') { GAME_CONFIG = { maxWaves:20, hpMult:0.7, costMult:0.85, gold:800 }; }
    else if(diff === 'medium') { GAME_CONFIG = { maxWaves:40, hpMult:0.9, costMult:1.0, gold:650 }; }
    else { GAME_CONFIG = { maxWaves:60, hpMult:1.1, costMult:1.2, gold:500 }; }
    
    document.getElementById('ui-max-wave').innerText = GAME_CONFIG.maxWaves;
    
    // 2. Reset Game (This sets 'gold' to GAME_CONFIG.gold)
    resetGame();

    // 3. Apply Skills (Must happen AFTER resetGame)
    if (window.applySkillBonuses) {
        console.log("👉 Attempting to apply skills..."); // Check F12 Console for this
        window.applySkillBonuses(); 
    } else {
        console.warn("⚠️ applySkillBonuses function not found!");
    }

    loadMap(selectedMapIndex);
    // Ensure graphics settings are applied after map loads
    if (typeof applyGraphicsSettings === 'function') {
        applyGraphicsSettings();
    }
    camera.position.set(0, 110, 50);
    camera.lookAt(0, 0, 0);
    
    AudioSys.playMusic(MAPS[selectedMapIndex].track);
    populateTowerGrid();

    gameRunning = true;
    isPaused = false;
    
    // 4. Final UI Update (Shows the total gold)
    updateUI();
};

        function resetGame() {
            // 1. Cleanup Scene
            enemies.forEach(e => { scene.remove(e.mesh); if(e.hpGroup) scene.remove(e.hpGroup); });
            towers.forEach(t => scene.remove(t.mesh));
            projectiles.forEach(p => scene.remove(p.mesh));
            mapProps.forEach(m => scene.remove(m));
            particles.forEach(p => scene.remove(p.mesh));
            
            if(hoverMesh) scene.remove(hoverMesh);
            if(rangeRing) scene.remove(rangeRing);
            
            // 2. Clear Arrays
            enemies = []; 
            towers = []; 
            projectiles = []; 
            particles = []; 
            mapProps = [];

            // 3. Reset State & Gold (FIXED)
            // We use GAME_CONFIG.gold so Easy mode gets $800 and Hard gets $500
            gold = (typeof GAME_CONFIG !== 'undefined' && GAME_CONFIG.gold) ? GAME_CONFIG.gold : 650;
            
            // Reset Multiplayer Wallets
	    playerWallets = [gold, gold, gold, gold];

            lives = 20; 
            wave = 0; 
            activeWave = false; 
            spawningFinished = true;
            selectedType = null; 
            selectedTower = null;

            // 4. Reset UI
            const btn = document.getElementById('btn-start-wave');
            if(btn) {
                btn.disabled = false;
                btn.innerText = "START WAVE";
                btn.style.backgroundColor = "";
            }
            
            // Safety: Ensure end screens are hidden immediately
            document.getElementById('game-over-screen').style.display = 'none';
            document.getElementById('victory-screen').style.display = 'none';
        }

        window.togglePause = function() {
            // Multiplayer Logic
            if(socket && myRoomId) {
                if(myRole === 'host') {
                    socket.emit('requestPause', { roomId: myRoomId, isPaused: !isPaused });
                }
                return; // Joiners cannot toggle locally
            }

            // Single Player Logic
            runPauseLogic(!isPaused);
        }

        // New helper to handle the actual UI/State change
        function runPauseLogic(pauseState) {
            isPaused = pauseState;
            
            // CrazyGames SDK Integration: Stop/Start gameplay tracking
            if (pauseState) {
                // Game is being paused
                notifyGameplayStop();
            } else {
                // Game is being resumed
                notifyGameplayStart();
            }
            
            // If we are unpausing, force hide ALL modals so players aren't stuck in Settings
            if (!pauseState) {
                hideAllScreens();
                setGameUIVisible(true);
            } else {
                document.getElementById('pause-menu').style.display = 'flex';
            }
        }
        window.restartLevel = function() {
            if(socket && myRoomId) {
                if(myRole === 'host') {
                    socket.emit('requestRestart', myRoomId);
                }
                return;
            }
            // Single player logic
            startGame(GAME_CONFIG.maxWaves === 20 ? 'easy' : GAME_CONFIG.maxWaves === 40 ? 'medium' : 'hard');
        }
// --- MAP GENERATION ---
        function loadMap(idx) {
            const data = MAPS[idx];
            currentWaypoints = data.path;
            
            // Apply graphics settings after map loads to ensure they persist
            if (typeof applyGraphicsSettings === 'function') {
                applyGraphicsSettings();
            }

            // --- 1. NEW ATMOSPHERE (FIXED FOG) ---
            if (idx === 0) { // Canyon
                scene.background = new THREE.Color(0x000000); 
                scene.fog = new THREE.FogExp2(0xE6C288, 0.002); 
            } else if (idx === 1) { // Frozen
                scene.background = new THREE.Color(0x2c3e50); 
                scene.fog = new THREE.FogExp2(0xaaddff, 0.004); 
            } else if (idx === 2) { // Volcano
                scene.background = new THREE.Color(0x050000); 
                scene.fog = new THREE.FogExp2(0x550000, 0.005); 
            } else if (idx === 3) { // --- KITTY KINGDOM ---
                scene.background = new THREE.Color(0xffcce0); // Light Pink Sky
                scene.fog = new THREE.FogExp2(0xffcce0, 0.006); 
	    } else if (idx === 4) { // --- THE VOID ---
                scene.background = new THREE.Color(0x050010); // Deep Purple/Black
                scene.fog = new THREE.FogExp2(0x050010, 0.008); 
            } else if (idx === 5) { // Crystal Caves
                scene.background = new THREE.Color(0x1a0b2e); // Deep Purple
                scene.fog = new THREE.FogExp2(0x1a0b2e, 0.006);
            } else if (idx === 6) { // Neon City
                scene.background = new THREE.Color(0x000022); // Cyber Blue/Black
                scene.fog = new THREE.FogExp2(0x000022, 0.004);
            } else if (idx === 7) { // Toxic Swamp
                scene.background = new THREE.Color(0x0a1a0a); // Murky Green
                scene.fog = new THREE.FogExp2(0x0a1a0a, 0.015); // Heavy Fog
            } else if (idx === 8) { // Space Station
                scene.background = new THREE.Color(0x000000); // Pure Space
                scene.fog = new THREE.FogExp2(0x000000, 0.001); // Almost no fog
            } else if (idx === 9) { // Harvest Valley (Farm)
                scene.background = new THREE.Color(0x87CEEB); // Sky Blue
                scene.fog = new THREE.FogExp2(0x87CEEB, 0.003); // Light fog
            } else if (idx === 10) { // Jungle Temple
                scene.background = new THREE.Color(0x2d4a2b); // Dark jungle green
                scene.fog = new THREE.FogExp2(0x2d4a2b, 0.008); // Dense jungle fog
            } else if (idx === 11) { // Mushroom Forest
                scene.background = new THREE.Color(0x4a2c5e); // Purple twilight
                scene.fog = new THREE.FogExp2(0x6a4c7e, 0.007); // Magical purple mist
            }
            // Floor
            const plane = new THREE.Mesh(new THREE.PlaneGeometry(240, 180), new THREE.MeshStandardMaterial({ color: data.floorColor, roughness: 0.9 }));
            plane.rotation.x = -Math.PI/2;
            plane.receiveShadow = shadowsEnabled; scene.add(plane); mapProps.push(plane);

            // Path Generation
            const pathMat = new THREE.MeshStandardMaterial({ color: 0x111111 });
            for(let i=0; i<currentWaypoints.length-1; i++) {
                const a = currentWaypoints[i], b = currentWaypoints[i+1];
                const len = a.distanceTo(b);
                const mid = new THREE.Vector3().lerpVectors(a,b,0.5);
                const road = new THREE.Mesh(new THREE.BoxGeometry(ROAD_WIDTH, 0.2, len), pathMat);
                road.position.copy(mid);
                road.position.y = 0.05; road.lookAt(b); road.receiveShadow = shadowsEnabled;
                scene.add(road); mapProps.push(road);
                const joint = new THREE.Mesh(new THREE.CylinderGeometry(ROAD_WIDTH/2, ROAD_WIDTH/2, 0.2, 16), pathMat);
                joint.position.copy(a);
                joint.position.y = 0.05; scene.add(joint); mapProps.push(joint);
                if(i===currentWaypoints.length-2) { const end = joint.clone(); end.position.copy(b); scene.add(end); mapProps.push(end); }
            }

            // Grid
            const grid = new THREE.GridHelper(240, 60, 0x000000, 0x000000);
            grid.position.y = 0.06;
            grid.position.x = GRID_SIZE / 2;
            grid.position.z = GRID_SIZE / 2;
            grid.material.opacity = 0.15;
            grid.material.transparent = true;
            scene.add(grid);
            mapProps.push(grid);
            
            // Cursor helpers
            hoverMesh = new THREE.Mesh(new THREE.BoxGeometry(3.8, 0.5, 3.8), new THREE.MeshBasicMaterial({ color: 0x3498db, transparent: true, opacity: 0.4 }));
            scene.add(hoverMesh);
            rangeRing = new THREE.Mesh(new THREE.RingGeometry(0.95, 1, 64), new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide }));
            rangeRing.rotation.x = -Math.PI/2; rangeRing.position.y = 0.5; rangeRing.visible = false; scene.add(rangeRing);
            
            // Dead zone ring (red inner circle for mortars)
            deadZoneRing = new THREE.Mesh(new THREE.CircleGeometry(1, 64), new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.25, side: THREE.DoubleSide }));
            deadZoneRing.rotation.x = -Math.PI/2; deadZoneRing.position.y = 0.51; deadZoneRing.visible = false; scene.add(deadZoneRing);

            // --- NEW: Calculate Road Directions for alignment ---
            // Start Dir: Pointing FROM start TO first waypoint
            const p0 = currentWaypoints[0];
            const p1 = currentWaypoints[1];
            const startDir = new THREE.Vector3().subVectors(p1, p0).normalize();

            // End Dir: Pointing FROM last waypoint TO base
            const last = currentWaypoints[currentWaypoints.length-1];
            const secondLast = currentWaypoints[currentWaypoints.length-2];
            const endDir = new THREE.Vector3().subVectors(last, secondLast).normalize();

            createEnvironmentProps(p0, last, startDir, endDir);
            // ----------------------------------------------------
            
            createDecorations(idx);
            createAtmosphericParticles(idx);
        }

        function createEnvironmentProps(startPos, endPos, startDir, endDir) {
            const matDark = new THREE.MeshStandardMaterial({color:0x2c3e50, roughness: 0.8});
            const matMetal = new THREE.MeshStandardMaterial({color:0x95a5a6, metalness:0.9, roughness:0.2});
            const matGlow = new THREE.MeshBasicMaterial({color:0x00ff00}); // Portal Glow
            const matBaseColor = new THREE.MeshStandardMaterial({color:0xe74c3c, roughness:0.6}); // Enemy Base Red
            const matGold = new THREE.MeshStandardMaterial({color:0xffd700, metalness:1.0, roughness:0.1});
            const matBlack = new THREE.MeshStandardMaterial({color:0x0a0a0a, roughness:0.9});

            // --- 1. SPAWN PORTAL (Advanced Stargate) ---
            const spawnGate = new THREE.Group();
            
            // Outer Ring (Thick)
            const outerRing = new THREE.Mesh(new THREE.TorusGeometry(3.5, 0.6, 20, 32), matDark);
            outerRing.position.y = 3.5;
            spawnGate.add(outerRing);
            
            // Inner Ring (Glowing)
            const innerRing = new THREE.Mesh(new THREE.TorusGeometry(3.2, 0.3, 16, 32), matGold);
            innerRing.position.y = 3.5;
            spawnGate.add(innerRing);
            
            // Chevrons (9 symbols around the ring)
            for(let i = 0; i < 9; i++) {
                const angle = (i / 9) * Math.PI * 2;
                const chevron = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.8, 0.4),
                    matMetal
                );
                chevron.position.set(
                    Math.cos(angle) * 3.5,
                    3.5 + Math.sin(angle) * 3.5,
                    0.5
                );
                chevron.rotation.z = angle;
                spawnGate.add(chevron);
            }

            // Event Horizon (Swirling portal)
            const portalMesh = new THREE.Mesh(
                new THREE.CircleGeometry(2.9, 32),
                new THREE.MeshBasicMaterial({
                    color:0x00ff00,
                    transparent:true,
                    opacity:0.6,
                    side:THREE.DoubleSide
                })
            );
            portalMesh.position.y = 3.5;
            spawnGate.add(portalMesh);
            
            // Inner vortex layer
            const vortex = new THREE.Mesh(
                new THREE.CircleGeometry(2.3, 32),
                new THREE.MeshBasicMaterial({
                    color:0x00aa00,
                    transparent:true,
                    opacity:0.8,
                    side:THREE.DoubleSide
                })
            );
            vortex.position.y = 3.5;
            vortex.position.z = -0.1;
            spawnGate.add(vortex);

            // Base Platform (Hexagonal)
            const basePlat = new THREE.Mesh(
                new THREE.CylinderGeometry(5, 5.5, 0.8, 6),
                matMetal
            );
            basePlat.position.y = 0.4;
            spawnGate.add(basePlat);
            
            // Glowing energy lines on platform
            for(let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2;
                const line = new THREE.Mesh(
                    new THREE.BoxGeometry(4, 0.1, 0.2),
                    matGlow
                );
                line.position.set(
                    Math.cos(angle) * 2,
                    0.85,
                    Math.sin(angle) * 2
                );
                line.rotation.y = angle + Math.PI/2;
                spawnGate.add(line);
            }

            // Support Pylons (4 corners)
            for(let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2 + Math.PI/4;
                const pylon = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 6, 0.8),
                    matDark
                );
                pylon.position.set(
                    Math.cos(angle) * 4,
                    3,
                    Math.sin(angle) * 4
                );
                spawnGate.add(pylon);
                
                // Pylon caps (gold)
                const cap = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.5, 0.5, 0.3, 8),
                    matGold
                );
                cap.position.set(
                    Math.cos(angle) * 4,
                    6.2,
                    Math.sin(angle) * 4
                );
                spawnGate.add(cap);
            }

            // ALIGNMENT LOGIC:
            spawnGate.position.copy(startPos).sub(startDir.clone().multiplyScalar(2));
            spawnGate.lookAt(startPos.clone().add(startDir.clone().multiplyScalar(10)));
            
            scene.add(spawnGate); mapProps.push(spawnGate);


            // --- 2. PLAYER BASE (Fortified Command Center) ---
            const bunker = new THREE.Group();

            // Main Building (Wider, more detailed)
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(10, 6, 10),
                matDark
            );
            mainBuilding.position.y = 3;
            bunker.add(mainBuilding);
            
            // Reinforced corners
            for(let i = 0; i < 4; i++) {
                const x = (i % 2) ? 5 : -5;
                const z = (i < 2) ? 5 : -5;
                const pillar = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 7, 1.2),
                    matMetal
                );
                pillar.position.set(x, 3.5, z);
                bunker.add(pillar);
            }

            // Roof Dome (Larger, more detailed)
            const domeLower = new THREE.Mesh(
                new THREE.CylinderGeometry(4.5, 5, 1.2, 12),
                matMetal
            );
            domeLower.position.y = 6.6;
            bunker.add(domeLower);
            
            const domeUpper = new THREE.Mesh(
                new THREE.SphereGeometry(3.5, 12, 8, 0, Math.PI*2, 0, Math.PI/2),
                matMetal
            );
            domeUpper.position.y = 7.3;
            bunker.add(domeUpper);

            // Multiple Antennas
            const antennaPositions = [[3, 9, -3], [-3, 9, -3], [0, 10, 0]];
            antennaPositions.forEach(pos => {
                const ant = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, pos[1] === 10 ? 2.5 : 2),
                    new THREE.MeshStandardMaterial({color:0xffffff, metalness:0.9})
                );
                ant.position.set(...pos);
                bunker.add(ant);
                
                // Antenna tip (red light)
                const tip = new THREE.Mesh(
                    new THREE.SphereGeometry(0.15),
                    new THREE.MeshBasicMaterial({color:0xff0000})
                );
                tip.position.set(pos[0], pos[1] + 1, pos[2]);
                bunker.add(tip);
            });

            // Entrance Gate (Massive)
            const gateFrame = new THREE.Mesh(
                new THREE.BoxGeometry(5, 4.5, 1.5),
                matBaseColor
            );
            gateFrame.position.set(0, 2.25, 5.2);
            bunker.add(gateFrame);

            // Gate doorway (black)
            const doorway = new THREE.Mesh(
                new THREE.BoxGeometry(3.5, 3.5, 0.5),
                matBlack
            );
            doorway.position.set(0, 1.75, 5.5);
            bunker.add(doorway);
            
            // Warning stripes on gate
            for(let i = 0; i < 6; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 4.4, 1.52),
                    new THREE.MeshStandardMaterial({
                        color: i % 2 === 0 ? 0xffff00 : 0x000000
                    })
                );
                stripe.position.set(-2.5 + i * 1, 2.25, 5.2);
                bunker.add(stripe);
            }

            // Defensive turret platforms (2 on roof)
            for(let side = -1; side <= 1; side += 2) {
                const turretBase = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.8, 1, 0.5, 8),
                    matMetal
                );
                turretBase.position.set(side * 3.5, 7.3, 2);
                bunker.add(turretBase);
                
                const turretBarrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.3, 1.5, 8),
                    matDark
                );
                turretBarrel.rotation.x = Math.PI/2;
                turretBarrel.position.set(side * 3.5, 7.6, 1);
                bunker.add(turretBarrel);
            }

            // ALIGNMENT LOGIC:
            bunker.position.copy(endPos).add(endDir.clone().multiplyScalar(4));
            bunker.lookAt(endPos); 

            scene.add(bunker); mapProps.push(bunker);
            
            // Labels
            createLabel("PORTAL", spawnGate.position.clone().add(new THREE.Vector3(0,8,0)), "#2ecc71");
            createLabel("BASE", bunker.position.clone().add(new THREE.Vector3(0,10,0)), "#e74c3c");
        }

        function createLabel(text, pos, col) {
            const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
            canvas.width=256; canvas.height=64; ctx.font="Bold 40px Arial"; ctx.fillStyle=col; ctx.textAlign="center"; ctx.strokeStyle="black"; ctx.lineWidth=4;
            ctx.strokeText(text,128,48); ctx.fillText(text,128,48);
            const s = new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(canvas), transparent:true}));
            s.position.copy(pos); s.scale.set(12,3,1); scene.add(s); mapProps.push(s);
        }

	function getMuzzlePosition(tower) {
            // How high up is the gun?
            let yOffset = 2.5; 
            // How far forward is the barrel tip?
            let forwardOffset = 2.0; 

            if(tower.type === 'sniper') { yOffset = 3.5; forwardOffset = 5.5; }
            else if(tower.type === 'minigun') { yOffset = 2.5; forwardOffset = 3.5; }
            else if(tower.type === 'gunner') { yOffset = 2.0; forwardOffset = 2.2; }
            else if(tower.type === 'cannon') { yOffset = 2.5; forwardOffset = 2.5; }
            else if(tower.type === 'flamethrower') { yOffset = 2.5; forwardOffset = 2.5; }
            else if(tower.type === 'laser') { yOffset = 2.0; forwardOffset = 1.8; }
            else if(tower.type === 'mortar') { yOffset = 3.5; forwardOffset = 0.5; } // Fires slightly up
            else if(tower.type === 'tesla') { yOffset = 5.0; forwardOffset = 0; }
            else if(tower.type === 'plasma') { yOffset = 4.0; forwardOffset = 0; }
            
            // Calculate the position based on rotation
            const rot = tower.mesh.children[1].rotation.y;
            const offset = new THREE.Vector3(0, 0, forwardOffset);
            offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rot);
            
            return tower.mesh.position.clone().add(new THREE.Vector3(0, yOffset, 0)).add(offset);
        }
	
	    function runEnemyAbilities(e, dt) {
            if(!e.abilityType) return;
            e.abilityCooldown -= dt;
            if(e.abilityCooldown > 0) return;

            // --- HEALER (Area Heal) ---
            if(e.abilityType === 'heal') {
                e.abilityCooldown = 2.0; 
                
                // 1. Find allies
                enemies.forEach(ally => {
                    if(ally !== e && ally.hp < ally.maxHp && ally.mesh.position.distanceTo(e.mesh.position) < 8) {
                        const healAmount = 20;
                        ally.hp = Math.min(ally.hp + healAmount, ally.maxHp);
                        
                        // 2. VISUAL: Green Popup "+20"
                        createFloatingText("+" + healAmount, ally.mesh.position.clone().add(new THREE.Vector3(0, 3, 0)), "#2ecc71");
                        
                        // 3. VISUAL: Sparkles
                        createParticles(ally.mesh.position, 3, 0x00ff00);

                        // --- FIX: Sync to Client ---
                        if(socket && myRoomId && myRole === 'host') {
                            socket.emit('gameAction', { 
                                type: 'visual_effect', 
                                effect: 'heal_area', 
                                roomId: myRoomId, 
                                x: ally.mesh.position.x, 
                                z: ally.mesh.position.z 
                            });
                        }
                    }
                });
            }

            // --- DISRUPTOR (Stun Towers) ---
            if(e.abilityType === 'stun') {
                e.abilityCooldown = 3.0; 
                towers.forEach(t => {
                    if(t.mesh.position.distanceTo(e.mesh.position) < 6) {
                        t.stunned = 3.0; 
                        createFloatingText("ZAP!", t.mesh.position.clone().add(new THREE.Vector3(0,4,0)), "#3498db");
                        createParticles(t.mesh.position.clone().add(new THREE.Vector3(0,2,0)), 10, 0x00ffff);
                        if(socket && myRoomId && myRole === 'host') {
                            socket.emit('gameAction', { type: 'tower_stun', roomId: myRoomId, tx: t.mesh.position.x, tz: t.mesh.position.z });
                        }
                    }
                });
            }

            // --- SUMMONER (Spawn Minions) ---
            if(e.abilityType === 'summon') {
                e.abilityCooldown = 4.0;
                spawnMinion(e.pathIdx, e.mesh.position);
            }
        }

function spawnMinion(pathIdx, pos) {
    // Local Spawn
    const id = Date.now() + Math.random();
    spawnEnemy('red', id); 
    // Hack: Move the just-spawned enemy to the Summoner's location
    const minion = enemies[enemies.length-1];
    minion.pathIdx = pathIdx;
    minion.mesh.position.copy(pos);

    // Network Spawn
    if(socket && myRoomId && myRole === 'host') {
        socket.emit('gameAction', { 
            type: 'spawn_minion', 
            roomId: myRoomId, 
            key: 'red', 
            id: id, 
            idx: pathIdx, 
            x: pos.x, z: pos.z 
        });
    }
}
	
        // --- GAME LOOP ---
        // =====================================================
        // PERFORMANCE MONITORING FUNCTIONS
        // =====================================================

        function updateFPS() {
            fpsCounter.frames++;
            const currentTime = performance.now();
            const delta = currentTime - fpsCounter.lastTime;
            
            if (delta >= 1000) {
                fpsCounter.fps = Math.round((fpsCounter.frames * 1000) / delta);
                fpsCounter.frames = 0;
                fpsCounter.lastTime = currentTime;
                
                const fpsEl = document.getElementById('fps-counter');
                if (fpsEl) {
                    // Respect user's FPS counter setting
                    if (showFPSCounter) {
                        fpsEl.style.display = 'block';
                        fpsEl.textContent = `FPS: ${fpsCounter.fps}`;
                        
                        // Color code based on performance
                        if (fpsCounter.fps < 30) {
                            fpsEl.className = 'perf-stat critical';
                        } else if (fpsCounter.fps < 50) {
                            fpsEl.className = 'perf-stat warning';
                        } else {
                            fpsEl.className = 'perf-stat';
                        }
                    } else {
                        fpsEl.style.display = 'none';
                    }
                }
            }
        }

        function updatePing(latency) {
            pingMonitor.samples.push(latency);
            if (pingMonitor.samples.length > 10) pingMonitor.samples.shift();
            
            const avgPing = Math.round(pingMonitor.samples.reduce((a, b) => a + b, 0) / pingMonitor.samples.length);
            pingMonitor.lastPing = avgPing;
            
            const pingEl = document.getElementById('ping-counter');
            if (pingEl) {
                pingEl.textContent = `PING: ${avgPing}ms`;
                pingEl.style.display = 'inline-block';
                
                if (avgPing > 200) {
                    pingEl.className = 'perf-stat critical';
                } else if (avgPing > 100) {
                    pingEl.className = 'perf-stat warning';
                } else {
                    pingEl.className = 'perf-stat';
                }
            }
        }

        function updateHostPing(latency) {
            hostPing = latency;
            const hostPingEl = document.getElementById('host-ping-counter');
            if (hostPingEl) {
                hostPingEl.textContent = `HOST: ${latency}ms`;
                hostPingEl.style.display = 'inline-block';
                
                const lagWarning = document.getElementById('lag-warning');
                if (latency > 200) {
                    hostPingEl.className = 'perf-stat critical';
                    if (lagWarning) lagWarning.style.display = 'block';
                } else if (latency > 100) {
                    hostPingEl.className = 'perf-stat warning';
                    if (lagWarning) lagWarning.style.display = 'none';
                } else {
                    hostPingEl.className = 'perf-stat';
                    if (lagWarning) lagWarning.style.display = 'none';
                }
            }
        }

        function setServerLocation(location) {
            serverLocation = location;
            const locEl = document.getElementById('server-location');
            if (locEl) {
                locEl.textContent = `📍 ${location}`;
                locEl.style.display = 'inline-block';
            }
        }

        function showPerformanceStats() {
            const statsDiv = document.getElementById('performance-stats');
            if (statsDiv) statsDiv.style.display = 'flex';
        }

        function hidePerformanceStats() {
            const statsDiv = document.getElementById('performance-stats');
            if (statsDiv) statsDiv.style.display = 'none';
        }

        function closeMpWarning() {
            const modal = document.getElementById('mp-warning-modal');
            if (modal) modal.style.display = 'none';
            mpWarningShown = true;
            // Show the name menu after dismissing warning
            document.getElementById('mp-name-menu').style.display = 'flex';
        }

        function animate() {
            requestAnimationFrame(animate);
    		const dt = 0.016;
            
            // Update FPS Counter
            updateFPS();
		
		// --- PREVIEW RENDER (Only when almanac is open) ---
		if(isPreviewing && previewModel && document.getElementById('almanac-menu').style.display !== 'none') {
                previewModel.rotation.y += 0.01;
                previewRenderer.render(previewScene, previewCam);
            	}
		
    		// 1. MENU MODE: If game isn't running, just spin the camera and render
    		if (!gameRunning) {
                const time = Date.now() * 0.0002;
                camera.position.x = Math.cos(time) * 100;
                camera.position.z = Math.sin(time) * 100;
                camera.position.y = 80;
                camera.lookAt(0, 0, 0);

                // Render and exit (don't run game logic)
                if(composer) composer.render();
                else renderer.render(scene, camera);
                return;
            	}

    		if (isPaused) {
                // OPTIMIZATION: Still render the scene when paused, but skip all game logic
                if(graphicsMode === 2 && composer) composer.render();
                else renderer.render(scene, camera);
                return;
            }

            // --- CAMERA SHAKE (only when active) ---
            let shakeOffset = new THREE.Vector3();
            if(shakeEnabled && shakeIntensity > 0) {
                const power = shakeIntensity * 10;
                shakeOffset.set(
                    (Math.random() - 0.5) * power,
                    (Math.random() - 0.5) * power * 0.5,
                    (Math.random() - 0.5) * power
                );
                camera.position.add(shakeOffset);
                shakeIntensity -= dt * shakeDecay;
                if(shakeIntensity < 0) shakeIntensity = 0;
            }

            // --- MASTER LOGIC (Runs for Single Player OR Host) ---
            if (!socket || myRole === 'host') {
                
                // OPTIMIZATION: Track if UI needs updating (instead of calling every frame)
                let needsUIUpdate = false;
                
                // 1. Enemies Movement & Lives
                for(let i=enemies.length-1; i>=0; i--) {
                    const e = enemies[i];

		    if (!socket || myRole === 'host') {
                        runEnemyAbilities(e, dt);
                    }

                    if(e.stunned > 0) {
                        e.stunned -= dt;
                        
                        // Simple ice effect when stunned
                        if(!e.iceEffect && e.mesh.material) {
                            e.originalColor = e.mesh.material.color.getHex();
                            e.mesh.material.color.setHex(0x88ddff); // Light blue tint
                            e.iceEffect = true;
                        }
                    } else {
                        // Remove ice tint when not stunned
                        if(e.iceEffect && e.mesh.material && e.originalColor) {
                            e.mesh.material.color.setHex(e.originalColor);
                            e.iceEffect = false;
                        }
                        
                        // SAFETY CHECK: Ensure pathIdx is valid
                        if(e.pathIdx >= currentWaypoints.length) {
                            // Enemy reached end, remove it
                            lives--;
                            addTrauma(0.5);
                            AudioSys.lifeLoss();
                            scene.remove(e.mesh); 
                            if(e.hpGroup) scene.remove(e.hpGroup);
                            enemies.splice(i,1);
                            needsUIUpdate = true;
                            if(lives<=0) { 
                                isPaused = true;
                                gameRunning = false;
                                notifyGameplayStop();
                                document.getElementById('final-wave-loss').innerText = wave; 
                                document.getElementById('game-over-screen').style.display='flex'; 
                                if(socket && myRoomId) {
                                    socket.emit('gameStateUpdate', { roomId: myRoomId, state: 'loss', finalWave: wave });
                                }
                            }
                            continue;
                        }
                        
                        const target = currentWaypoints[e.pathIdx];
                        // OPTIMIZATION: Cache position and calculate distance squared (faster)
                        const dx = target.x - e.mesh.position.x;
                        const dz = target.z - e.mesh.position.z;
                        const distSq = dx * dx + dz * dz;
                        const dist = Math.sqrt(distSq);
                        let s = e.speed;
                        if(e.slowTime > 0) { s *= 0.5; e.slowTime -= dt; }
                        // OPTIMIZATION: Reuse dx/dz for direction calculation
                        const invDist = dist > 0 ? 1 / dist : 0;
                        e.mesh.position.x += dx * invDist * s;
                        e.mesh.position.z += dz * invDist * s;
                        // OPTIMIZATION: Only update lookAt if enemy moved significantly
                        if(distSq > 0.01) {
                            const lookTarget = target.clone(); lookTarget.y = e.mesh.position.y;
                            e.mesh.lookAt(lookTarget);
                        }
                        
                        if(distSq < 1) { // Use squared distance for comparison (faster)
                            e.pathIdx++;
                            if(e.pathIdx >= currentWaypoints.length) {
                                lives--;
				addTrauma(0.5);
                                AudioSys.lifeLoss(); // Life loss alarm sound
                                scene.remove(e.mesh); scene.remove(e.hpGroup);
                                enemies.splice(i,1);
                                needsUIUpdate = true; // OPTIMIZATION: Mark UI for update
                                if(lives<=0) { 
                                    isPaused = true;
                                    gameRunning = false;
                                    
                                    // Notify CrazyGames that gameplay stopped
                                    notifyGameplayStop();
                                    
				    document.getElementById('final-wave-loss').innerText = wave; 
                                    document.getElementById('game-over-screen').style.display='flex'; 
                                    if(socket && myRoomId) {
                                        socket.emit('gameStateUpdate', { roomId: myRoomId, state: 'loss', finalWave: wave });
                                    }
                                }
                                continue;
                            }
                        }
                    }
                    
                    // BURNING EFFECT (DoT from flamethrower)
                    if(e.burning) {
                        e.burning.duration -= dt;
                        e.burning.nextTick -= dt;
                        
                        if(e.burning.nextTick <= 0) {
                            // Apply burn damage
                            e.hp -= e.burning.damage;
                            e.burning.nextTick = e.burning.tickRate;
                            
                            // Spawn fire particles
                            const firePos = e.mesh.position.clone();
                            firePos.y += 1;
                            const fireParticle = new THREE.Mesh(
                                new THREE.SphereGeometry(0.4, 6, 6),
                                new THREE.MeshBasicMaterial({color: 0xff4500})
                            );
                            fireParticle.position.copy(firePos);
                            scene.add(fireParticle);
                            particles.push({
                                mesh: fireParticle,
                                vel: new THREE.Vector3((Math.random()-0.5), 3, (Math.random()-0.5)),
                                life: 0.4,
                                maxLife: 0.4
                            });
                            
                            // Update HP bar
                            if(e.fg) {
                                const hpRatio = Math.max(0, e.hp / e.maxHp);
                                e.fg.scale.x = hpRatio;
                                if(hpRatio > 0.5) e.fg.material.color.setHex(0x00ff00);
                                else if(hpRatio > 0.2) e.fg.material.color.setHex(0xffaa00);
                                else e.fg.material.color.setHex(0xff0000);
                            }
                            
                            // Check if enemy died from burn
                            if(e.hp <= 0) {

				if(e.burning && e.burning.source) {
        			    e.burning.source.destroys++;
    				}

                                gold += e.score;
                                needsUIUpdate = true;
                                scene.remove(e.mesh);
                                scene.remove(e.hpGroup);
                                
                                // Achievement & XP tracking
                                trackKill();
                                trackGoldEarned(e.score);
                                if (typeof window.addXP === 'function') window.addXP(5);
                                if (typeof window.trackEnemyDestroyed === 'function') window.trackEnemyDestroyed(e.score);
                                
                                // Explosion
                                createExplosion(e.mesh.position, e.mesh.userData.mainColor || 0xff6600, 3);
                                AudioSys.explosion();
                                
                                
                                // Achievement & XP tracking
                                trackKill();
                                if (typeof window.addXP === 'function') window.addXP(5);
                                if (typeof window.trackEnemyDestroyed === 'function') window.trackEnemyDestroyed(0);
                                
                                enemies.splice(i, 1);
                                continue;
                            }
                        }
                        
                        // Remove burn when duration expires
                        if(e.burning.duration <= 0) {
                            delete e.burning;
                            // Remove fire glow
                            if(e.mesh) {
                                e.mesh.traverse(child => {
                                    if(child.isMesh && child.material && child.material.emissive) {
                                        child.material.emissive.setHex(0x000000);
                                        child.material.emissiveIntensity = 0;
                                    }
                                });
                            }
                        }
                    }
                    
                    // OPTIMIZATION: Only update HP bar if health bars are enabled
                    if(healthBarsEnabled && e.hpGroup) { 
                        e.hpGroup.position.copy(e.mesh.position); 
                        e.hpGroup.position.y += e.hpHeight; 
                        e.hpGroup.quaternion.copy(camera.quaternion); 
                    } else if(e.hpGroup) {
                        e.hpGroup.visible = false;
                    }
                }

                // 2. Wave Sync & Auto Start
                if(enemies.length === 0 && spawningFinished && activeWave) {
                    activeWave = false;
                    
                    // Achievement tracking
                    trackWaveComplete();
                    if (typeof window.trackWaveCompleted === 'function') {
                        window.trackWaveCompleted(wave);
                    }
                    if(socket && myRoomId) socket.emit('gameAction', { type: 'wave_finished', roomId: myRoomId, wave: wave });
                    
                    // HAPPY TIME: Trigger on boss waves (every 10 waves)
                    if (wave % 10 === 0) {
                        triggerHappyTime();
                    }
                    
                    if(wave >= GAME_CONFIG.maxWaves) { 
                        isPaused = true;
                        gameRunning = false;
                        
                        // Notify CrazyGames that gameplay stopped
                        notifyGameplayStop();
                        
                        // HAPPY TIME: Victory!
                        triggerHappyTime();
                        
                        // Track victory in lifetime stats
                        if(typeof lifetimeStats !== 'undefined') {
                            lifetimeStats.gamesWon++;
                            if(typeof saveProgression === 'function') saveProgression();
                            if(typeof checkAchievements === 'function') checkAchievements();
                        }
                        
                        // ✅ CRITICAL: Track game won for special achievements
                        if (typeof window.trackGameWon === 'function') {
                            const finalLives = lives;
                            const totalTowers = towers.length;
                            window.trackGameWon(finalLives, totalTowers);
                        }
                        
                        document.getElementById('victory-screen').style.display='flex';
                        
                        if(socket && myRoomId) {
                            socket.emit('gameStateUpdate', { roomId: myRoomId, state: 'win' });
                        }
                    } else {
                        const btn = document.getElementById('btn-start-wave');
                        btn.disabled = false;
                        if (autoWave && !isPaused && gameRunning && wave > 0) {
                            btn.innerText = "AUTO STARTING...";
                            btn.style.backgroundColor = "#555";
                            setTimeout(() => { if(!activeWave && gameRunning && !isPaused) startWave(); }, 1500);
                        } else {
                            btn.innerText = "START WAVE";
                            btn.style.backgroundColor = ""; 
                        }
                    }
                }

                // 3. Towers Combat
                towers.forEach(t => {
                    // --- STUNNED LOGIC ---
                    if(t.stunned > 0) {
                        t.stunned -= dt;
                        
                        // OPTIMIZATION: Reduced spark frequency
                        if(Math.random() < 0.08) { // 8% instead of 15%
                            const sparkPos = t.mesh.position.clone().add(new THREE.Vector3(
                                (Math.random()-0.5)*2, 
                                Math.random()*3, 
                                (Math.random()-0.5)*2
                            ));
                            createParticles(sparkPos, 1, 0x00ffff); 
                        }
                        return;
                    }
                    
                    // OPTIMIZATION: Cache tower position (it never changes!)
                    const tPos = t.mesh.position;
                    
                    // Tower tracking (only for towers that need it)
                    if(t.type !== 'farm' && ['gunner','sniper','minigun','cannon','mortar','laser','flamethrower'].includes(t.type)) {
                        const target = enemies.find(e => e.mesh.position.distanceTo(tPos) <= t.range);
                        if(target) {
                            const dx = target.mesh.position.x - tPos.x;
                            const dz = target.mesh.position.z - tPos.z;
                            const angle = Math.atan2(dx, dz);
                            t.mesh.children[1].rotation.y = angle;
                            t.currentRotY = angle; 
                        }
                    }

		    if(t.type === 'plasma' || t.type === 'ice') {
                        if(t.mesh.children[1]) {
                             t.mesh.children[1].rotation.y += dt;
                             t.currentRotY = t.mesh.children[1].rotation.y; // <--- ADD THIS (Saves spin for Sync)
                        }
                    }
                    // 2. Tracking Animations (Client Side Smoothing)
                    if(myRole !== 'host' && t.currentRotY !== undefined && t.mesh.children[1]) {
                    // Smoothly lerp to the rotation sent by server
                    t.mesh.children[1].rotation.y += (t.currentRotY - t.mesh.children[1].rotation.y) * 0.1;
                    }

                    if(t.type === 'farm') {
                         if(activeWave) {
                             t.cooldown -= dt;
                             if(t.cooldown <= 0) {
                                 t.cooldown = t.rate;
                                 
                                 // --- FIX: USE NEW WALLET SYSTEM ---
                                 if(currentGamemode === 'shared') {
                                     gold += t.income; trackGoldEarned(t.income);;
                                 } else {
                                     const ownerIdx = (typeof t.ownerIndex === 'number') ? t.ownerIndex : 0;
                                     playerWallets[ownerIdx] += t.income;
                                     if(ownerIdx === myPlayerIndex) gold = playerWallets[myPlayerIndex];
                                 }
                                 
                                 t.totalGenerated = (t.totalGenerated || 0) + t.income;

                                 needsUIUpdate = true; // OPTIMIZATION: Mark UI for update
                                 AudioSys.shoot('farm');
                                 createFloatingText("+$"+t.income, t.mesh.position.clone().add(new THREE.Vector3(0, 6, 0)), "#2ecc71");

                                 if(socket && myRole === 'host') {
                                     socket.emit('gameAction', { 
                                         type: 'visual_effect', effect: 'farm_text', roomId: myRoomId, 
                                         x: t.mesh.position.x, z: t.mesh.position.z, value: t.income 
                                     });
                                     
                                     // FIX: Sync wallet update in separate mode
                                     if(currentGamemode === 'separate') {
                                         socket.emit('gameAction', { 
                                             type: 'wallet_update', 
                                             roomId: myRoomId, 
                                             wallets: playerWallets,
                                             gold: gold,
                                             mode: currentGamemode
                                         });
                                     }
                                 }
                             }
                         }
                         return;
                    }

                    t.cooldown -= dt;
                    if(t.cooldown <= 0) {
                        // OPTIMIZATION: Tower position is cached in tPos above
                        // MORTAR FIX: Find target OUTSIDE minimum range
                        let target;
                        if(t.type === 'mortar' && t.minRange) {
                            target = enemies.find(e => {
                                const dist = e.mesh.position.distanceTo(tPos);
                                return dist >= t.minRange && dist <= t.range;
                            });
                        } else {
                            target = enemies.find(e => e.mesh.position.distanceTo(tPos) <= t.range);
                        }
                        
                        if(target) {
                            t.cooldown = t.rate;
                            
			    // --- SPECIAL ABILITIES ---
                            if (t.special === 'multi_target') {
                                // LASER SPLITTER: Find 2 other enemies
                                let extras = 0;
                                enemies.forEach(e2 => {
                                    if(extras < 2 && e2 !== target && e2.mesh.position.distanceTo(t.mesh.position) <= t.range) {
                                        // Draw extra beam
                                        const beam = new THREE.Line(new THREE.BufferGeometry().setFromPoints([muzzlePos, e2.mesh.position]), new THREE.LineBasicMaterial({color: t.color}));
                                        scene.add(beam); setTimeout(()=>scene.remove(beam), 50);
                                        damageEnemy(e2, t.dmg, 0, 0);
                                        extras++;
                                    }
                                });
                            }
                            
                            if (t.special === 'black_hole') {
                                // PLASMA BLACK HOLE: Suck enemies in? Or just massive slow
                                damageEnemy(target, t.dmg, t.splash, 0.9); // 90% Slow!
                            }

                            if (t.special === 'stun_boss') {
                                // SNIPER CRIPPLE: Stun bosses specifically
                                if(target.maxHp > 2000) { // Rough check for boss
                                    target.stunned = 0.5; // Mini-stun
                                }
                            }

                            // 1. Get Exact Barrel Tip Position
                            const muzzlePos = getMuzzlePosition(t);

                            // --- HITSCAN WEAPONS ---
                            if(t.type === 'tesla') {
                                createMuzzleFlash(muzzlePos, 0x5dade2);
                                AudioSys.shoot('tesla'); // Fixed sound name
                                
                                let chainTargets = [target]; let curr = target;
                                // Calculate full chain
                                for(let k=0; k < t.chain - 1; k++) {
                                    let next = null; let minDist = t.jump || 6;
                                    enemies.forEach(e => {
                                        if(!chainTargets.includes(e)) {
                                            const d = e.mesh.position.distanceTo(curr.mesh.position);
                                            if(d < minDist) { minDist = d; next = e; }
                                        }
                                    });
                                    if(next) { chainTargets.push(next); curr = next; } else { break; }
                                }

                                // Draw & Damage
                                let prevPos = muzzlePos; 
                                const syncPoints = [ {x: muzzlePos.x, y: muzzlePos.y, z: muzzlePos.z} ]; // Store points for MP

                                chainTargets.forEach(e => {
                                    damageEnemy(e, t.dmg, 0, 0, 0, t);
                                    createImpact(e.mesh.position, 0x5dade2, 3);
                                    
                                    // Visuals
                                    const bolt = new THREE.Line(
                                        new THREE.BufferGeometry().setFromPoints([prevPos, e.mesh.position]), 
                                        new THREE.LineBasicMaterial({ color: 0x5dade2 })
                                    );
                                    scene.add(bolt); setTimeout(() => scene.remove(bolt), 80);
                                    
                                    prevPos = e.mesh.position;
                                    syncPoints.push({ x: e.mesh.position.x, y: e.mesh.position.y, z: e.mesh.position.z });
                                });

                                // --- FIX: Send Full Chain to Client ---
                                if(socket && myRole === 'host') {
                                    socket.emit('gameAction', { 
                                        type: 'visual_effect', 
                                        effect: 'tesla_chain', 
                                        roomId: myRoomId, 
                                        points: syncPoints 
                                    });
                                }
                            }
                            else if(t.type==='laser') {
                                createMuzzleFlash(muzzlePos, 0xe74c3c);
                                AudioSys.shoot('laser');
                                const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([muzzlePos, target.mesh.position]), new THREE.LineBasicMaterial({color: 0xe74c3c}));
                                scene.add(line); setTimeout(()=>scene.remove(line), 50);
                                damageEnemy(target, t.dmg, 0, 0, 0, t);
                                createImpact(target.mesh.position, 0xe74c3c, 2);
                            }
                            else if (t.type==='ice') {
                                 AudioSys.shoot('ice');
                                 // VISUAL FIX: Specific Frost Ring so you see it working
                                 const ring = new THREE.Mesh(new THREE.RingGeometry(0.5, t.range, 32), new THREE.MeshBasicMaterial({color:0xaaddff, transparent:true, opacity:0.5, side:THREE.DoubleSide}));
                                 ring.rotation.x = -Math.PI/2; ring.position.copy(t.mesh.position).add(new THREE.Vector3(0,0.5,0));
                                 scene.add(ring);
                                 particles.push({ mesh:ring, life:0.3, type:'expand_fade' });

                                 enemies.forEach(e => {
                                     if(e.mesh.position.distanceTo(t.mesh.position) <= t.range) {
                                         damageEnemy(e, t.dmg, 0, t.slow, Math.random() < t.stunChance ? t.stunDur : 0, t);
                                     }
                                 });
                            } 
                            // --- PROJECTILES (Balls) ---
                            else {
                AudioSys.shoot(t.type);
                createMuzzleFlash(muzzlePos, t.color);
                
                let pMesh;
                let isArc = false;
                let velocity = null;
                let gravity = 0;

                if(t.type === 'mortar') {
                    // 1. VISUALS: Big Shell
                    const shellGroup = new THREE.Group();
                    const body = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.25, 0.25, 1.2, 8),
                        new THREE.MeshStandardMaterial({ color: 0x3a3a3a, metalness: 0.7 })
                    );
                    body.rotation.x = Math.PI / 2;
                    const tip = new THREE.Mesh(
                        new THREE.ConeGeometry(0.25, 0.4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x2a2a2a, metalness: 0.8 })
                    );
                    tip.rotation.x = Math.PI / 2;
                    tip.position.z = 0.8;
                    shellGroup.add(body, tip);
                    pMesh = shellGroup;
                    pMesh.scale.set(1.5, 1.5, 1.5);
                    
                    // 2. ARC-BASED MOVEMENT
                    // No prediction needed - projectile tracks enemy during flight!
                    scene.add(pMesh);
                    pMesh.position.copy(muzzlePos);
                    
                    projectiles.push({
                        mesh: pMesh,
                        target: target, // Projectile will track this target's position every frame
                        dmg: t.dmg,
                        splash: t.splash || 0,
                        slow: t.slow || 0,
                        type: 'mortar',
                        start: muzzlePos.clone(),
                        // No targetPos needed - tracks enemy's current position every frame!
                        progress: 0,
                        speed: 0.015, // Slow floaty mortar
                        arcHeight: 18, // High arc
                        source: t
                    });
                    
                    return; // Skip normal projectile creation (forEach uses return, not continue)

                } else if(t.type === 'cannon') {
                    // CANNON: Normal straight projectile with splash damage (no arc)
                    
                    // 1. VISUALS: Iron Ball
                    pMesh = new THREE.Mesh(
                        new THREE.SphereGeometry(0.5, 12, 12),
                        new THREE.MeshStandardMaterial({ color: 0x2c2c2c, metalness: 0.9 })
                    );
                    
                    // 2. STANDARD PROJECTILE (Not arc-based, shoots straight like other towers)
                    scene.add(pMesh);
                    pMesh.position.copy(muzzlePos);
                    
                    projectiles.push({
                        mesh: pMesh,
                        target: target,
                        dmg: t.dmg, // FIX: Use t.dmg instead of t.damage
                        splash: t.splash || 0, // Has splash damage
                        slow: t.slow || 0,
                        type: 'cannon', // Still labeled as cannon for explosion visuals
                        source: t
                    });
                    
                    return; // Skip the else block projectile creation
                }
                                else if(t.type === 'flamethrower') {
                                    // FLAMETHROWER: Continuous fire stream (no projectile, instant hit with DoT)
                                    
                                    
                                    // Fire particles along stream
                                    for(let i = 0; i < 25; i++) { 
        // Randomize position slightly around the path for a "spray" effect
        const randomOffset = Math.random(); 
        const particlePos = new THREE.Vector3().lerpVectors(muzzlePos, target.mesh.position, randomOffset);
        
        // Add spread to the spray
        particlePos.x += (Math.random() - 0.5) * 1.5;
        particlePos.z += (Math.random() - 0.5) * 1.5;
        particlePos.y += (Math.random() - 0.5) * 1.5;

        const fireParticle = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 4, 4), // Low poly sphere for performance
            new THREE.MeshBasicMaterial({color: Math.random() > 0.5 ? 0xff4500 : 0xffaa00})
        );
        fireParticle.position.copy(particlePos);
        scene.add(fireParticle);

        // Particles float up and fade
        particles.push({ 
            mesh: fireParticle, 
            vel: new THREE.Vector3((Math.random()-0.5)*0.5, 0.5, (Math.random()-0.5)*0.5), 
            life: 0.3, 
            maxLife: 0.3 
        });
    }
                                    
                                    // Apply initial damage
                                    damageEnemy(target, t.dmg, 0, t.slow || 0, 0, t);
                                    
                                    // Apply BURNING effect (DoT)
                                    if(!target.burning) {
                                        target.burning = {
                                            damage: t.dot || 3,
                                            duration: t.dotDuration || 2.0,
                                            tickRate: 0.5,
                                            nextTick: 0.5,
					    source: t
                                        };
                                        
                                        // Visual: Set enemy on fire
                                        if(target.mesh) {
                                            target.mesh.traverse(child => {
                                                if(child.isMesh && child.material && child.material.emissive) {
                                                    child.material.emissive.setHex(0xff4500);
                                                    child.material.emissiveIntensity = 0.6;
                                                }
                                            });
                                        }
                                    } else {
                                        // Refresh burn duration
                                        target.burning.duration = Math.max(target.burning.duration, t.dotDuration || 2.0);
                                        target.burning.damage = Math.max(target.burning.damage, t.dot || 3);
                                    }
                                    
                                    AudioSys.shoot('flamethrower');
                                    
                                    // Flamethrower doesn't create projectiles - it's instant hit
                                    // Skip the projectile creation below by not setting pMesh
                                    pMesh = null;
                                }
                                else {
                                    // STANDARD BULLET (The Orb is Back!)
                                    const size = t.type === 'sniper' ? 0.3 : 0.4;
                                    pMesh = new THREE.Mesh(new THREE.SphereGeometry(size), new THREE.MeshBasicMaterial({color: t.color}));
                                }

                                // Only create projectile if pMesh was set (not flamethrower)
                                if(pMesh) {
                                    pMesh.position.copy(muzzlePos);
                                    scene.add(pMesh);
                                    
                                    projectiles.push({ 
                                        mesh: pMesh, 
                                        target: target, 
                                        dmg: t.dmg, 
                                        splash: t.splash, 
                                        slow: t.slow,
                                        stunChance: t.stunChance || 0,
                                        stunDur: t.stunDur || 0,
                                        color: t.color,
                                        type: t.type,
                                        isArc: isArc,
                                        velocity: velocity,
				        source: t // FIX: Changed from sourceTower to source for consistency
                                    });
                                }
                            }

                            // Multiplayer Sync
                            if(socket && myRole === 'host') {
                                socket.emit('gameAction', { 
                                    type: 'visual_effect', 
                                    effect: 'shoot', 
                                    roomId: myRoomId, 
                                    towerX: t.mesh.position.x, 
                                    towerZ: t.mesh.position.z, 
                                    targetId: target.id,
                                    towerType: t.type,
                                    rotY: t.currentRotY 
                                });
                            }
                        }
                    }
                });

                // 4. BROADCAST MASTER STATE (Original 60 Tick)
            if(socket && myRoomId && myRole === 'host') {
                
                const tSync = towers.map(t => ({
                    x: t.mesh.position.x,
                    z: t.mesh.position.z,
                    rotY: t.currentRotY || 0,
                    type: t.type,
                    level: t.level,
                    branch: t.branch,
                    owner: t.ownerRole,
                    destroys: t.destroys
                }));
                
                const eSync = enemies.map(e => ({
                    id: e.id,
                    type: e.type,
                    x: e.mesh.position.x,
                    z: e.mesh.position.z,
                    hp: e.hp,
                    maxHp: e.maxHp,
		    rot: e.mesh.rotation.y,
                    freeze: e.freezeTimer > 0,
                    slow: e.slowTimer > 0
                }));

                socket.emit('gameAction', { 
                    type: 'master_sync', 
                    roomId: myRoomId, 
                    towers: tSync, 
                    enemies: eSync, 
                    lives: lives, 
                    wave: wave,
                    gold: gold,
                    wallets: playerWallets,
                    mode: currentGamemode,
                    hostFPS: fpsCounter.fps  // Include host FPS for performance monitoring
                });
            }
            
            // OPTIMIZATION: Only update UI when needed
            if(needsUIUpdate) updateUI();
	}
            // --- UNIVERSAL VISUALS (Runs on all clients) ---
            for(let i=projectiles.length-1; i>=0; i--) {
        const p = projectiles[i];
        
        // Remove if target is dead/gone
        if(!p.target || !p.target.mesh.parent) {
            scene.remove(p.mesh);
            projectiles.splice(i,1);
            continue;
        }

        // LERP-BASED ARC MOVEMENT (Mortar ONLY - tracks enemy!)
        if(p.type === 'mortar') {
            // Update progress
            p.progress += p.speed;
            
            // OPTIMIZATION: Cache target position and calculate lerp directly
            const targetPos = p.target.mesh.position;
            const t = p.progress;
            const invT = 1 - t;
            
            // OPTIMIZATION: Direct calculation instead of Vector3.lerpVectors
            p.mesh.position.x = p.start.x * invT + targetPos.x * t;
            p.mesh.position.z = p.start.z * invT + targetPos.z * t;
            p.mesh.position.y = (p.start.y * invT + targetPos.y * t) + Math.sin(t * Math.PI) * p.arcHeight;
            
            // OPTIMIZATION: Only update rotation if not near completion
            if(p.progress < 0.99) {
                const nextT = Math.min(p.progress + 0.01, 1);
                const nextInvT = 1 - nextT;
                const nextX = p.start.x * nextInvT + targetPos.x * nextT;
                const nextY = (p.start.y * nextInvT + targetPos.y * nextT) + Math.sin(nextT * Math.PI) * p.arcHeight;
                const nextZ = p.start.z * nextInvT + targetPos.z * nextT;
                p.mesh.lookAt(new THREE.Vector3(nextX, nextY, nextZ));
            }
            
            // Hit when progress reaches 1.0 (arrived at target)
            if(p.progress >= 1.0) {
                // Damage Logic
                if (!socket || myRole === 'host') {
                    const stunToApply = (p.stunChance && Math.random() < p.stunChance) ? p.stunDur : 0;
                    damageEnemy(p.target, p.dmg, p.splash, p.slow, stunToApply, p.source);
                }

                // Explosion visuals
                if(p.splash > 0) {
                    createExplosion(p.mesh.position, 0xff5500, p.splash);
                    addTrauma(0.8); // Mortar has big explosion
                }

                scene.remove(p.mesh);
                projectiles.splice(i,1);
            }
            continue;
        }

        // OLD ARC PHYSICS (Keep for compatibility, but won't be used by mortar/cannon anymore)
        if(p.isArc && p.velocity) {
            // 1. Apply Gravity (based on calculated gravity per second)
            // We divide by 60 assuming ~60FPS for simple physics step
            p.velocity.y -= p.gravity * dt; 
            
            // 2. SOFT HOMING (The Fix for Missing)
            // OPTIMIZATION: Calculate direction directly without creating new vectors
            const dx = p.target.mesh.position.x - p.mesh.position.x;
            const dz = p.target.mesh.position.z - p.mesh.position.z;
            const distH = Math.sqrt(dx * dx + dz * dz);
            
            // Calculate horizontal speed for rotation check
            const speedH = Math.sqrt(p.velocity.x * p.velocity.x + p.velocity.z * p.velocity.z);
            
            if(distH > 0.01 && speedH > 0.01) {
                // Calculate ideal direction
                const idealX = dx / distH;
                const idealZ = dz / distH;
                
                // Current velocity direction
                const currentX = p.velocity.x / speedH;
                const currentZ = p.velocity.z / speedH;
                
                // Blend current direction with ideal direction (Steer Factor)
                const steer = p.type === 'mortar' ? 0.1 : 0.05;
                const newX = (currentX * (1 - steer) + idealX * steer);
                const newZ = (currentZ * (1 - steer) + idealZ * steer);
                const newLen = Math.sqrt(newX * newX + newZ * newZ);
                
                // Apply new horizontal velocity
                if(newLen > 0.01) {
                    p.velocity.x = (newX / newLen) * speedH;
                    p.velocity.z = (newZ / newLen) * speedH;
                }
            }

            // 3. Move Mesh - OPTIMIZATION: Direct calculation instead of clone
            const moveScale = dt * 60;
            p.mesh.position.x += p.velocity.x * moveScale;
            p.mesh.position.y += p.velocity.y * moveScale;
            p.mesh.position.z += p.velocity.z * moveScale;

            // 4. Rotation (Face flight direction) - OPTIMIZATION: Only if needed
            if(speedH > 0.01) {
                p.mesh.lookAt(new THREE.Vector3(
                    p.mesh.position.x + p.velocity.x,
                    p.mesh.position.y + p.velocity.y,
                    p.mesh.position.z + p.velocity.z
                ));
                if(p.type === 'cannon') p.mesh.rotateX(Math.PI / 2); // Fix cannonball rotation
            }

            // 5. Hit Detection - OPTIMIZATION: Use squared distance
            const targetPos = p.target.mesh.position;
            const hitDx = p.mesh.position.x - targetPos.x;
            const hitDy = p.mesh.position.y - targetPos.y;
            const hitDz = p.mesh.position.z - targetPos.z;
            const hitDistSq = hitDx * hitDx + hitDy * hitDy + hitDz * hitDz;
            // Using a larger hit radius (2.5) for arc weapons to ensure they land
            if(p.mesh.position.y <= targetPos.y + 0.5 || hitDistSq < 6.25) { // 2.5^2 = 6.25
                
                // Damage Logic
                if (!socket || myRole === 'host') {
                    const stunToApply = (p.stunChance && Math.random() < p.stunChance) ? p.stunDur : 0;
                    damageEnemy(p.target, p.dmg, p.splash, p.slow, stunToApply, p.source);
                }

                // Visuals
                if(p.splash > 0) {
                    createExplosion(p.mesh.position, 0xff5500, p.splash);
                    addTrauma(p.type === 'mortar' ? 0.8 : 0.5);
                }

                scene.remove(p.mesh);
                projectiles.splice(i,1);
            }
            continue;
        }

        // STANDARD BULLET MOVEMENT
        // OPTIMIZATION: Calculate direction and distance together
        const dx = p.target.mesh.position.x - p.mesh.position.x;
        const dy = p.target.mesh.position.y - p.mesh.position.y;
        const dz = p.target.mesh.position.z - p.mesh.position.z;
        const distSq = dx * dx + dy * dy + dz * dz;
        const dist = Math.sqrt(distSq);
        const speed = (p.type === 'sniper') ? 80 : 60;
        const moveDist = speed * dt;
        
        // OPTIMIZATION: Only move if not already at target
        if(dist > 0.1) {
            const invDist = 1 / dist;
            p.mesh.position.x += dx * invDist * moveDist;
            p.mesh.position.y += dy * invDist * moveDist;
            p.mesh.position.z += dz * invDist * moveDist;
        }

        if(distSq < 2.25) { // 1.5^2 = 2.25 (use squared distance for comparison)
            // Hit Logic
            if (!socket || myRole === 'host') {
                const stunToApply = (p.stunChance && Math.random() < p.stunChance) ? p.stunDur : 0;
                damageEnemy(p.target, p.dmg, p.splash, p.slow, stunToApply, p.source);
            }
            if(p.splash > 0) createExplosion(p.mesh.position, 0xff5500, p.splash);
            
            scene.remove(p.mesh);
            projectiles.splice(i,1);
        }
    }

            for(let i=particles.length-1; i>=0; i--) {
                const p = particles[i];
                
                // PHYSICS LOGIC (Gravity & Bounce) - OPTIMIZATION: Direct position updates
                if(p.isPhysics) {
                    p.vel.y -= 0.03; // Gravity
                    // OPTIMIZATION: Direct position update instead of Vector3.add
                    p.mesh.position.x += p.vel.x;
                    p.mesh.position.y += p.vel.y;
                    p.mesh.position.z += p.vel.z;
                    p.mesh.rotation.x += p.vel.z; // Spin while flying
                    p.mesh.rotation.z -= p.vel.x;

                    // Floor Bounce
                    if(p.mesh.position.y < 0.25) {
                        p.mesh.position.y = 0.25;
                        p.vel.y *= -0.6; // Bounce with energy loss
                        p.vel.x *= 0.8;  // Friction
                        p.vel.z *= 0.8;
                    }
                } 
                // STANDARD LOGIC (Trails, Text, Explosions) - OPTIMIZATION: Direct position updates
                else {
                    if(p.vel) {
                        p.mesh.position.x += p.vel.x;
                        p.mesh.position.y += p.vel.y;
                        p.mesh.position.z += p.vel.z;
                    }
                }

                p.life -= dt;
                
                // Shrink logic
                if(p.type === 'floating_text') {
                    p.mesh.position.y += dt * 2.0; 
                } else if (!p.isPhysics) { 
                    // Physics particles don't shrink until the very end
                    p.mesh.scale.multiplyScalar(0.9);
                } else if (p.life < 0.5) {
                    p.mesh.scale.multiplyScalar(0.9);
                }

                if(p.life <= 0) { scene.remove(p.mesh); particles.splice(i,1); }
            }
		    
            // --- FINAL RENDER (All visual updates complete) ---
            // Reset camera shake before rendering
            if(shakeEnabled && shakeIntensity > 0) {
                camera.position.sub(shakeOffset);
            }
            
            // Animate atmospheric particles
            if (window.atmosphericParticles && window.particleVelocities && graphicsMode > 0) {
                const positions = window.atmosphericParticles.geometry.attributes.position.array;
                for (let i = 0; i < window.particleVelocities.length; i++) {
                    positions[i * 3] += window.particleVelocities[i].x;
                    positions[i * 3 + 1] += window.particleVelocities[i].y;
                    positions[i * 3 + 2] += window.particleVelocities[i].z;
                    
                    // Wrap around if particle goes too far
                    if (Math.abs(positions[i * 3]) > 100) positions[i * 3] *= -0.9;
                    if (positions[i * 3 + 1] > 100) positions[i * 3 + 1] = 0;
                    if (positions[i * 3 + 1] < 0) positions[i * 3 + 1] = 100;
                    if (Math.abs(positions[i * 3 + 2]) > 100) positions[i * 3 + 2] *= -0.9;
                }
                window.atmosphericParticles.geometry.attributes.position.needsUpdate = true;
            }
            
            // Rotate starfield slowly
            if (window.starfield) {
                window.starfield.rotation.y += 0.0001;
            }
            
            // Choose rendering method based on graphics settings
            if(graphicsMode === 2 && composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // --- SPAWNER ---
        // --- SPAWNER ---
        function spawnEnemy(typeKey, remoteId = null) {
            unlockEnemy(typeKey);
            const def = ENEMIES[typeKey];
            let hpMult = (def.type === 'boss') ? 0.6 : 1.0; 
            
            // --- FIX: Scale HP every 5 waves (Stepped Difficulty) ---
            // Old Logic: (1 + wave * 0.2) -> Multiplier 5.0x at Wave 20
            // New Logic: Updates only at wave 5, 10, 15, etc.
            // Wave 1-4: 1.0x | Wave 5-9: 1.5x | Wave 20: 3.0x
            
            const difficultyStep = Math.floor(wave / 5); 
            const waveScaling = 1 + (difficultyStep * 0.5); // +50% HP every 5 waves
            
            const hp = Math.floor(def.hp * hpMult * waveScaling * GAME_CONFIG.hpMult);
            // --------------------------------------------------------
            
            // 1. Assign ID
            const id = remoteId || (Date.now() + Math.random());

            // 2. Host tells Joiner to spawn the SAME enemy
            if(socket && myRoomId && myRole === 'host' && !remoteId) {
                socket.emit('gameAction', { type: 'spawn', roomId: myRoomId, typeKey, enemyId: id });
            }

            // GEOMETRY VARIATIONS
            // --- NEW MODEL SYSTEM ---
            const mesh = createEnemyModel(typeKey, def.color, def.size);
            mesh.position.copy(currentWaypoints[0]);
            
            // Store the "Main Color" on the group so we can read it later for explosions
            mesh.userData.mainColor = def.color;
            
            scene.add(mesh);
            // ------------------------

            const hpGroup = new THREE.Group();
            const bg = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.3), new THREE.MeshBasicMaterial({color:0x000000}));
            const fg = new THREE.Mesh(new THREE.PlaneGeometry(1.8, 0.2), new THREE.MeshBasicMaterial({color:0x00ff00}));
            fg.position.z = 0.05; fg.geometry.translate(0.9, 0, 0); fg.position.x = -0.9;
            hpGroup.add(bg, fg);
            scene.add(hpGroup);

            enemies.push({ 
                id, mesh, hpGroup, fg, hp, maxHp: hp, speed: def.speed, 
                pathIdx: 1, slowTime: 0, stunned: 0, score: def.score,
                hpHeight: mesh.userData.hpOffset || 2.5,
                abilityCooldown: 0,
                abilityType: def.ability || null
            });
        }

        function triggerFlash(e) {
            if(!e || !e.mesh) return;
            
            // Traverse the group and flash every mesh inside
            e.mesh.traverse(child => {
                if(child.isMesh && child.material && child.material.emissive) {
                    // Save old emissive if you want perfection, but hard-setting is fine for flash
                    child.currentHex = child.material.emissive.getHex();
                    child.material.emissive.setHex(0xffffff);
                }
            });

            setTimeout(()=> { 
                if(e.mesh) {
                    e.mesh.traverse(child => {
                        if(child.isMesh && child.material && child.material.emissive) {
                            child.material.emissive.setHex(0);
                        }
                    });
                }
            }, 50);
        }

        function damageEnemy(e, dmg, splash, slow, stunDuration = 0, sourceTower = null) {
            // Safety check: if enemy is already dead/removed, stop.
            if(!e || e.hp <= 0) return;

            if(splash) {
                // Splash Logic: Hit everything in range
                enemies.forEach(sub => {
                    if(sub.mesh.position.distanceTo(e.mesh.position) < splash) {
                        applyDmg(sub, dmg, slow, stunDuration, sourceTower);
                    }
                });
            } else {
                // Single Target Logic
                applyDmg(e, dmg, slow, stunDuration, sourceTower);
            }
        }

        function applyDmg(e, dmg, slow, stun, sourceTower) {
            if(!e || e.hp <= 0) return; // Stop if already dead

	    if (typeof getSkillMultipliers === 'function') {
        	const mults = getSkillMultipliers();
        	dmg *= mults.damage;
    	    }

            e.hp -= dmg;
            
            // Track damage for daily challenges and stats
            if (typeof sessionStats !== 'undefined') {
                sessionStats.damage += dmg;
            }
            if (typeof lifetimeStats !== 'undefined') {
                lifetimeStats.totalDamage = (lifetimeStats.totalDamage || 0) + dmg;
            }
            
            // 1. Damage Text
            if(dmgTextEnabled && gameRunning && (!socket || myRole === 'host')) {
                const isCrit = dmg > 40;
                createFloatingText("-" + Math.floor(dmg), e.mesh.position, isCrit ? "#e74c3c" : "#fff");
                
                // Sync Text to Clients
                if(socket && myRoomId && myRole === 'host') {
                    socket.emit('gameAction', { 
                        type: 'visual_effect', effect: 'dmg_text', roomId: myRoomId, 
                        x: e.mesh.position.x, z: e.mesh.position.z, val: Math.floor(dmg), crit: isCrit 
                    });
                }
            }
            
            if(slow) e.slowTime = 1.0; 
            if(stun > 0) e.stunned = stun;
            
            triggerFlash(e);

            // Update Health Bar
            if(e.fg) {
                const pct = Math.max(0, e.hp / e.maxHp);
                e.fg.scale.x = pct;
                e.fg.material.color.setHSL(pct * 0.3, 1, 0.5);
            }

            // --- KILL LOGIC ---
            if(e.hp <= 0) {
                // 1. Remove from Scene & Array
                scene.remove(e.mesh); 
                if(e.hpGroup) scene.remove(e.hpGroup);
                enemies = enemies.filter(x => x !== e);
                
		// NEW: Track Destroys
                if (sourceTower) {
                    sourceTower.destroys = (sourceTower.destroys || 0) + 1;
                }
		
		// ✅ CRITICAL: Track enemy destroyed for achievements
                if (typeof window.trackEnemyDestroyed === 'function') {
                    window.trackEnemyDestroyed(e.score || 0);
                }
		
                // 2. SHATTER EFFECT (The Fix)
                createShatter(e.mesh.position, e.mesh.userData.mainColor || 0xff0000, 8);
                AudioSys.shoot('explosion');
                createFloatingText("+$" + e.score, e.mesh.position.clone().add(new THREE.Vector3(0,4,0)), "#f1c40f");

                // 2.5 UPDATE SESSION STATS
                const killStat = document.getElementById('stat-destroys');
                if (killStat) {
                    killStat.innerText = parseInt(killStat.innerText || 0) + 1;
                }

                // 3. INCOME LOGIC (The Fix)
                if(currentGamemode === 'shared') {
                    gold += e.score;
                    
                    // Achievement & XP tracking
                    trackKill();
                    trackGoldEarned(e.score);
                    if (typeof window.addXP === 'function') window.addXP(5);
                    if (typeof window.trackEnemyDestroyed === 'function') window.trackEnemyDestroyed(e.score);
                } else {
                    // Split gold among players
                    const pCount = (allPlayers && allPlayers.length > 0) ? allPlayers.length : 1;
                    const share = Math.floor(e.score / pCount);
                    
                    if(allPlayers.length > 0) {
                        for(let i=0; i<4; i++) {
                            // Add to everyone's wallet
                            if(i < allPlayers.length) playerWallets[i] += share;
                        }
                    } else {
                        // Single Player
                        playerWallets[0] += e.score;
                    }
                    
                    // FORCE UPDATE LOCAL DISPLAY IMMEDIATELY
                    gold = playerWallets[myPlayerIndex];
                }
                
                // FIX: Sync wallets to all players immediately after enemy destroy
                if(socket && myRoomId && myRole === 'host') {
                    socket.emit('gameAction', { 
                        type: 'wallet_update', 
                        roomId: myRoomId, 
                        wallets: playerWallets,
                        gold: gold,
                        mode: currentGamemode
                    });
                }
                
                // 4. Cleanup
                if(e.id === selectedEnemyId) { selectedEnemyId=null; document.getElementById('inspect-panel').style.display='none'; }
                unlockEnemy(e.type);
                updateUI();
            }
        }

	// --- NEW HELPER: Auto-Centers any model ---
        function centerModel(mesh) {
            // 1. Calculate the bounding box of the model
            const box = new THREE.Box3().setFromObject(mesh);
            const center = box.getCenter(new THREE.Vector3());
            
            // 2. Shift the mesh opposite to its center offset
            // This forces the "Middle" of the model to sit exactly at (0,0,0)
            mesh.position.x -= center.x;
            mesh.position.y -= center.y;
            mesh.position.z -= center.z;
            
            return mesh;
        }

        // --- BUILDING ---
function createTowerModel(type, level = 1, branch = null) {
    const root = new THREE.Group();

    // --- 1. SHARED MATERIALS ---
    const tData = TOWERS[type] || { color: 0xffffff };
    let mainColor = tData.color;
    if (level === 5 && branch && typeof TOWER_UPGRADES !== 'undefined' && TOWER_UPGRADES[type]) {
        mainColor = TOWER_UPGRADES[type][branch].color;
    }

    const matBase = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.7 });
    const matMain = new THREE.MeshStandardMaterial({ color: mainColor, roughness: 0.3, metalness: 0.2 });
    const matDetail = new THREE.MeshStandardMaterial({ color: 0x95a5a6, roughness: 0.2, metalness: 0.8 });
    const matDark = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.9 });
    const matGold = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1.0, roughness: 0.2 });
    const matEnergy = new THREE.MeshBasicMaterial({ color: mainColor });
    
    // FIX: Added side: THREE.DoubleSide to fix the invisible wall glitch
    const matGlass = new THREE.MeshStandardMaterial({ 
        color: 0xaaddff, 
        transparent: true, 
        opacity: 0.6, 
        metalness: 0.9, 
        roughness: 0.0,
        side: THREE.DoubleSide 
    });
    
    // Gatling Materials (Modernized)
    const matGunMetal = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.6, roughness: 0.4 });

    // --- 2. HELPER FUNCTIONS ---
    const addBolts = (target, count, radius, yPos, size = 0.05) => {
        for (let i = 0; i < count; i++) {
            const angle = (i / count) * Math.PI * 2;
            const b = new THREE.Mesh(new THREE.DodecahedronGeometry(size), matDetail);
            b.position.set(Math.cos(angle) * radius, yPos, Math.sin(angle) * radius);
            target.add(b);
        }
    };
    const addVents = (target, w, h, x, y, z) => {
        const g = new THREE.Group();
        g.position.set(x, y, z);
        const frame = new THREE.Mesh(new THREE.BoxGeometry(w, h, 0.05), matDark);
        g.add(frame);
        for(let i=0; i<5; i++) {
            const slat = new THREE.Mesh(new THREE.BoxGeometry(w*0.9, h/10, 0.06), matDetail);
            slat.position.y = (i - 2) * (h/6);
            g.add(slat);
        }
        target.add(g);
    };

    // --- 3. BASE GENERATION ---
    const baseGroup = new THREE.Group();
    root.add(baseGroup);
 
    if (type === 'plasma' || type === 'laser' || type === 'tesla') {
        // --- HOVER TECH BASE (Unchanged) ---
        const pad = new THREE.Mesh(new THREE.CylinderGeometry(2, 2.2, 0.4, 8), matBase);
        pad.position.y = 0.2;
        baseGroup.add(pad);
        
        const ringGeo = new THREE.TorusGeometry(1.8, 0.15, 6, 16);
        const r1 = new THREE.Mesh(ringGeo, matDetail); r1.rotation.x = Math.PI/2; r1.position.y = 0.6;
        const r2 = new THREE.Mesh(ringGeo, matMain); r2.rotation.x = Math.PI/2; r2.position.y = 0.9;
        baseGroup.add(r1, r2);
        
        for(let i=0; i<4; i++) {
            const em = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.8), matEnergy);
            em.position.set(Math.cos(i*1.57)*1.8, 1.2, Math.sin(i*1.57)*1.8);
            baseGroup.add(em);
        }
    }
    else if (type === 'farm') {
        // --- LAND PLOT (Unchanged) ---
        const soil = new THREE.Mesh(new THREE.BoxGeometry(3.5, 0.5, 3.5), matBase);
        soil.position.y = 0.25;
        baseGroup.add(soil);
        const grass = new THREE.Mesh(new THREE.BoxGeometry(3.3, 0.1, 3.3), new THREE.MeshStandardMaterial({color:0x2ecc71}));
        grass.position.y = 0.55;
        baseGroup.add(grass);
    }
    else {
        // --- HEAVY MILITARY BASE (Unchanged) ---
        const footGeo = new THREE.BoxGeometry(0.8, 0.4, 1.2);
        for(let i=0; i<4; i++) {
            const foot = new THREE.Mesh(footGeo, matBase);
            const ang = (i/4)*Math.PI*2 + Math.PI/4;
            foot.position.set(Math.cos(ang)*1.5, 0.2, Math.sin(ang)*1.5);
            foot.lookAt(0,0.2,0);
            baseGroup.add(foot);
            const strut = new THREE.Mesh(new THREE.BoxGeometry(0.2, 2.0, 0.4), matBase);
            strut.position.set(Math.cos(ang)*1.0, 0.5, Math.sin(ang)*1.0);
            strut.rotation.x = -0.3; strut.lookAt(0, 1.5, 0);
            baseGroup.add(strut);
        }
        const center = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.2, 1.0, 8), matDark);
        center.position.y = 0.5;
        baseGroup.add(center);
        addBolts(baseGroup, 8, 1.1, 0.9);
    }

    // --- 4. HEAD GENERATION ---
    const head = new THREE.Group();
    if (type === 'minigun') head.position.y = 1.0; // Adjusted for new base
    else if (type === 'farm') head.position.y = 0.6;
    else if (type === 'cannon') head.position.y = 1.0; // Cannon rotates
    else if (type === 'flamethrower') head.position.y = 1.0; // Flamethrower rotates
    else if (type === 'mortar') head.position.y = 1.2;
    else head.position.y = 1.0;
    
    root.add(head);

    // ===========================================
    //               TOWER LOGIC
    // ===========================================

    if (type === 'gunner') {
        // --- DEFAULT LOOK ---
        const swivel = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 0.4, 16), matDetail);
        swivel.position.y = 0.2; head.add(swivel);
        
        const housing = new THREE.Mesh(new THREE.BoxGeometry(1.4, 1.2, 2.0), matMain);
        housing.position.set(0, 1.0, 0); head.add(housing);
        
        const drum = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.6, 0.5, 12), matDark);
        drum.rotation.z = Math.PI/2; drum.position.set(0.9, 1.0, 0); head.add(drum);
        
        // --- LEVEL UPGRADES ---
        if (level >= 2) { // Add Reinforced Top Plate
            const plate = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.2, 1.8), matDetail);
            plate.position.set(0, 1.7, 0); head.add(plate);
        }
        if (level >= 3) { // Add Targeting Sensor
            const sensor = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.4), matEnergy);
            sensor.position.set(-0.5, 1.8, -0.5); head.add(sensor);
        }

        const makeGun = (offX) => {
            const g = new THREE.Group();
            g.position.set(offX, 1.0, 1.0);
            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 2.2), matDark);
            b.rotation.x = Math.PI/2; b.position.z = 1.1;
            const brake = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.4), matDetail);
            brake.rotation.x = Math.PI/2; brake.position.z = 2.2;
            g.add(b, brake);
            return g;
        };

        if (level >= 4) {
            head.add(makeGun(0.4)); head.add(makeGun(-0.4));
        } else {
            head.add(makeGun(0));
        }

        if (level === 5 && branch === 'A') { // Doomsday
            const pod = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.6, 1.2), matMain);
            pod.position.set(-1.0, 1.2, 0); head.add(pod);
            for(let i=0; i<4; i++) {
                const m = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.3), new THREE.MeshBasicMaterial({color:0xff0000}));
                m.rotation.x = -Math.PI/2; m.position.set(-1.0 + (i%2)*0.4, 1.2 + (i<2?0.2:-0.2), 0.6);
                head.add(m);
            }
        } else if (level === 5 && branch === 'B') { // Shredder
            const dish = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.1, 0.2, 16), matDetail);
            dish.position.set(0, 1.8, -0.5); head.add(dish);
        }
    }

    else if (type === 'sniper') {
        // --- 1. BASE MODEL (Level 1) ---
        // Pivot/Stand
        const pivot = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 0.8), matDark);
        pivot.position.y = 0.3; head.add(pivot);

        // Main Receiver (The body)
        const body = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.7, 1.5), matMain);
        body.position.set(0, 0.8, 0.5); head.add(body);

        // Stock (Back part)
        const stock = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.5, 1.2), matDark);
        stock.position.set(0, 0.7, -0.8); head.add(stock);

        // Thin Barrel (Level 1 Style)
        if (level < 4) {
            const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 3.5), matDetail);
            barrel.rotation.x = Math.PI/2; 
            barrel.position.set(0, 0.8, 2.5); 
            head.add(barrel);
        }

        // --- 2. LEVEL UPGRADES (Visual Progression) ---
        
        // LEVEL 2: "Tactical Kit" (Muzzle Brake + Laser)
        if (level >= 2) {
            // Giant Muzzle Brake (T-Shape at end of barrel)
            // Position depends on if we have the L4 shroud or not
            const tipPos = (level >= 4) ? 4.8 : 4.2;
            const brake = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.4, 0.5), matDark);
            brake.position.set(0, 0.8, tipPos); 
            head.add(brake);

            // Laser Sight (Side Box)
            const laserBox = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.6), matDark);
            laserBox.position.set(0.4, 0.9, 1.5); 
            head.add(laserBox);
            
            // The Laser Beam Emitter (Red dot)
            const lens = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.1), new THREE.MeshBasicMaterial({color:0xff0000}));
            lens.position.set(0.4, 0.9, 1.85);
            head.add(lens);
        }

        // LEVEL 3: "Heavy Mag Kit" (Ammo Box + Cheek Pad)
        if (level >= 3) {
            // Big Ammo Box (Sticking out the left side)
            const mag = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.8, 0.6), matDetail);
            mag.position.set(-0.6, 0.7, 0.5); 
            head.add(mag);

            // Cheek Rest (On stock)
            const rest = new THREE.Mesh(new THREE.CylinderGeometry(0.25, 0.25, 0.8, 8, 1, false, 0, Math.PI), matMain);
            rest.rotation.z = Math.PI/2;
            rest.rotation.y = Math.PI/2;
            rest.position.set(0, 0.95, -0.8);
            head.add(rest);
        }

        // LEVEL 4: "Elite Barrel" (Thermal Shroud + Digital Scope)
        if (level >= 4) {
            // REPLACE the thin barrel with a massive Thermal Shroud (Square Barrel)
            const shroud = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.6, 3.5), matMain);
            shroud.position.set(0, 0.8, 2.8);
            head.add(shroud);
            
            // Cooling Vents (Visual detail on shroud)
            for(let i=0; i<5; i++) {
                const vent = new THREE.Mesh(new THREE.BoxGeometry(0.52, 0.4, 0.1), matDark);
                vent.position.set(0, 0.8, 1.5 + i*0.6);
                head.add(vent);
            }

            // Digital Scope (Replaces iron sights)
            const scopeBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.2), matDark);
            scopeBase.position.set(0, 1.35, 0.2);
            head.add(scopeBase);
            
            const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16), new THREE.MeshBasicMaterial({color:0x00ff00}));
            lens.rotation.x = Math.PI/2;
            lens.position.set(0, 1.35, -0.4); // Facing player
            head.add(lens);
        }

        // --- 3. BRANCH PATHS (Level 5) ---
        if (branch === 'A') { // CRIPPLE (Purple Tech)
            const sensor = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.8), matEnergy);
            sensor.position.set(0.3, 1.2, 1.0); head.add(sensor);
            // Glow tip
            const glow = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.5, 0.2), matEnergy);
            glow.position.set(0, 0.8, 5.1); head.add(glow);
        } 
        else if (branch === 'B') { // ELITE (Golden/Yellow Accents)
            const drum = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.5, 0.4, 16), matDark);
            drum.rotation.z = Math.PI/2; 
            drum.position.set(0, 0.3, 0.5); head.add(drum); // Under-barrel drum
            
            // Gold Barrel Stripes
            const stripe = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.65, 0.5), matGold);
            stripe.position.set(0, 0.8, 3.5); head.add(stripe);
        }
    }

    else if (type === 'minigun') {
        // --- GATLING REDESIGN (Heavy Turret Style) ---
        
        // 1. Swivel Base (Low profile, heavy)
        const swivel = new THREE.Mesh(new THREE.CylinderGeometry(1.1, 1.1, 0.4, 16), matDetail);
        swivel.position.y = 0.2;
        head.add(swivel);

        // 2. Main Turret Block (Asymmetrical)
        const turret = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 1.5), matMain);
        turret.position.y = 0.8;
        head.add(turret);

        // 3. Massive Ammo Drum (Side Mounted)
        const drum = new THREE.Mesh(new THREE.CylinderGeometry(0.65, 0.65, 0.8, 16), matDark);
        drum.rotation.z = Math.PI/2;
        drum.position.set(0.8, 0.8, -0.2); // Stick out the right side
        head.add(drum);

        // Ammo Belt Feed
        const belt = new THREE.Mesh(new THREE.TorusGeometry(0.6, 0.15, 4, 8, 1.5), matDetail);
        belt.rotation.y = 1.5; 
        belt.position.set(0.5, 0.8, 0.2);
        head.add(belt);

        // 4. The Rotary Gun
        const gunGroup = new THREE.Group();
        gunGroup.position.set(-0.2, 0.8, 0.8); // Offset to left slightly to balance drum
        head.add(gunGroup);

        // Gun Motor Housing
        const motor = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, 1.0), matGunMetal);
        gunGroup.add(motor);

        // Barrel Cluster
        const cluster = new THREE.Group();
        cluster.position.z = 0.5;
        gunGroup.add(cluster);

        const barrelCount = (level >= 4) ? 8 : 6;
        for(let i=0; i<barrelCount; i++) {
            const angle = (i/barrelCount) * Math.PI * 2;
            const b = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.8), matDark);
            b.rotation.x = Math.PI/2;
            b.position.set(Math.cos(angle)*0.25, Math.sin(angle)*0.25, 1.4);
            cluster.add(b);
        }

        // Barrel Clamps (Visual Detail)
        const clamp1 = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.03, 4, 8), matDetail);
        clamp1.position.z = 1.5; cluster.add(clamp1);
        const clamp2 = new THREE.Mesh(new THREE.TorusGeometry(0.25, 0.03, 4, 8), matDetail);
        clamp2.position.z = 2.5; cluster.add(clamp2);

        // --- LEVEL VISUALS ---
        
        // Level 2: Heat Shield (Half-cylinder at base of barrels)
        if (level >= 2) {
            const shield = new THREE.Mesh(new THREE.CylinderGeometry(0.35, 0.35, 1.0, 16, 1, true, 0, Math.PI), matMain);
            shield.rotation.x = Math.PI/2;
            shield.rotation.z = Math.PI/2; // Open top
            shield.position.z = 1.0;
            gunGroup.add(shield);
        }

        // Level 3: Radar / Targeter on top of Turret
        if (level >= 3) {
            const sensorBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.2, 0.4), matDetail);
            sensorBase.position.set(0, 1.4, 0); head.add(sensorBase);
            
            const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.1, 0.5), matEnergy);
            lens.rotation.x = Math.PI/2;
            lens.position.set(0, 1.4, 0.3); head.add(lens);
        }

        // Level 5 Branch B: Rocket Pod Swap
        if (level === 5 && branch === 'B') {
            head.remove(gunGroup); // Remove the minigun
            head.remove(drum);     // Remove the ammo
            head.remove(belt);
            
            // Add Missile Rack
            const rack = new THREE.Mesh(new THREE.BoxGeometry(1.8, 1.2, 1.5), matMain);
            rack.position.set(0, 1.0, 0);
            head.add(rack);
            
            for(let x=-1; x<=1; x+=2) for(let y=-1; y<=1; y+=2) {
                const rkt = new THREE.Mesh(new THREE.ConeGeometry(0.25, 0.8), matDark);
                rkt.rotation.x = -Math.PI/2; 
                rkt.position.set(x*0.5, 1.0 + y*0.3, 0.8);
                head.add(rkt);
            }
        }
    }

    else if (type === 'cannon') {
        // --- EPIC BTD6 STYLE CANNON - BIGGER & BETTER ---
        
        // Wooden carriage base (BIGGER)
        const carriageL = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 2.5, 0.4),
            new THREE.MeshStandardMaterial({ color: 0x8B4513, roughness: 0.9 })
        );
        carriageL.position.set(-1.0, 0.8, -0.6);
        carriageL.rotation.z = 0.3;
        head.add(carriageL);
        
        const carriageR = carriageL.clone();
        carriageR.position.set(1.0, 0.8, -0.6);
        carriageR.rotation.z = -0.3;
        head.add(carriageR);
        
        // Wooden platform (BIGGER)
        const platform = new THREE.Mesh(
            new THREE.BoxGeometry(2.8, 0.4, 2.0),
            new THREE.MeshStandardMaterial({ color: 0x654321, roughness: 0.9 })
        );
        platform.position.y = 0.2;
        head.add(platform);
        
        // Wooden planks detail
        for(let i = 0; i < 4; i++) {
            const plank = new THREE.Mesh(
                new THREE.BoxGeometry(2.6, 0.05, 0.4),
                new THREE.MeshStandardMaterial({ color: 0x5d4037, roughness: 0.95 })
            );
            plank.position.set(0, 0.42, -0.8 + i * 0.5);
            head.add(plank);
        }
        
        // BIG Wheels (LARGER)
        const wheelGeo = new THREE.CylinderGeometry(0.7, 0.7, 0.3, 12);
        const wheelMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.8 });
        
        const wheelL = new THREE.Mesh(wheelGeo, wheelMat);
        wheelL.rotation.z = Math.PI / 2;
        wheelL.position.set(-1.4, 0.7, -0.5);
        head.add(wheelL);
        
        const wheelR = new THREE.Mesh(wheelGeo, wheelMat);
        wheelR.rotation.z = Math.PI / 2;
        wheelR.position.set(1.4, 0.7, -0.5);
        head.add(wheelR);
        
        // Wheel spokes (more detail)
        for(let wheel of [wheelL, wheelR]) {
            for(let i = 0; i < 8; i++) {
                const spoke = new THREE.Mesh(
                    new THREE.BoxGeometry(0.06, 0.6, 0.06),
                    new THREE.MeshStandardMaterial({ color: 0x2d1f14 })
                );
                const angle = (i / 8) * Math.PI * 2;
                spoke.position.x = Math.sin(angle) * 0.3;
                spoke.position.y = Math.cos(angle) * 0.3;
                spoke.rotation.z = angle;
                wheel.add(spoke);
            }
            // Wheel hub
            const hub = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.15, 0.35, 8),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9 })
            );
            hub.rotation.z = Math.PI / 2;
            wheel.add(hub);
        }
        
        // THE BARREL - BIGGER AND FATTER
        const barrelLength = (branch === 'A') ? 2.8 : 4;
        const barrelRadius = (branch === 'A') ? 0.65 : 0.55;
        
        const barrel = new THREE.Mesh(
            new THREE.CylinderGeometry(barrelRadius, barrelRadius * 1.15, barrelLength, 20),
            new THREE.MeshStandardMaterial({ 
                color: 0x1a1a1a, 
                metalness: 0.9, 
                roughness: 0.2 
            })
        );
        barrel.rotation.x = Math.PI / 2;
        barrel.position.set(0, 1.2, 1.5);
        head.add(barrel);
        
        // Muzzle (darker)
        const muzzle = new THREE.Mesh(
            new THREE.CylinderGeometry(barrelRadius + 0.1, barrelRadius, 0.4, 20),
            new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.1 })
        );
        muzzle.rotation.x = Math.PI / 2;
        muzzle.position.set(0, 1.2, 1.5 + barrelLength/2);
        head.add(muzzle);
        
        // Barrel rings (MORE metal bands)
        for(let i = 0; i < 4; i++) {
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(barrelRadius + 0.07, 0.08, 12, 20),
                matDetail
            );
            ring.rotation.y = Math.PI / 2;
            ring.position.set(0, 1.2, -0.4 + i * 0.7);
            head.add(ring);
        }
        
        // Fuse hole on top (bigger)
        const fuseBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.12, 0.12, 0.1, 8),
            new THREE.MeshStandardMaterial({ color: 0x8B4513 })
        );
        fuseBase.position.set(0, 1.55, -0.3);
        head.add(fuseBase);
        
        const fuse = new THREE.Mesh(
            new THREE.CylinderGeometry(0.06, 0.06, 0.2, 8),
            new THREE.MeshStandardMaterial({ color: 0xd4af37, emissive: 0x664400, emissiveIntensity: 0.3 })
        );
        fuse.position.set(0, 1.7, -0.3);
        head.add(fuse);
        
        // Cannon supports (metal brackets)
        const supportL = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.8, 0.3),
            new THREE.MeshStandardMaterial({ color: 0x2c2c2c, metalness: 0.8 })
        );
        supportL.position.set(-0.7, 0.9, 0);
        head.add(supportL);
        
        const supportR = supportL.clone();
        supportR.position.set(0.7, 0.9, 0);
        head.add(supportR);
        
        // Level upgrades
        if(level >= 2) {
            // Stack of cannonballs (BIGGER pile)
            const ballPositions = [
                [0.9, 0.5, 0.7], [1.1, 0.5, 0.5], [1.0, 0.8, 0.6],  // Right Pyramid
                [-0.9, 0.5, 0.7], [-1.1, 0.5, 0.5]                  // Left Pile
            ];
            ballPositions.forEach(pos => {
                const ball = new THREE.Mesh(
                    new THREE.SphereGeometry(0.25, 12, 12),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.9, roughness: 0.2 })
                );
                ball.position.set(...pos);
                head.add(ball);
            });
        }
        
        if(level >= 3) {
            // Reinforced barrel with rivets
            const reinforcement = new THREE.Mesh(
                new THREE.CylinderGeometry(barrelRadius + 0.15, barrelRadius + 0.15, 0.5, 20),
                matMain
            );
            reinforcement.rotation.x = Math.PI / 2;
            reinforcement.position.set(0, 1.2, 1.2);
            head.add(reinforcement);
            
            // Rivets on reinforcement
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                const rivet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.05, 6, 6),
                    matDetail
                );
                rivet.position.set(
                    Math.sin(angle) * (barrelRadius + 0.15),
                    1.2,
                    1.2 + Math.cos(angle) * (barrelRadius + 0.15)
                );
                head.add(rivet);
            }
        }
        
        if(level >= 4 && !branch) {
            // GOLD barrel bands (SHINY!)
            for(let i = 0; i < 3; i++) {
                const goldRing = new THREE.Mesh(
                    new THREE.TorusGeometry(barrelRadius + 0.1, 0.1, 12, 20),
                    matGold
                );
                goldRing.rotation.y = Math.PI / 2;
                goldRing.position.set(0, 1.2, 0.2 + i * 0.8);
                head.add(goldRing);
            }
            
            // Crown on barrel (royal!)
            const crown = new THREE.Mesh(
                new THREE.ConeGeometry(0.2, 0.3, 5),
                matGold
            );
            crown.position.set(0, 1.6, 1.0);
            head.add(crown);
        }
        
        // Branch A: HOWITZER - MASSIVE barrel
        if(branch === 'A') {
            // Blast shield
            const shield = new THREE.Mesh(
                new THREE.BoxGeometry(3.2, 1.5, 0.25),
                matMain
            );
            shield.position.set(0, 1.2, -1.0);
            head.add(shield);
            
            // Danger stripes on shield
            for(let i = 0; i < 6; i++) {
                const stripe = new THREE.Mesh(
                    new THREE.BoxGeometry(0.4, 1.4, 0.26),
                    new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? 0xffff00 : 0x000000 })
                );
                stripe.position.set(-1.5 + i * 0.6, 1.2, -1.0);
                head.add(stripe);
            }
        }
        
        // Branch B: GRAPESHOT - Triple cannons
        if(branch === 'B') {
            barrel.visible = false;
            muzzle.visible = false;
            
            for(let i = -1; i <= 1; i++) {
                const smallBarrel = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.35, 0.4, 1.8, 16),
                    new THREE.MeshStandardMaterial({ 
                        color: 0x1a1a1a, 
                        metalness: 0.9, 
                        roughness: 0.2 
                    })
                );
                smallBarrel.rotation.x = Math.PI / 2;
                smallBarrel.position.set(i * 0.7, 1.2, 0.4);
                head.add(smallBarrel);
                
                // Mini muzzles
                const miniMuzzle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.4, 0.35, 0.3, 16),
                    new THREE.MeshStandardMaterial({ color: 0x0a0a0a, roughness: 0.1 })
                );
                miniMuzzle.rotation.x = Math.PI / 2;
                miniMuzzle.position.set(i * 0.7, 1.2, 1.2);
                head.add(miniMuzzle);
            }
        }
    }
    
    else if (type === 'flamethrower') {
        // --- FLAMETHROWER: INFERNO TOWER ---
        
        // Base - Fuel tank
        const tank = new THREE.Mesh(
            new THREE.CylinderGeometry(0.8, 0.9, 1.8, 16),
            new THREE.MeshStandardMaterial({ color: 0x444444, metalness: 0.8, roughness: 0.3 })
        );
        tank.position.y = 0.9;
        head.add(tank);
        
        // Warning stripes on tank
        for(let i = 0; i < 3; i++) {
            const stripe = new THREE.Mesh(
                new THREE.TorusGeometry(0.82, 0.08, 8, 16),
                new THREE.MeshStandardMaterial({ color: i % 2 === 0 ? 0xff6600 : 0xffff00 })
            );
            stripe.rotation.x = Math.PI / 2;
            stripe.position.y = 0.3 + i * 0.6;
            head.add(stripe);
        }
        
        // Pressure gauge
        const gauge = new THREE.Mesh(
            new THREE.CylinderGeometry(0.25, 0.25, 0.1, 16),
            new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.9 })
        );
        gauge.rotation.z = Math.PI / 2;
        gauge.position.set(0.9, 1.2, 0);
        head.add(gauge);
        
        const gaugeGlass = new THREE.Mesh(
            new THREE.CylinderGeometry(0.2, 0.2, 0.12, 16),
            matGlass
        );
        gaugeGlass.rotation.z = Math.PI / 2;
        gaugeGlass.position.set(0.95, 1.2, 0);
        head.add(gaugeGlass);
        
        // Nozzle assembly
        const nozzleBase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.3, 0.4, 0.8, 12),
            matMain
        );
        nozzleBase.rotation.x = Math.PI / 2;
        nozzleBase.position.set(0, 1.5, 1.0);
        head.add(nozzleBase);
        
        const nozzle = new THREE.Mesh(
            new THREE.ConeGeometry(0.35, 1.2, 12),
            new THREE.MeshStandardMaterial({ color: 0xff4500, emissive: 0x330000, emissiveIntensity: 0.3, metalness: 0.7 })
        );
        nozzle.rotation.x = -Math.PI / 2;
        nozzle.position.set(0, 1.5, 1.8);
        head.add(nozzle);
        
        // Igniter (pilot light)
        const igniter = new THREE.Mesh(
            new THREE.SphereGeometry(0.15, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xff6600 })
        );
        igniter.position.set(0, 1.5, 2.3);
        head.add(igniter);
        
        // Support arm
        const arm = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 1.2, 0.2),
            matDetail
        );
        arm.position.set(0, 1.0, 0.8);
        arm.rotation.x = -0.3;
        head.add(arm);
        
        // Level 2: Reinforced tank
        if(level >= 2) {
            // Thick metal bands
            for(let i = 0; i < 4; i++) {
                const band = new THREE.Mesh(
                    new THREE.TorusGeometry(0.92, 0.06, 8, 16),
                    matDetail
                );
                band.rotation.x = Math.PI / 2;
                band.position.y = 0.2 + i * 0.5;
                head.add(band);
            }
        }
        
        // Level 3: Dual fuel lines
        if(level >= 3) {
            for(let side = -1; side <= 1; side += 2) {
                const pipe = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 1.5, 8),
                    new THREE.MeshStandardMaterial({ color: 0x8b4513 })
                );
                pipe.position.set(side * 0.6, 1.0, 0.3);
                pipe.rotation.x = -0.5;
                head.add(pipe);
            }
        }
        
        // Level 4: Gold trim
        if(level >= 4) {
            const topRim = new THREE.Mesh(
                new THREE.TorusGeometry(0.85, 0.1, 8, 16),
                matGold
            );
            topRim.rotation.x = Math.PI / 2;
            topRim.position.y = 1.8;
            head.add(topRim);
            
            // Ornate valve
            const valve = new THREE.Mesh(
                new THREE.TorusGeometry(0.15, 0.05, 8, 12),
                matGold
            );
            valve.rotation.z = Math.PI / 2;
            valve.position.set(-0.9, 0.6, 0);
            head.add(valve);
        }
        
        // Branch A: DRAGON'S BREATH - Extended range, long burns
        if(branch === 'A') {
            // Longer, ribbed nozzle
            nozzle.scale.z = 1.5;
            nozzle.position.z = 2.2;
            
            // Dragon head ornament
            const dragonHead = new THREE.Mesh(
                new THREE.BoxGeometry(0.6, 0.5, 0.8),
                new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0xff0000, emissiveIntensity: 0.4 })
            );
            dragonHead.position.set(0, 1.8, 2.5);
            head.add(dragonHead);
            
            // Dragon horns
            for(let side = -1; side <= 1; side += 2) {
                const horn = new THREE.Mesh(
                    new THREE.ConeGeometry(0.1, 0.4, 6),
                    matGold
                );
                horn.position.set(side * 0.25, 2.1, 2.5);
                horn.rotation.z = side * 0.5;
                head.add(horn);
            }
            
            // Flame decals
            for(let i = 0; i < 3; i++) {
                const flame = new THREE.Mesh(
                    new THREE.ConeGeometry(0.15, 0.5, 4),
                    new THREE.MeshBasicMaterial({ color: 0xffaa00 })
                );
                flame.rotation.x = Math.PI;
                flame.position.set(0, 1.2 - i * 0.5, 0);
                tank.add(flame);
            }
        }
        
        // Branch B: RING OF FIRE - 360 degree area damage
        if(branch === 'B') {
            // Hide main nozzle
            nozzle.visible = false;
            nozzleBase.visible = false;
            arm.visible = false;
            igniter.visible = false;
            
            // Ring of 8 nozzles
            for(let i = 0; i < 8; i++) {
                const angle = (i / 8) * Math.PI * 2;
                
                const ringNozzle = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 0.6, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: 0xff6600, 
                        emissive: 0x330000, 
                        emissiveIntensity: 0.5,
                        metalness: 0.8
                    })
                );
                ringNozzle.rotation.x = Math.PI / 2;
                ringNozzle.rotation.z = angle;
                ringNozzle.position.set(
                    Math.cos(angle) * 1.0,
                    1.8,
                    Math.sin(angle) * 1.0
                );
                head.add(ringNozzle);
                
                // Pilot lights
                const flame = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 6, 6),
                    new THREE.MeshBasicMaterial({ color: 0xffaa00 })
                );
                flame.position.set(
                    Math.cos(angle) * 1.3,
                    1.8,
                    Math.sin(angle) * 1.3
                );
                head.add(flame);
            }
            
            // Central ring platform
            const platform = new THREE.Mesh(
                new THREE.CylinderGeometry(1.2, 1.2, 0.2, 16),
                matMain
            );
            platform.position.y = 1.7;
            head.add(platform);
        }
    }
    
    else if (type === 'mortar') {
        // --- DEFAULT LOOK ---
        const plate = new THREE.Mesh(new THREE.CylinderGeometry(1.8, 1.8, 0.2, 16), matDetail);
        head.add(plate);
        
        const mountL = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.5, 1.5), matMain);
        mountL.position.set(1.0, 0.8, 0); head.add(mountL);
        const mountR = mountL.clone(); mountR.position.set(-1.0, 0.8, 0); head.add(mountR);

        const tubeGroup = new THREE.Group();
        tubeGroup.rotation.x = Math.PI/4; 
        tubeGroup.position.set(0, 0.8, 0);
        head.add(tubeGroup);

        // --- LEVEL UPGRADES ---
        if (level >= 2) { // Hydraulic Pistons
            const pis = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 1.0), matDetail);
            pis.position.set(0.8, 0.5, -0.5); pis.rotation.x = -0.5; head.add(pis);
        }
        if (level >= 3) { // Auto Loader Box
            const loader = new THREE.Mesh(new THREE.BoxGeometry(1.0, 0.8, 1.0), matDark);
            loader.position.set(0, 0.5, -1.0); head.add(loader);
        }

        if (branch === 'B') {
            for(let i=-1; i<=1; i++) {
                const t = new THREE.Mesh(new THREE.CylinderGeometry(0.5, 0.6, 3.5, 16), matDark);
                t.position.x = i * 1.1; t.position.y = 1.0; tubeGroup.add(t);
            }
        } else {
            const r = (branch === 'A') ? 1.2 : 0.8;
            const t = new THREE.Mesh(new THREE.CylinderGeometry(r, r+0.1, 3.5, 16), (branch==='A')?matMain:matDark);
            t.position.y = 1.0; tubeGroup.add(t);
            
            const ring = new THREE.Mesh(new THREE.TorusGeometry(r+0.15, 0.1, 4, 16), matDetail);
            ring.rotation.x = Math.PI/2; ring.position.y = -0.5; tubeGroup.add(ring);
            
            if (level >= 4 && !branch) { // Reinforced Muzzle
                const muzzle = new THREE.Mesh(new THREE.TorusGeometry(r+0.2, 0.15, 4, 16), matDetail);
                muzzle.rotation.x = Math.PI/2; muzzle.position.y = 1.8; tubeGroup.add(muzzle);
            }

            if(branch === 'A') {
                const core = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 3.6), matEnergy);
                core.position.y = 1.0; tubeGroup.add(core);
            }
        }
    }

    else if (type === 'tesla') {
        // --- DEFAULT LOOK ---
        const shaft = new THREE.Mesh(new THREE.CylinderGeometry(0.6, 0.8, 3.0, 8), matDetail);
        shaft.position.y = 1.5; head.add(shaft);
        
        // --- LEVEL UPGRADES ---
        if (level >= 2) { // Capacitor Base
            const cap = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.0, 0.5), matMain);
            cap.position.y = 0.5; head.add(cap);
        }
        
        // Coils
        const coilCount = level >= 3 ? 6 : 4;
        for(let i=0; i<coilCount; i++) {
            const coil = new THREE.Mesh(new THREE.TorusGeometry(1.0 - (i*0.1), 0.15, 8, 16), new THREE.MeshStandardMaterial({color:0xb85c00}));
            coil.rotation.x = Math.PI/2; coil.position.y = 0.5 + i*0.5;
            head.add(coil);
        }
        
        if (level >= 4 && !branch) { // Static Spikes
            for(let i=0; i<3; i++) {
                const s = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5), matEnergy);
                s.position.set(Math.cos(i*2), 3.0, Math.sin(i*2));
                head.add(s);
            }
        }

        if (branch === 'A') {
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), matEnergy);
            sphere.position.y = 3.5; head.add(sphere);
            const ring = new THREE.Mesh(new THREE.TorusGeometry(2.5, 0.1, 4, 32), matDetail);
            ring.rotation.x = Math.PI/2; ring.position.y = 3.5; head.add(ring);
        } else if (branch === 'B') {
            const dish = new THREE.Mesh(new THREE.ConeGeometry(2.0, 1.0, 16, 1, true), matDark);
            dish.position.y = 3.5; head.add(dish);
            const spike = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.4, 2.0), matEnergy);
            spike.position.y = 3.5; head.add(spike);
        } else {
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(0.8), matDetail);
            sphere.position.y = 3.2; head.add(sphere);
            for(let i=0; i<4; i++) {
                const s = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.8), matMain);
                s.position.set(Math.cos(i*1.57), 3.5, Math.sin(i*1.57));
                s.lookAt(0, 3.2, 0); head.add(s);
            }
        }
    }

    else if (type === 'ice') {
        // --- SYMMETRICAL CRYO-SPIRE (AoE Style) ---
        // Since this tower spins 360 degrees in the animation loop, 
        // we build it to look good from all angles.

        // 1. Central Cooling Column (The Core)
        // A glass cylinder encasing pure energy
        const coreGeo = new THREE.CylinderGeometry(0.6, 0.6, 2.5, 6);
        const core = new THREE.Mesh(coreGeo, matGlass);
        core.position.y = 1.2;
        head.add(core);
        
        // Inner Energy Rod (The glow inside)
        const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 2.5), matEnergy);
        rod.position.y = 1.2;
        head.add(rod);

        // 2. Symmetrical Containment Arms (3-way symmetry)
        // These hold the core in place, similar to the Plasma tower
        for(let i=0; i<3; i++) {
            const armGroup = new THREE.Group();
            const angle = (i/3) * Math.PI * 2;
            
            armGroup.rotation.y = angle;
            
            // The Pillar/Arm
            const pillar = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.2, 0.4), matMain);
            pillar.position.set(0, 1.1, 1.2); // Offset from center
            armGroup.add(pillar);
            
            // Connector beam to core
            const conn = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.8), matDark);
            conn.position.set(0, 1.1, 0.6);
            armGroup.add(conn);
            
            head.add(armGroup);
        }

        // --- LEVEL UPGRADES (Adding complexity to the symmetry) ---
        
        // L2: Base Diffuser Ring (Widening the footprint)
        if (level >= 2) {
            const ring = new THREE.Mesh(new THREE.TorusGeometry(1.6, 0.1, 4, 32), matDetail);
            ring.rotation.x = Math.PI/2;
            ring.position.y = 0.4;
            head.add(ring);
        }

        // L3: Top Stabilizer Ring (Closing the cage)
        if (level >= 3) {
            const topRing = new THREE.Mesh(new THREE.TorusGeometry(1.4, 0.1, 4, 32), matDetail);
            topRing.rotation.x = Math.PI/2;
            topRing.position.y = 2.2;
            head.add(topRing);
        }

        // L4: Floating Emitters (Symmetrical Crystals)
        if (level >= 4) {
            for(let i=0; i<3; i++) {
                const em = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.6), matEnergy);
                // Place these BETWEEN the main arms
                const angle = (i/3) * Math.PI * 2 + (Math.PI/3); 
                em.position.set(Math.cos(angle)*1.0, 2.6, Math.sin(angle)*1.0);
                head.add(em);
            }
        }

        // --- BRANCH PATHS ---
        
        if (branch === 'A') { // ABSOLUTE ZERO (The Frozen Sun)
            // Remove the mechanical core to make room for the Sphere
            head.remove(core);
            head.remove(rod);
            
            // Outer Glass Shell
            const sphere = new THREE.Mesh(new THREE.SphereGeometry(1.5, 16, 16), matGlass);
            sphere.position.y = 1.5;
            head.add(sphere);
            
            // Inner Pulsing Core
            const inner = new THREE.Mesh(new THREE.SphereGeometry(0.8, 8, 8), matEnergy);
            inner.position.y = 1.5;
            head.add(inner);
        }
        else if (branch === 'B') { // ICICLES (The Shredder)
            // Add 6 jagged spikes sticking outward
            for(let i=0; i<6; i++) {
                const spike = new THREE.Mesh(new THREE.ConeGeometry(0.1, 1.8), matDetail);
                const angle = (i/6) * Math.PI * 2;
                
                // Position them in a circle
                spike.position.set(Math.cos(angle)*1.4, 1.5, Math.sin(angle)*1.4);
                
                // Rotate to point OUTWARD
                spike.rotation.y = -angle;
                spike.rotation.z = Math.PI/2; 
                
                head.add(spike);
            }
        }
    }

    else if (type === 'laser') {
        // --- DEFAULT LOOK ---
        const yoke = new THREE.Mesh(new THREE.BoxGeometry(2.5, 0.5, 0.5), matDark);
        yoke.position.y = 0.5; head.add(yoke);
        const pillarL = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.0, 0.8), matMain);
        pillarL.position.set(1.2, 1.5, 0); head.add(pillarL);
        const pillarR = pillarL.clone(); pillarR.position.set(-1.2, 1.5, 0); head.add(pillarR);
        
        const coreGroup = new THREE.Group();
        coreGroup.position.y = 1.5; head.add(coreGroup);
        
        const lensHouse = new THREE.Mesh(new THREE.CylinderGeometry(0.8, 0.6, 1.5, 6), matDark);
        lensHouse.rotation.x = Math.PI/2; coreGroup.add(lensHouse);
        
        const crystalGeo = branch === 'A' ? new THREE.CylinderGeometry(0.1, 0.6, 3.0, 6) : new THREE.OctahedronGeometry(0.6);
        const crystal = new THREE.Mesh(crystalGeo, new THREE.MeshBasicMaterial({color:mainColor}));
        if(branch === 'A') { crystal.rotation.x = -Math.PI/2; crystal.position.z = 0.5; }
        else { crystal.position.z = 0; }
        coreGroup.add(crystal);

        for(let i=0; i<3; i++) {
            const rod = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2.0), matDetail);
            const a = (i/3)*Math.PI*2;
            rod.position.set(Math.cos(a)*0.9, Math.sin(a)*0.9, 0.5);
            rod.rotation.x = Math.PI/2; coreGroup.add(rod);
        }

        // --- LEVEL UPGRADES ---
        if (level >= 2) { // Batteries
            const bat = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.2, 0.8), matEnergy);
            bat.rotation.z = Math.PI/2; bat.position.set(1.5, 1.5, 0); head.add(bat);
        }
        if (level >= 3) { // Cooling Fins
            const fin = new THREE.Mesh(new THREE.BoxGeometry(0.1, 1.0, 0.5), matDark);
            fin.position.set(0, 2.0, 0); head.add(fin);
        }
        if (level >= 4) { // Focus Ring
            const ring = new THREE.Mesh(new THREE.TorusGeometry(0.5, 0.05, 4, 16), matDetail);
            ring.position.z = 1.2; coreGroup.add(ring);
        }
    }

    else if (type === 'plasma') {
        // --- DEFAULT LOOK ---
        for(let i=0; i<3; i++) {
            const arm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 2.5, 0.4), matMain);
            const a = (i/3)*Math.PI*2;
            arm.position.set(Math.cos(a)*1.5, 2.0, Math.sin(a)*1.5);
            arm.rotation.z = -0.2; arm.lookAt(0, 2.0, 0); head.add(arm);
        }
        
        const coreGeo = (branch === 'B') ? new THREE.SphereGeometry(1.2) : new THREE.IcosahedronGeometry(1.0, 1);
        const coreMat = (branch === 'B') ? new THREE.MeshBasicMaterial({color:0x000000}) : new THREE.MeshBasicMaterial({color:mainColor, wireframe:true});
        const core = new THREE.Mesh(coreGeo, coreMat);
        core.position.y = 2.0; head.add(core);
        
        const r1 = new THREE.Mesh(new THREE.TorusGeometry(1.4, 0.05, 4, 32), matDark);
        r1.position.y = 2.0; r1.rotation.x = Math.PI/2; head.add(r1);
        
        // --- LEVEL UPGRADES ---
        if (level >= 2) { // Second Ring
            const r2 = new THREE.Mesh(new THREE.TorusGeometry(1.6, 0.05, 4, 32), matDetail);
            r2.position.y = 2.0; r2.rotation.y = 0.5; head.add(r2);
        }
        if (level >= 3) { // Base Emitters
            for(let i=0; i<3; i++) {
                const em = new THREE.Mesh(new THREE.ConeGeometry(0.1, 0.5), matEnergy);
                const a = (i/3)*Math.PI*2;
                em.position.set(Math.cos(a)*1.0, 0.5, Math.sin(a)*1.0);
                head.add(em);
            }
        }
        if (level >= 4) { // Top Spike
            const spike = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 1.5), matDetail);
            spike.position.y = 3.2; head.add(spike);
        }

        if (branch === 'B') {
             const disk = new THREE.Mesh(new THREE.RingGeometry(1.5, 2.5, 32), new THREE.MeshBasicMaterial({color:0x8e44ad, side:THREE.DoubleSide, transparent:true, opacity:0.6}));
             disk.position.y = 2.0; disk.rotation.x = Math.PI/2; head.add(disk);
        }
    }

    else if (type === 'farm') {
        // --- DEFAULT LOOK ---
        const bGeo = new THREE.BoxGeometry(2.0, 3.0, 2.0);
        const building = new THREE.Mesh(bGeo, matMain);
        building.position.y = 1.5; head.add(building);
        
        for(let z=-1; z<=1; z+=2) {
            const rack = new THREE.Mesh(new THREE.PlaneGeometry(1.6, 2.6), new THREE.MeshBasicMaterial({color:0x00ff00}));
            rack.position.set(0, 1.5, z*1.01);
            if(z===1) rack.rotation.y = Math.PI; head.add(rack);
        }
        
        const fanHouse = new THREE.Mesh(new THREE.BoxGeometry(2.2, 0.5, 2.2), matDark);
        fanHouse.position.y = 3.2; head.add(fanHouse);
        
        // --- LEVEL UPGRADES ---
        if (level >= 2) { // Solar Panel
            const panel = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.1, 1.0), new THREE.MeshStandardMaterial({color:0x34495e}));
            panel.position.set(0, 3.5, 0); head.add(panel);
        }
        if (level >= 3) { // Satellite Dish
            const dish = new THREE.Mesh(new THREE.ConeGeometry(0.5, 0.2, 16, 1, true), matDetail);
            dish.position.set(0.5, 3.5, 0.5); dish.rotation.x = -0.5; head.add(dish);
        }
        if (level >= 4) { // Extra Server Wing
            const wing = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.0, 1.5), matMain);
            wing.position.set(1.2, 1.5, 0); head.add(wing);
        }

        if (branch === 'A') {
            const vault = new THREE.Mesh(new THREE.CylinderGeometry(1.2, 1.2, 0.5, 16), matGold);
            vault.rotation.x = Math.PI/2; vault.position.set(0, 1.5, 1.2); head.add(vault);
        } else if (branch === 'B') {
             const pipe = new THREE.Mesh(new THREE.TorusGeometry(1.5, 0.3, 8, 16), matDetail);
             pipe.rotation.y = Math.PI/2; pipe.position.y = 2.0; head.add(pipe);
             const stack = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 2.0), matDark);
             stack.position.set(1.0, 4.0, 1.0); head.add(stack);
        }
    }

    // --- 5. FINALIZE ---
    root.traverse(c => { 
        if(c.isMesh) { 
            c.castShadow = shadowsEnabled; 
            c.receiveShadow = shadowsEnabled; 
        } 
    });
    return root;
}
	function createEnemyModel(type, color, size) {
            size *= 2.5; 
            
            const group = new THREE.Group();
            const visuals = new THREE.Group();
            visuals.rotation.y = Math.PI; // Face Forward
            
            // --- 1. CLASSIFICATION SYSTEM ---
            const isMoab    = ['siege walker','dreadnought','the obliterator','void stalker','entropy monolith'].includes(type);
            const isSpecial = ['healer','disruptor','summoner'].includes(type);
            const isTuff    = ['tank','omnicrawler','shadow interceptor'].includes(type);
            const isFast    = ['pink','yellow','white','purple','zebra','rainbow'].includes(type);
            const isStarter = ['red','blue','green'].includes(type);

            // --- 2. ALTITUDE LOGIC ---
            let lift = size * 0.5;
            let hpY = size * 1.0;
            
            if (isMoab) { 
                lift = size * 1.5; 
                hpY = size * 1.2; 
            }
            else if (type === 'omnicrawler') {
                lift = size * 0.6; // FIX: Raised so wheels touch ground (Radius is 0.55)
                hpY = size * 1.4;
            }
            else if (['tank','summoner'].includes(type)) { 
                lift = size * 0.2; 
                hpY = size * 1.4; 
            } 
            else if (isFast || type === 'shadow interceptor') { 
                lift = size * 0.8; 
            }

            visuals.position.y = lift; 
            group.add(visuals);
            group.userData.hpOffset = lift + hpY + 0.5;
            
            // FIX: Siege Walker (MOAB) walked backwards because the model faces Z+ 
            // but the container was rotated 180. We reset rotation for him.
            if (type === 'moab') {
                visuals.rotation.y = 0; 
            }

            // --- 3. MATERIALS LIBRARY ---
            const matBody   = new THREE.MeshStandardMaterial({ color: color, roughness: 0.3, metalness: 0.5 });
            const matDark   = new THREE.MeshStandardMaterial({ color: 0x2c3e50, roughness: 0.8 });
            const matBlack  = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.9, metalness: 0.2 });
            const matChrome = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.9 });
            const matGlow   = new THREE.MeshBasicMaterial({ color: color }); 
            const matCyan   = new THREE.MeshBasicMaterial({ color: 0x00ffff }); // Engines
            const matRed    = new THREE.MeshBasicMaterial({ color: 0xff0000 }); // Sensors

            // =========================================================
            // GROUP 1: STARTER (The Sentry Drones)
            // =========================================================
            if (isStarter) {
                // Core Sphere (Detailed)
                const core = new THREE.Mesh(new THREE.IcosahedronGeometry(size*0.4, 1), matBody);
                visuals.add(core);

                // Equatorial Ring (Mechanical)
                const ring = new THREE.Mesh(new THREE.TorusGeometry(size*0.5, 0.05, 6, 16), matDark);
                if(type === 'blue') ring.rotation.x = 0.5; // Blue tilt
                visuals.add(ring);

                // Sensor Eye (Cyclops)
                const eye = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.2), matBlack);
                eye.rotation.x = Math.PI/2; eye.position.z = -size*0.35;
                visuals.add(eye);
                const lens = new THREE.Mesh(new THREE.SphereGeometry(0.08), matCyan);
                lens.position.set(0, 0, -size*0.45);
                visuals.add(lens);

                // Stabilizer Fins (3 Fins)
                for(let i=0; i<3; i++) {
                    const fin = new THREE.Mesh(new THREE.BoxGeometry(0.05, size*0.4, size*0.4), matDark);
                    const angle = (i / 3) * Math.PI * 2;
                    fin.position.set(Math.cos(angle)*size*0.4, Math.sin(angle)*size*0.4, size*0.2);
                    fin.rotation.z = angle;
                    visuals.add(fin);
                }
            }

            // =========================================================
            // GROUP 2: FAST (The Interceptor Jets)
            // =========================================================
            else if (isFast) {
                // --- SPECIAL: ZEBRA (Physical Racing Stripes) ---
                if (type === 'zebra') {
                    // Body: 5 Interlocking Segments
                    for(let i=0; i<5; i++) {
                        const isWhite = i%2===0;
                        const rad = size * (0.35 - i*0.05);
                        const seg = new THREE.Mesh(
                            new THREE.CylinderGeometry(rad, rad*0.8, size*0.4, 16),
                            isWhite ? new THREE.MeshStandardMaterial({color:0xffffff}) : matBlack
                        );
                        seg.rotation.x = -Math.PI/2;
                        seg.position.z = size * (0.4 - i*0.4);
                        visuals.add(seg);
                    }
                    // Wings
                    const w = new THREE.Mesh(new THREE.BoxGeometry(size*1.6, 0.05, size*0.4), new THREE.MeshStandardMaterial({color:0xffffff}));
                    visuals.add(w);
                }
                
                // --- SPECIAL: RAINBOW (Celestial Gyro) ---
                else if (type === 'rainbow') {
                    const core = new THREE.Mesh(new THREE.SphereGeometry(size*0.3, 16, 16), matChrome);
                    visuals.add(core);
                    const colors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0x9400d3];
                    colors.forEach((c, i) => {
                        const r = new THREE.Mesh(new THREE.TorusGeometry(size*(0.4+i*0.1), 0.02, 4, 24), new THREE.MeshBasicMaterial({color:c}));
                        r.rotation.set(Math.random()*3, Math.random()*3, Math.random()*3);
                        visuals.add(r);
                    });
                }

                // --- STANDARD JETS (Pink, Yellow, White, Purple) ---
                else {
                    // Needle Fuselage
                    const hull = new THREE.Mesh(new THREE.ConeGeometry(size*0.3, size*1.8, 8), matBody);
                    hull.rotation.x = -Math.PI/2; visuals.add(hull);
                    
                    // Cockpit Canopy
                    const canopy = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.2, 0.5), matBlack);
                    canopy.position.set(0, size*0.2, -size*0.2);
                    visuals.add(canopy);
                    
                    // Swept Wings
                    const wingShape = new THREE.Shape();
                    wingShape.moveTo(0,0); wingShape.lineTo(1.0, 0.6); wingShape.lineTo(1.0, 0.3); wingShape.lineTo(0.2, -0.2);
                    const wingGeo = new THREE.ExtrudeGeometry(wingShape, {depth:0.05, bevelEnabled:false});
                    const wL = new THREE.Mesh(wingGeo, matBody); wL.rotation.x = -Math.PI/2; wL.position.set(0.1, 0, 0);
                    const wR = wL.clone(); wR.scale.x = -1; wR.position.set(-0.1, 0, 0);
                    visuals.add(wL, wR);
                    
                    // Afterburner
                    const burn = new THREE.Mesh(new THREE.ConeGeometry(size*0.2, size*0.5, 8, 1, true), matCyan);
                    burn.rotation.x = Math.PI/2; burn.position.z = size*1.0;
                    visuals.add(burn);
                }
            }

            // =========================================================
            // GROUP 3: TUFF (Heavy Panzers)
            // =========================================================
            else if (isTuff) {
                // --- BLACK: SHADOW INTERCEPTOR (Redesigned) ---
                if (type === 'shadow interceptor') {
                    // 1. Central Fuselage (Long & Sleek)
                    const body = new THREE.Mesh(new THREE.BoxGeometry(size*0.3, size*0.15, size*1.4), matBlack);
                    visuals.add(body);

                    // 2. Cockpit / Sensor Dome
                    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(size*0.2, size*0.1, size*0.5), matDark);
                    cockpit.position.set(0, size*0.1, -size*0.3);
                    visuals.add(cockpit);

                    // 3. Swept-Back Delta Wings
                    for(let i=-1; i<=1; i+=2) {
                        // Main Wing Slab
                        const wing = new THREE.Mesh(new THREE.BoxGeometry(size*0.9, 0.05, size*0.7), matBlack);
                        // Position: Out to the side
                        wing.position.set(i * size*0.45, 0, size*0.1);
                        // Rotation: Sweep back 35 degrees
                        wing.rotation.y = -i * 0.6; 
                        visuals.add(wing);

                        // Vertical Stabilizers (Fins)
                        const fin = new THREE.Mesh(new THREE.BoxGeometry(0.05, size*0.5, size*0.4), matBlack);
                        fin.position.set(i * size*0.3, size*0.25, size*0.4);
                        fin.rotation.z = i * 0.3; // Slight outward tilt
                        // Shear the fin to look fast (rotation x)
                        fin.rotation.x = -0.4;
                        visuals.add(fin);
                        
                        // Engine Glow (Rear Vents)
                        const engine = new THREE.Mesh(new THREE.BoxGeometry(size*0.15, size*0.05, 0.1), matRed);
                        engine.position.set(i * size*0.3, 0, size*0.6);
                        visuals.add(engine);
                    }
                    
                    // 4. Front Red "Eye" (Scanner)
                    const eye = new THREE.Mesh(new THREE.BoxGeometry(size*0.15, 0.05, 0.2), matRed);
                    eye.position.set(0, 0, -size*0.7);
                    visuals.add(eye);
                }
                
                // --- LEAD: ARMORED TANK (Unchanged, kept for safety) ---
                else if (type === 'tank') {
                    const hull = new THREE.Mesh(new THREE.BoxGeometry(size*1.2, size*0.6, size*1.5), new THREE.MeshStandardMaterial({color:0x555555, metalness:1.0}));
                    visuals.add(hull);
                    const turret = new THREE.Mesh(new THREE.CylinderGeometry(size*0.4, size*0.5, size*0.4, 8), matDark);
                    turret.position.y = size*0.5; visuals.add(turret);
                    const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, size*1.0), matBlack);
                    barrel.rotation.x = -Math.PI/2; barrel.position.set(0, size*0.5, -size*0.6);
                    visuals.add(barrel);
                    const tGeo = new THREE.BoxGeometry(size*0.3, size*0.4, size*1.4);
                    const tL = new THREE.Mesh(tGeo, matBlack); tL.position.set(size*0.7, -size*0.1, 0);
                    const tR = tL.clone(); tR.position.set(-size*0.7, -size*0.1, 0);
                    visuals.add(tL, tR);
                }

                // --- CERAMIC: OMNI-CRAWLER (Rolling Fortress) ---
                else if (type === 'omnicrawler') {
                    const matTerra = new THREE.MeshStandardMaterial({color:0xd35400, roughness:0.5, metalness:0.2}); 
                    
                    // Central Armored Core
                    const core = new THREE.Mesh(new THREE.DodecahedronGeometry(size*0.5), matTerra);
                    visuals.add(core);

                    // Massive Side Wheels (The "Steamroller" look)
                    const wheelGeo = new THREE.CylinderGeometry(size*0.55, size*0.55, size*0.3, 16);
                    wheelGeo.rotateZ(Math.PI/2); // Flip sideways
                    
                    const wL = new THREE.Mesh(wheelGeo, matDark);
                    wL.position.x = size*0.5;
                    visuals.add(wL);
                    
                    const wR = new THREE.Mesh(wheelGeo, matDark);
                    wR.position.x = -size*0.5;
                    visuals.add(wR);

                    // Reinforced Wheel Hubcaps
                    const hubL = new THREE.Mesh(new THREE.CylinderGeometry(size*0.2, size*0.3, 0.1, 6), matTerra);
                    hubL.rotation.z = -Math.PI/2; hubL.position.x = size*0.66;
                    visuals.add(hubL);
                    
                    const hubR = hubL.clone();
                    hubR.rotation.z = Math.PI/2; hubR.position.x = -size*0.66;
                    visuals.add(hubR);

                    // Front Sensor Array (The "Head")
                    const head = new THREE.Mesh(new THREE.BoxGeometry(size*0.5, size*0.4, size*0.5), matTerra);
                    head.position.set(0, size*0.3, -size*0.4);
                    visuals.add(head);
                    
                    const eye = new THREE.Mesh(new THREE.BoxGeometry(size*0.3, 0.1, 0.1), new THREE.MeshBasicMaterial({color:0x00ff00}));
                    eye.position.set(0, size*0.3, -size*0.66);
                    visuals.add(eye);
                }
            }

            // =========================================================
            // GROUP 4: MOAB (The 5 Apocalyptic Riders)
            // =========================================================
            else if (isMoab) {
                
                // 1. MOAB: SIEGE WALKER (Heavy Mech)
                if (type === 'siege walker') {
                    // Main Torso (Hunched)
                    const torso = new THREE.Mesh(new THREE.BoxGeometry(size*0.8, size*0.6, size*0.7), matDark);
                    torso.position.y = size*0.4; visuals.add(torso);
                    
                    // Cockpit (Glowing Slit)
                    const cockpit = new THREE.Mesh(new THREE.BoxGeometry(size*0.4, size*0.15, size*0.1), matRed);
                    cockpit.position.set(0, size*0.5, size*0.36); visuals.add(cockpit);
                    
                    // Heavy Legs
                    const legGeo = new THREE.BoxGeometry(size*0.3, size*0.9, size*0.4);
                    const legL = new THREE.Mesh(legGeo, matBody); legL.position.set(size*0.35, -size*0.1, 0); visuals.add(legL);
                    const legR = legL.clone(); legR.position.set(-size*0.35, -size*0.1, 0); visuals.add(legR);
                    
                    // Shoulder Cannons
                    const cannon = new THREE.Mesh(new THREE.CylinderGeometry(size*0.1, size*0.1, size*0.8), matBlack);
                    cannon.rotation.x = Math.PI/2; cannon.position.set(size*0.5, size*0.7, 0); visuals.add(cannon);
                    const cannon2 = cannon.clone(); cannon2.position.set(-size*0.5, size*0.7, 0); visuals.add(cannon2);
                }
                
                // 2. BFB: DREADNOUGHT (Floating Fortress)
                else if (type === 'dreadnought') {
                    // Main Hull (Elongated Hexagon)
                    const hull = new THREE.Mesh(new THREE.CylinderGeometry(size*0.8, size*1.0, size*0.3, 6), matBlack);
                    visuals.add(hull);
                    // Bridge
                    const bridge = new THREE.Mesh(new THREE.BoxGeometry(size*0.4, size*0.3, size*0.6), matDark);
                    bridge.position.y = size*0.25; visuals.add(bridge);
                    // Engine Pods
                    const podGeo = new THREE.CylinderGeometry(size*0.3, size*0.2, size*1.2, 8); podGeo.rotateX(Math.PI/2);
                    const podL = new THREE.Mesh(podGeo, matBody); podL.position.x = size*0.9; visuals.add(podL);
                    const podR = podL.clone(); podR.position.x = -size*0.9; visuals.add(podR);
                    // Exhausts
                    const thrust = new THREE.Mesh(new THREE.SphereGeometry(size*0.15), matRed);
                    thrust.position.set(size*0.9, 0, size*0.6); visuals.add(thrust);
                    const thrust2 = thrust.clone(); thrust2.position.set(-size*0.9, 0, size*0.6); visuals.add(thrust2);
                }
                
                // 3. ZOMG: THE OBLITERATOR (Geometric God)
                else if (type === 'the obliterator') {
                    // The Core (Burning Sun)
                    const core = new THREE.Mesh(new THREE.IcosahedronGeometry(size*0.6, 1), new THREE.MeshBasicMaterial({color:0x00ff00}));
                    visuals.add(core);
                    // Inner Ring
                    const r1 = new THREE.Mesh(new THREE.TorusGeometry(size*0.9, size*0.1, 4, 6), matBlack);
                    r1.rotation.x = Math.PI/4; visuals.add(r1);
                    // Outer Spikes
                    for(let i=0; i<8; i++) {
                        const spike = new THREE.Mesh(new THREE.ConeGeometry(size*0.1, size*1.5, 4), matDark);
                        const angle = (i/8) * Math.PI * 2;
                        spike.position.set(Math.cos(angle)*size, 0, Math.sin(angle)*size);
                        spike.lookAt(0,0,0); spike.rotateX(-Math.PI/2);
                        visuals.add(spike);
                    }
                    // Vertical Ring
                    const r2 = new THREE.Mesh(new THREE.TorusGeometry(size*1.2, size*0.05, 4, 32), matRed);
                    r2.rotation.y = Math.PI/2; visuals.add(r2);
                }

                // 4. DDT: VOID STALKER (Stealth Shark) - NEW!
                else if (type === 'void stalker') {
                    // Sleek Main Body
                    const body = new THREE.Mesh(new THREE.ConeGeometry(size*0.4, size*2.0, 4), matBlack);
                    body.rotation.x = -Math.PI/2; 
                    body.scale.set(1, 0.5, 1); // Flattened profile
                    visuals.add(body);

                    // Forward Swept Blades (Wings)
                    const wingGeo = new THREE.BoxGeometry(size*0.8, 0.05, size*0.6);
                    const wL = new THREE.Mesh(wingGeo, matDark);
                    wL.position.set(size*0.6, 0, size*0.2); wL.rotation.y = -0.5; visuals.add(wL);
                    const wR = wL.clone();
                    wR.position.set(-size*0.6, 0, size*0.2); wR.rotation.y = 0.5; visuals.add(wR);

                    // Rear Thrusters (Blue Ion Glow for speed)
                    const engine = new THREE.Mesh(new THREE.BoxGeometry(size*0.6, 0.1, 0.2), matCyan);
                    engine.position.set(0, 0, size*1.0);
                    visuals.add(engine);
                }

                // 5. BAD: ENTROPY MONOLITH (Final Boss) - NEW!
                else if (type === 'entropy monolith') {
                    // The Monolith (Giant Floating Obelisk)
                    const tower = new THREE.Mesh(new THREE.CylinderGeometry(size*0.6, size*0.9, size*2.5, 4), matBody);
                    visuals.add(tower);

                    // Floating Shield Generators (4 Cubes orbiting)
                    for(let i=0; i<4; i++) {
                        const shield = new THREE.Mesh(new THREE.BoxGeometry(size*0.5, size*0.5, size*0.5), matDark);
                        const angle = (i/4) * Math.PI * 2;
                        shield.position.set(Math.cos(angle)*size*1.5, 0, Math.sin(angle)*size*1.5);
                        // Add glow core to shields
                        const core = new THREE.Mesh(new THREE.BoxGeometry(size*0.2, size*0.2, size*0.2), new THREE.MeshBasicMaterial({color:0x8e44ad}));
                        shield.add(core);
                        visuals.add(shield);
                    }

                    // The Eye of Doom (Top)
                    const eye = new THREE.Mesh(new THREE.SphereGeometry(size*0.4), new THREE.MeshBasicMaterial({color:0xff00ff})); // Magenta Eye
                    eye.position.y = size*1.0;
                    visuals.add(eye);
                    
                    // Dark Halo
                    const halo = new THREE.Mesh(new THREE.TorusGeometry(size*1.2, 0.1, 4, 32), matBlack);
                    halo.rotation.x = Math.PI/2; halo.position.y = size*1.0;
                    visuals.add(halo);
                }
            }

            // =========================================================
            // GROUP 5: SPECIAL (Redesigned: High-Tech Cyber Units)
            // =========================================================
            else if (isSpecial) {
                
                // --- HEALER: SERAPHIM DRONE (Floating Medic) ---
                if (type === 'healer') {
                    // Main Body (Clean White Capsule)
                    const body = new THREE.Mesh(new THREE.CylinderGeometry(size*0.4, size*0.4, size*1.2, 16, 1), matChrome);
                    body.rotation.x = Math.PI/2;
                    visuals.add(body);
                    
                    // Medical Cross (Glowing Green on top)
                    const vBar = new THREE.Mesh(new THREE.BoxGeometry(size*0.3, size*0.8, size*0.1), new THREE.MeshBasicMaterial({color:0x00ff00}));
                    vBar.position.y = size*0.35;
                    visuals.add(vBar);
                    const hBar = new THREE.Mesh(new THREE.BoxGeometry(size*0.8, size*0.3, size*0.1), new THREE.MeshBasicMaterial({color:0x00ff00}));
                    hBar.position.y = size*0.35;
                    visuals.add(hBar);

                    // Holographic Halo (Floating Ring)
                    const halo = new THREE.Mesh(new THREE.TorusGeometry(size*0.8, 0.05, 4, 32), new THREE.MeshBasicMaterial({color:0x00ff00, transparent:true, opacity:0.6}));
                    halo.rotation.x = Math.PI/2;
                    visuals.add(halo); // You can rotate this in animate() if you want extra flair
                    
                    // Engine Thrusters (4 small vents)
                    for(let i=0; i<4; i++) {
                        const thruster = new THREE.Mesh(new THREE.ConeGeometry(0.15, 0.4, 8), matDark);
                        thruster.rotation.x = -Math.PI/2;
                        const a = (i/4)*Math.PI*2 + Math.PI/4;
                        thruster.position.set(Math.cos(a)*size*0.5, 0, Math.sin(a)*size*0.5);
                        visuals.add(thruster);
                    }
                }
                
                // --- DISRUPTOR: TESLA STAR (Chaotic Jammer) ---
                else if (type === 'disruptor') {
                    // Core: Unstable Icosahedron
                    const core = new THREE.Mesh(new THREE.IcosahedronGeometry(size*0.4, 0), matGlow);
                    visuals.add(core);
                    
                    // Spikes: Long jagged antennas
                    for(let i=0; i<6; i++) {
                        const spike = new THREE.Mesh(new THREE.ConeGeometry(0.05, size*1.8, 4), matDark);
                        // Random rotations for chaotic look
                        spike.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, 0);
                        visuals.add(spike);
                    }
                    
                    // Gyro Rings (The "Atom" look)
                    const r1 = new THREE.Mesh(new THREE.TorusGeometry(size*0.9, 0.03, 4, 32), matCyan);
                    r1.rotation.x = 1.0;
                    visuals.add(r1);
                    
                    const r2 = new THREE.Mesh(new THREE.TorusGeometry(size*0.7, 0.03, 4, 32), matCyan);
                    r2.rotation.y = 1.0;
                    visuals.add(r2);
                }
                
                // --- SUMMONER: RIFT CARRIER (Mothership) ---
                else if (type === 'summoner') {
                    // Main Engine Block (Rear)
                    const engine = new THREE.Mesh(new THREE.BoxGeometry(size*1.0, size*0.6, size*0.8), matDark);
                    engine.position.z = size*0.8;
                    visuals.add(engine);
                    
                    // V-Shape Hull (Twin Prongs)
                    const lProng = new THREE.Mesh(new THREE.BoxGeometry(size*0.4, size*0.2, size*2.2), matBody);
                    lProng.position.set(-size*0.7, 0, -size*0.2);
                    lProng.rotation.y = 0.15; // Angled inward
                    visuals.add(lProng);
                    
                    const rProng = lProng.clone();
                    rProng.position.set(size*0.7, 0, -size*0.2);
                    rProng.rotation.y = -0.15;
                    visuals.add(rProng);
                    
                    // The Void Portal (Held between prongs)
                    const orb = new THREE.Mesh(new THREE.DodecahedronGeometry(size*0.45), new THREE.MeshBasicMaterial({color:0x8e44ad, wireframe:true}));
                    visuals.add(orb);
                    
                    const innerVoid = new THREE.Mesh(new THREE.SphereGeometry(size*0.25), new THREE.MeshBasicMaterial({color:0x000000}));
                    visuals.add(innerVoid);
                    
                    // Landing Lights
                    const light = new THREE.Mesh(new THREE.SphereGeometry(0.1), matRed);
                    light.position.set(size*0.8, size*0.2, -size*1.2);
                    visuals.add(light);
                    const light2 = light.clone();
                    light2.position.set(-size*0.8, size*0.2, -size*1.2);
                    visuals.add(light2);
                }
            }

            group.traverse(o => { if(o.isMesh) { o.castShadow = true; o.receiveShadow = true; } });
            return group;
        }

        // --- WAVE LOGIC ---
	function startWave() {
            // If in MP, ask server to start
            if(socket && myRoomId) {
                if(myRole === 'host') {
                    socket.emit('requestWave', myRoomId);
                }
                return;
            }
            
            // Single Player Logic (Keep existing logic)
            runWaveLogic();
        }

        // The actual logic (moved to a new function)
        function runWaveLogic() {
            if(activeWave) return;
            wave++; 
            activeWave = true;
            spawningFinished = false;
            
            // ✅ CRITICAL: Track wave completion for achievements
            if (typeof window.trackWaveCompleted === 'function') {
                window.trackWaveCompleted(wave);
            }
            
            // Notify CrazyGames that gameplay started
            notifyGameplayStart();
            
            // Show midgame ad every 5 waves (DISABLED - ad-free version)
            // if (wave > 1 && wave % 5 === 0) {
            //     showIntermissionAd();
            // }
            
            const btn = document.getElementById('btn-start-wave');
            btn.disabled = true; btn.innerText = "IN PROGRESS..."; btn.style.backgroundColor = "#555";
            updateUI();
            
            const wavePlan = getWaveData(wave);
            let groupIndex = 0;
            let enemiesInGroup = wavePlan[0].count;
            
            function spawnLoop() {
                if(!activeWave) return;
                if(isPaused || !gameRunning) { setTimeout(spawnLoop, 100); return; }

                spawnEnemy(wavePlan[groupIndex].type);
                enemiesInGroup--;

                if(enemiesInGroup <= 0) {
                    groupIndex++;
                    if(groupIndex >= wavePlan.length) {
                        spawningFinished = true;
                        return;
                    }
                    enemiesInGroup = wavePlan[groupIndex].count;
                }
                setTimeout(spawnLoop, wavePlan[groupIndex].interval);
            }
            spawnLoop();
        }

        // --- INTERACTION ---
        function onMD(e) {
            if (e.button === 1) { isPanning = true; panStart.set(e.clientX, e.clientY); return; } // Middle click
            onClick(e); // Pass event
        }
        function onMU(e) { if(e.button===1) isPanning = false; }
        
        function onMM(e) {
            if(!gameRunning) return;
            if (isPanning) {
                const dx = (e.clientX - panStart.x) * 0.1;
                const dy = (e.clientY - panStart.y) * 0.1;
                camera.position.x -= dx;
                camera.position.z -= dy;
                panStart.set(e.clientX, e.clientY);
                return;
            }
            
            mouse.x = (e.clientX/window.innerWidth)*2-1; mouse.y = -(e.clientY/window.innerHeight)*2+1;
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(mapProps);
            for(let h of hits) {
                if(h.object.geometry instanceof THREE.PlaneGeometry && h.point.y < 1) {
                    const x = Math.round(h.point.x/GRID_SIZE)*GRID_SIZE;
                    const z = Math.round(h.point.z/GRID_SIZE)*GRID_SIZE;
                    hoverMesh.position.set(x, 0.25, z);
                    if(selectedType) {
                        rangeRing.position.set(x, 0.5, z);
                        hoverMesh.material.color.setHex(canBuild(x,z) ? 0x3498db : 0xe74c3c);
                        
                        // Show dead zone for mortar
                        if(TOWERS[selectedType].minRange) {
                            deadZoneRing.visible = true;
                            deadZoneRing.position.set(x, 0.51, z);
                            deadZoneRing.scale.set(TOWERS[selectedType].minRange, TOWERS[selectedType].minRange, 1);
                        } else {
                            deadZoneRing.visible = false;
                        }
                    }
                    break;
                }
            }
        }

        function onClick(e) {
            if(!gameRunning || lives<=0 || isPaused) return;

            if(e.button === 2) { deselectAll(); return; } // Right click
            if(e.button !== 0) return; // Only Left click

            // 1. Check for clicking EXISTING towers (Select)
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(scene.children, true);
            let clicked = null;
            for(let h of hits) {
                let p = h.object; while(p.parent&&p.parent!==scene) p=p.parent;
                const t = towers.find(tow => tow.mesh===p);
                if(t) { clicked=t; break; }
            }
            if(clicked) {
                document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
                selectedTower = clicked; 
                selectedType = null;
                rangeRing.visible=true; 
                rangeRing.position.copy(clicked.mesh.position); 
                rangeRing.position.y=0.5; 
                rangeRing.scale.set(clicked.range,clicked.range,1);
                
                // Show dead zone for mortar
                if(clicked.minRange) {
                    deadZoneRing.visible = true;
                    deadZoneRing.position.copy(clicked.mesh.position);
                    deadZoneRing.position.y = 0.51;
                    deadZoneRing.scale.set(clicked.minRange, clicked.minRange, 1);
                } else {
                    deadZoneRing.visible = false;
                }
                
                updateInspect(); 
                return;
            }
            
            // 2. BUILD LOGIC
            if(selectedType) {
                const x = hoverMesh.position.x; const z = hoverMesh.position.z;
                
                // ANTI-SPAM: Prevent double-charging bug
                const now = Date.now();
                if(now - lastSpendTime < 100) return; // 100ms cooldown between builds
                
                // CHECK: Can we build here?
                if(canBuild(x,z)) {
                    const data = TOWERS[selectedType];
                    const cost = Math.floor(data.cost * GAME_CONFIG.costMult);
                    
                    // CHECK: Money
                    const myGold = (currentGamemode === 'separate' && socket) ? playerWallets[myPlayerIndex] : gold;
                    if(myGold < cost) {
                        showLocalError("INSUFFICIENT FUNDS");
                        return;
                    }

                    // CHECK: Farm Limit
                    if(selectedType === 'farm') {
                        const MAX_FARMS = 5;
                        let farmCount = 0;
                        if(currentGamemode === 'separate') {
                            // Count ONLY my farms
                            farmCount = towers.filter(t => t.type === 'farm' && t.ownerIndex === myPlayerIndex).length;
                        } else {
                            // Shared/Single: Count ALL farms
                            farmCount = towers.filter(t => t.type === 'farm').length;
                        }

                        if(farmCount >= MAX_FARMS) {
                            showLocalError(`MAX FARMS REACHED (${MAX_FARMS})`);
                            return;
                        }
                    }

                    // --- EXECUTE BUILD ---
                    // ANTI-SPAM: Mark spend time
                    lastSpendTime = now;
                    
                    // Deduct Money
                    if(currentGamemode === 'separate') {
                        playerWallets[myPlayerIndex] -= cost;
                        lastSpendTime = Date.now(); 
                        
                        // FIX: Update visual 'gold' immediately for EVERYONE, not just Host
                        gold = playerWallets[myPlayerIndex]; 
                    } else {
                        gold -= cost;
                    }
                    
                    AudioSys.click();

                    if(socket && myRoomId) {
                        socket.emit('gameAction', { 
                            roomId: myRoomId, type: 'build', key: selectedType, 
                            x: x, z: z, pIndex: myPlayerIndex 
                        });
                    }

                    // Local Build
                    const mesh = createTowerModel(selectedType, 1);
                    mesh.position.set(x, 0, z);
                    scene.add(mesh);
                    createParticles(mesh.position, 10, 0xcccccc);

                    towers.push({ 
                        mesh, 
                        ...JSON.parse(JSON.stringify(data)), 
                        type: selectedType, 
                        level: 1, 
                        cooldown: 0,
                        destroys: 0, // Initialize destroy counter
                        ownerRole: (socket && myRoomId) ? myRole : 'host',
                        ownerIndex: myPlayerIndex,
                        totalGenerated: 0 // <--- NEW: Init Farm Stats
                    });
                    
                    
                    // Achievement tracking
                    trackTowerBuild();
                    
                    // Track tower built for challenges
                    if (typeof window.trackTowerBuilt === 'function') {
                        window.trackTowerBuilt();
                    }
                    
                    // Deduct from local display immediately to feel responsive
                    updateUI();
                } else {
                    // Cannot build here (Red square)
                    showLocalError("CANNOT BUILD HERE");
                }
            }
        }

function canBuild(x, z) {
            const p = new THREE.Vector3(x,0,z);

            // 1. Check distance to other towers (prevent stacking)
            if(towers.some(t => t.mesh.position.distanceTo(p) < 3)) return false;

            // 2. Check distance to the road path
            for(let i=0; i<currentWaypoints.length-1; i++) {
                const a = currentWaypoints[i], b = currentWaypoints[i+1];
                // Math to find the closest point on the line segment
                const t = Math.max(0, Math.min(1, ((p.x-a.x)*(b.x-a.x)+(p.z-a.z)*(b.z-a.z)) / a.distanceToSquared(b)));
                const proj = new THREE.Vector3().copy(a).add(new THREE.Vector3().subVectors(b,a).multiplyScalar(t));
                
                // 3.5 is the radius from the road center
                if(p.distanceTo(proj) < 3.5) return false;
            }

            // 3. NEW: Check Environment Obstacles (Trees, Rocks, Cave, Base)
            // We filter mapProps for "Group" types, which are the 3D decor objects
            const obstacleCollision = mapProps.some(obj => {
                if (obj.type === 'Group') {
                    // Check if we are within 4 units of a tree/rock
                    return obj.position.distanceTo(p) < 4.0; 
                }
                return false;
            });

            if (obstacleCollision) return false;

            return true;
        }

        // =====================================================
        // MODERN TOWER UI FUNCTIONS
        // =====================================================
        
        let currentTowerCategory = 'all';
        let currentSearchTerm = '';
        
        // Populate tower grid
        function populateTowerGrid() {
            const grid = document.getElementById('tower-grid');
            if (!grid) return;
            
            grid.innerHTML = '';
            let visibleCount = 0;
            
            Object.keys(TOWERS).forEach((k, index) => {
                const t = TOWERS[k];
                const cost = Math.floor(t.cost * GAME_CONFIG.costMult);
                
                // Filter by category
                if (currentTowerCategory !== 'all' && t.category !== currentTowerCategory) {
                    return;
                }
                
                // Filter by search
                if (currentSearchTerm && !t.name.toLowerCase().includes(currentSearchTerm.toLowerCase())) {
                    return;
                }
                
                visibleCount++;
                
                const btn = document.createElement('div');
                btn.className = 'tower-btn';
                btn.dataset.tower = k;
                btn.dataset.category = t.category;
                
                // Check if tower is unlocked (only in singleplayer or if not in a game)
                const isUnlocked = !window.unlockedTowers || !window.towerUnlockLevels || window.unlockedTowers.includes(k);
                const unlockLevel = window.towerUnlockLevels ? window.towerUnlockLevels[k] : 1;
                
                // Check if affordable
                if (cost > gold || !isUnlocked) {
                    btn.classList.add('disabled');
                }
                
                // Show unlock level for locked towers
                let costDisplay = isUnlocked 
                    ? `<div class="tower-cost ${cost > gold ? 'expensive' : ''}">$${cost}</div>`
                    : `<div class="tower-cost" style="color: #e67e22;">UNLOCKS LVL ${unlockLevel}</div>`;
                
                btn.innerHTML = `
                    ${t.hotkey ? `<div class="tower-hotkey">${t.hotkey}</div>` : ''}
                    <img src="${TOWER_ICONS[k]}" class="tower-preview" style="${!isUnlocked ? 'filter: grayscale(1) brightness(0.5);' : ''}">
                    <div class="tower-info">
                        <div class="tower-name">${t.name}</div>
                        ${costDisplay}
                    </div>
                `;
                
                btn.onclick = (e) => { 
                    e.stopPropagation(); 
                    if (cost <= gold && isUnlocked) {
                        playClick(); 
                        selectTool(k, btn); 
                    }
                };
                
                grid.appendChild(btn);
            });
            
            // Update counter
            const counter = document.getElementById('tower-count');
            if (counter) {
                const total = Object.keys(TOWERS).length;
                counter.textContent = `${visibleCount} / ${total}`;
            }
            
            // Show empty state if no towers
            const emptyState = document.getElementById('tower-empty-state');
            if (emptyState) {
                emptyState.style.display = visibleCount === 0 ? 'block' : 'none';
            }
        }
        
        // Filter by category
        function filterTowerCategory(category) {
            currentTowerCategory = category;
            
            // Update tab styles
            document.querySelectorAll('.category-tab').forEach(tab => {
                tab.classList.remove('active');
                if (tab.dataset.category === category) {
                    tab.classList.add('active');
                }
            });
            
            populateTowerGrid();
        }
        
        // Search towers
        function searchTowers() {
            const searchInput = document.getElementById('tower-search');
            if (!searchInput) return;
            
            currentSearchTerm = searchInput.value;
            populateTowerGrid();
        }
        
        // Keyboard shortcuts for tower selection
        document.addEventListener('keydown', (e) => {
            if (!gameRunning || isPaused) return;
            
            // Don't trigger if typing in search
            if (document.activeElement.id === 'tower-search') return;
            
            // Number keys 0-9 for tower hotkeys
            const key = e.key;
            Object.keys(TOWERS).forEach(k => {
                const t = TOWERS[k];
                if (t.hotkey === key) {
                    const cost = Math.floor(t.cost * GAME_CONFIG.costMult);
                    const isUnlocked = !window.unlockedTowers || !window.towerUnlockLevels || window.unlockedTowers.includes(k);
                    if (cost <= gold && isUnlocked) {
                        const btn = document.querySelector(`.tower-btn[data-tower="${k}"]`);
                        if (btn && !btn.classList.contains('disabled')) {
                            playClick();
                            selectTool(k, btn);
                        }
                    }
                }
            });
        });

        function selectTool(k, el) {
            if(selectedType === k) {
                deselectAll();
                return;
            }
            selectedType = k; selectedTower = null;
            rangeRing.visible=true; rangeRing.scale.set(TOWERS[k].range, TOWERS[k].range, 1);
            
            // Show dead zone for mortar
            if(TOWERS[k].minRange) {
                deadZoneRing.visible = true;
                deadZoneRing.scale.set(TOWERS[k].minRange, TOWERS[k].minRange, 1);
            } else {
                deadZoneRing.visible = false;
            }
            
            document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            el.classList.add('selected');
            document.getElementById('inspect-panel').style.display='none';
        }

        function deselectAll() { 
            selectedType=null; 
            selectedTower=null; 
            rangeRing.visible=false;
            deadZoneRing.visible=false; // Hide dead zone too
            document.querySelectorAll('.tower-btn').forEach(b => b.classList.remove('selected'));
            document.getElementById('inspect-panel').style.display='none'; 
        }
        
        function upgradeTower(branch = null) {
            const t = selectedTower; if(!t) return;
            
            // --- NEW: Calculate Cost based on Branch ---
            let cost = 0;
            if(t.level === 4 && branch) {
                // If it's a Level 5 upgrade, get the SPECIFIC price from the object
                const basePrice = TOWER_UPGRADES[t.type][branch].cost;
                // Apply difficulty multiplier (Easy/Hard mode scaling)
                cost = Math.floor(basePrice * GAME_CONFIG.costMult); 
            } else {
                // Standard 1-4 Scaling logic
                cost = Math.floor((t.cost * GAME_CONFIG.costMult) * (t.level + 0.5));
            }

            if(gold >= cost && t.level < MAX_LEVEL) {
                gold -= cost; 
                
                // Multiplayer Wallet Logic
                if(currentGamemode === 'separate') {
    // Subtract from my specific wallet
    playerWallets[myPlayerIndex] -= cost;
    
    // If I am the host, update the main display gold immediately
    if(myRole === 'host') gold = playerWallets[0];
    
    // FIX: Sync wallet updates to all players after tower purchase
    if(socket && myRoomId) {
        socket.emit('gameAction', { 
            type: 'wallet_update', 
            roomId: myRoomId, 
            wallets: playerWallets,
            gold: gold,
            mode: currentGamemode
        });
    }
}

                t.level++;
                
                // Track upgrade for challenges
                if (typeof window.sessionStats !== 'undefined') {
                    window.sessionStats.upgrades = (window.sessionStats.upgrades || 0) + 1;
                    if (typeof window.updateChallengeProgress === 'function') {
                        window.updateChallengeProgress('upgrades', window.sessionStats.upgrades);
                    }
                }
                
                // --- APPLY UPGRADE STATS ---
                if(t.level === 5 && branch) {
                    t.branch = branch; // Save the choice!
                    
                    // Safety check: Ensure upgrades exist
                    if(TOWER_UPGRADES[t.type] && TOWER_UPGRADES[t.type][branch]) {
                        const stats = TOWER_UPGRADES[t.type][branch];
                        
                        t.dmg *= stats.dmgMult || 1;
                        t.range *= stats.rangeMult || 1;
                        t.rate *= stats.rateMult || 1;
                        
                        if(stats.splash) t.splash = stats.splash;
                        if(stats.special) t.special = stats.special;
                        
                        // Overrides
                        if(t.type === 'tesla') {
                            if(stats.chainAdd) t.chain += stats.chainAdd;
                            if(stats.chainSet) t.chain = stats.chainSet;
                        }
                        if(t.type === 'farm') {
                            if(stats.incomeAdd) t.income += stats.incomeAdd;
                        }
                        if(t.type === 'ice') {
                            if(stats.slowAdd) t.slow += stats.slowAdd;
                        }
                        
                        // Change bullet color to match theme
                        t.color = stats.color; 
                    }
                } else {
                    // Standard 1-4 Scaling
                    t.dmg *= 1.5;
                    t.range *= 1.1;
                    t.rate *= 0.9;
                    if(t.type === 'farm') t.income += 30;
                    if(t.type === 'tesla' && t.level%2===0) t.chain++;
                    
                    // Ice/Tesla special scaling
                    if(t.type === 'ice') { t.slow += 0.1; t.stunChance += 0.05; t.stunDur += 0.2; }
                    if(t.type === 'tesla' && t.level % 2 === 0) { t.chain += 1; }
                }

                // MP Sync
                if(socket && myRoomId) {
                    socket.emit('gameAction', { 
                           roomId: myRoomId, 
                           type: 'upgrade', 
                           key: selectedType, 
                           x: t.mesh.position.x, 
                           z: t.mesh.position.z,
                           playerRole: myRole,
                           branch: branch 
                    });
                }

                AudioSys.click();
                
                // Rebuild Mesh
                scene.remove(t.mesh);
                const oldPos = t.mesh.position.clone();
                const oldRot = t.mesh.children[1].rotation.clone();
                
                // PASS THE BRANCH TO THE MODEL GENERATOR
                t.mesh = createTowerModel(t.type, t.level, t.branch); 
                
                t.mesh.position.copy(oldPos);
                t.mesh.children[1].rotation.copy(oldRot);
                scene.add(t.mesh);
                
                rangeRing.scale.set(t.range, t.range, 1);
                
                if(typeof unlockTowerLevel === 'function') unlockTowerLevel(t.type, t.level);
                updateUI(); updateInspect();
            }
        }

        function sellTower() {
            const t = selectedTower; if(!t) return;
            
            // Calculate Sell Price
            const sellPrice = Math.floor((t.cost * GAME_CONFIG.costMult * t.level) * 0.6);
            
            // Economy Logic (UPDATED FOR 4 PLAYERS)
            if(currentGamemode === 'shared') {
                gold += sellPrice;
            } else {
                // Refund to the specific owner
                if(typeof t.ownerIndex !== 'undefined') {
                    playerWallets[t.ownerIndex] += sellPrice;
                    
                    // Update my display if I own it
                    if(t.ownerIndex === myPlayerIndex) {
                        gold = playerWallets[myPlayerIndex];
                    }
                }
            }

            AudioSys.click();
            
            // FIX: Sync wallet updates after selling
            if(socket && myRoomId && currentGamemode === 'separate') {
                socket.emit('gameAction', { 
                    type: 'wallet_update', 
                    roomId: myRoomId, 
                    wallets: playerWallets,
                    gold: gold,
                    mode: currentGamemode
                });
            }
            
            // Sync Selling
            if(socket && myRoomId) {
                socket.emit('gameAction', { 
                    type: 'sell', 
                    roomId: myRoomId, 
                    x: t.mesh.position.x, 
                    z: t.mesh.position.z 
                });
            }

            scene.remove(t.mesh); 
            towers = towers.filter(x => x !== t);
            deselectAll(); 
            updateUI();
        }

        function createFloatingText(text, pos, color) {
            const canvas = document.createElement('canvas'); 
            const ctx = canvas.getContext('2d');
            canvas.width=128; canvas.height=64; 
            ctx.font="Bold 40px Arial"; 
            ctx.fillStyle=color; 
            ctx.textAlign="center"; 
            ctx.strokeStyle="black"; 
            ctx.lineWidth=4;
            ctx.strokeText(text,64,48); 
            ctx.fillText(text,64,48);
            
            const tex = new THREE.CanvasTexture(canvas);
            const mat = new THREE.SpriteMaterial({map:tex, transparent:true});
            const sprite = new THREE.Sprite(mat);
            sprite.position.copy(pos); 
            sprite.scale.set(6,3,1);
            
            scene.add(sprite);
            particles.push({ mesh: sprite, life: 1.5, type: 'floating_text', vel: new THREE.Vector3(0,0,0) });
        }

        function createParticles(pos, count, color) {
            const mat = new THREE.MeshBasicMaterial({color});
            const geo = new THREE.BoxGeometry(0.3, 0.3, 0.3);
            for(let i=0; i<count; i++) {
                const m = new THREE.Mesh(geo, mat);
                m.position.copy(pos); m.position.x += (Math.random()-0.5)*2; m.position.z += (Math.random()-0.5)*2;
                scene.add(m);
                particles.push({ mesh: m, vel: new THREE.Vector3((Math.random()-0.5), Math.random()*0.5, (Math.random()-0.5)), life: 0.5 });
            }
        }

        // --- NEW VFX SYSTEMS ---
        
        // 1. Muzzle Flash (Bright expand/fade at barrel)
        function createMuzzleFlash(pos, color) {
            if(graphicsMode === 0) return; // Skip on Low settings
            
            const geo = new THREE.PlaneGeometry(1.5, 1.5);
            const mat = new THREE.MeshBasicMaterial({
                color: color, 
                transparent: true, 
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const mesh = new THREE.Mesh(geo, mat);
            mesh.position.copy(pos);
            mesh.lookAt(camera.position); // Billboard
            mesh.rotation.z = Math.random() * Math.PI; // Random rotation
            
            scene.add(mesh);
            
            // Flash is very short-lived
            particles.push({ 
                mesh: mesh, 
                life: 0.08, 
                type: 'flash',
                onUpdate: (p, dt) => {
                    p.mesh.scale.multiplyScalar(1.2); // Expand
                    p.mesh.material.opacity -= dt * 10; // Fade fast
                }
            });
        }

        // 2. Impact Sparks (Directional spray)
        function createImpact(pos, color, count=5) {
            if(graphicsMode === 0) return;
            
            const geo = new THREE.BoxGeometry(0.15, 0.15, 0.4);
            const mat = new THREE.MeshBasicMaterial({ color: color });
            
            for(let i=0; i<count; i++) {
                const m = new THREE.Mesh(geo, mat);
                m.position.copy(pos);
                m.lookAt(pos.clone().add(new THREE.Vector3(Math.random()-0.5, Math.random(), Math.random()-0.5)));
                scene.add(m);
                
                particles.push({
                    mesh: m,
                    life: 0.3 + Math.random() * 0.2,
                    vel: new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.5, (Math.random()-0.5)*0.5),
                    isPhysics: true // Use gravity logic
                });
            }
        }

        // 3. Upgraded Explosion (Ring + Debris)
        function createExplosion(pos, color, radius) {
            addTrauma(0.4);
            AudioSys.noise(0.5, 0.4, 600); 

            // A. The Core Sphere (Flash) - Brighter and bigger
            const sphere = new THREE.Mesh(
                new THREE.SphereGeometry(radius * 1.2, 16, 16), 
                new THREE.MeshBasicMaterial({ 
                    color: color, 
                    transparent: true, 
                    opacity: 1.0 
                })
            );
            sphere.position.copy(pos);
            scene.add(sphere);
            particles.push({ mesh: sphere, life: 0.3, type: 'expand_fade' });

            // B. The Shockwave Ring
            if(graphicsMode > 0) {
                const ring = new THREE.Mesh(
                    new THREE.RingGeometry(0.1, 0.5, 32),
                    new THREE.MeshBasicMaterial({ 
                        color: color, 
                        transparent: true, 
                        opacity: 0.8, 
                        side: THREE.DoubleSide 
                    })
                );
                ring.position.copy(pos);
                ring.rotation.x = -Math.PI/2;
                scene.add(ring);
                
                particles.push({ 
                    mesh: ring, 
                    life: 0.4, 
                    type: 'shockwave',
                    maxSize: radius * 3.0 
                });
                
                // C. NEW: Fire particles shooting outward
                if(graphicsMode === 2) {
                    for(let i=0; i<12; i++) {
                        const angle = (i / 12) * Math.PI * 2;
                        const spark = new THREE.Mesh(
                            new THREE.BoxGeometry(0.3, 0.3, 0.8),
                            new THREE.MeshBasicMaterial({ color: 0xffaa00 })
                        );
                        spark.position.copy(pos);
                        spark.lookAt(
                            pos.x + Math.cos(angle),
                            pos.y,
                            pos.z + Math.sin(angle)
                        );
                        scene.add(spark);
                        
                        particles.push({
                            mesh: spark,
                            life: 0.4,
                            vel: new THREE.Vector3(
                                Math.cos(angle) * 0.5,
                                Math.random() * 0.3,
                                Math.sin(angle) * 0.5
                            )
                        });
                    }
                }
            }
        }
	
	function createShatter(pos, color, count) {
            for(let i=0; i<count; i++) {
                const size = 0.3 + Math.random() * 0.4;
                const geo = new THREE.BoxGeometry(size, size, size);
                const mat = new THREE.MeshBasicMaterial({ color: color });
                const mesh = new THREE.Mesh(geo, mat);
                
                mesh.position.copy(pos);
                // Random offset
                mesh.position.x += (Math.random() - 0.5);
                mesh.position.y += (Math.random() - 0.5);
                mesh.position.z += (Math.random() - 0.5);
                
                // Random rotation
                mesh.rotation.set(Math.random()*Math.PI, Math.random()*Math.PI, Math.random()*Math.PI);
                
                scene.add(mesh);
                
                // Add to particles array with physics
                particles.push({
                    mesh: mesh,
                    life: 1.0 + Math.random() * 0.5,
                    vel: new THREE.Vector3(
                        (Math.random() - 0.5) * 0.8,
                        Math.random() * 0.8 + 0.2, // Pop up
                        (Math.random() - 0.5) * 0.8
                    ),
                    rotVel: new THREE.Vector3(
                        (Math.random()-0.5) * 0.2,
                        (Math.random()-0.5) * 0.2,
                        (Math.random()-0.5) * 0.2
                    ),
                    isPhysics: true // Use gravity
                });
            }
            
            // Sync Shatter to Clients
            if(socket && myRoomId && myRole === 'host') {
                socket.emit('gameAction', { 
                    type: 'visual_effect', effect: 'shatter', roomId: myRoomId, 
                    x: pos.x, z: pos.z, color: color, count: count 
                });
            }
        }
	
	// Added 'color' parameter with default red
        function showLocalError(msg, color = '#e74c3c') {
            AudioSys.tone(150, 'sawtooth', 0.2, 0.2);

            const err = document.createElement('div');
            err.innerText = msg;
            err.style.position = 'absolute';
            err.style.color = color; // Use the custom color
            // ... (keep the rest of the styling logic below)
            err.style.fontFamily = 'Orbitron, sans-serif';
            err.style.fontWeight = 'bold';
            err.style.fontSize = '24px';
            err.style.top = '40%';
            err.style.left = '50%';
            err.style.transform = 'translate(-50%, -50%)';
            err.style.textShadow = '0 0 10px black';
            err.style.pointerEvents = 'none';
            err.style.zIndex = '2000';
            err.style.transition = 'all 1s ease';
            document.body.appendChild(err);

            setTimeout(() => {
                err.style.opacity = '0';
                err.style.transform = 'translate(-50%, -100%)';
            }, 50);

            setTimeout(() => err.remove(), 1000);
        }

	function balanceMapGrid() {
            // 1. Get the map list container
            const container = document.querySelector('#level-select .map-container');
            if(!container) return;
            
            // 2. Count the maps
            const cards = container.querySelectorAll('.map-card');
            const count = cards.length;
            if(count === 0) return;

            // 3. Calculate "Symmetrical" Columns
            // 9 maps -> 4.5 -> Ceil(4.5) = 5 columns (5 up, 4 down)
            // 10 maps -> 5 -> 5 columns (5 up, 5 down)
            // 11 maps -> 5.5 -> Ceil(5.5) = 6 columns (6 up, 5 down)
            const cols = Math.ceil(count / 2);
            
            // 4. Force the Width
            // Width = (cols * 240px card) + ((cols - 1) * 25px gap)
            // We add 20px padding just to be safe
            const targetWidth = (cols * 240) + ((cols - 1) * 25) + 20;
            
            container.style.maxWidth = targetWidth + 'px';
        }

        function updateUI() {
    document.getElementById('ui-gold').innerText = Math.floor(gold);
    document.getElementById('ui-lives').innerText = lives;
    document.getElementById('ui-wave').innerText = wave;

    // --- MULTIPLAYER PLAYER LIST ---
    if (socket && myRoomId && allPlayers.length > 0) {
        for (let i = 0; i < 4; i++) {
            const el = document.getElementById('info-p' + (i + 1));
            if (el) {
                if (i < allPlayers.length) {
                    el.style.display = 'flex';
                    const pName = allPlayers[i].name;
                    
                    // Show level for current player, "?" for others
                    const level = (i === myPlayerIndex && window.playerLevel) ? window.playerLevel : '?';
                    const levelBadge = `<span style="background: linear-gradient(135deg, #e67e22, #e74c3c); padding: 2px 6px; border-radius: 4px; font-size: 10px; margin-right: 5px;">LVL ${level}</span>`;
                    
                    // FIX: Explicitly check which variable to show
                    let displayGold = 0;
                    
                    if (currentGamemode === 'separate') {
                        // If it's ME, show my local 'gold' variable (which we synced above)
                        if (i === myPlayerIndex) {
                            displayGold = gold;
                        } else {
                            // If it's OTHERS, show the array value from the server
                            displayGold = playerWallets[i];
                        }
                    } else {
                        displayGold = gold; // Shared mode always uses global gold
                    }

                    const pColor = PLAYER_COLORS[i] || '#fff';
                    el.innerHTML = `${levelBadge}<span style="color:${pColor}">${pName}:</span> <span style="color:#f1c40f">$${Math.floor(displayGold)}</span>`;
                } else {
                    el.style.display = 'none';
                }
            }
        }
    }
      else {
        // Single Player
        document.getElementById('info-p1').innerHTML = `<span>You:</span> <span style="color:#f1c40f">$${Math.floor(gold)}</span>`;
        document.getElementById('info-p2').style.display = 'none';
        document.getElementById('info-p3').style.display = 'none';
        document.getElementById('info-p4').style.display = 'none';
    }

    if (selectedTower) updateInspect();
    
    // Update tower affordability in the grid
    document.querySelectorAll('.tower-btn').forEach(btn => {
        const towerKey = btn.dataset.tower;
        if (towerKey) {
            const cost = Math.floor(TOWERS[towerKey].cost * GAME_CONFIG.costMult);
            if (cost > gold) {
                btn.classList.add('disabled');
            } else {
                btn.classList.remove('disabled');
            }
            
            // Update cost display color
            const costEl = btn.querySelector('.tower-cost');
            if (costEl) {
                if (cost > gold) {
                    costEl.classList.add('expensive');
                } else {
                    costEl.classList.remove('expensive');
                }
            }
        }
    });
}

        function updateInspect() {
            if(!selectedTower) { 
                document.getElementById('inspect-panel').style.display = 'none'; 
                // Restore tower dock to previous state when inspect panel closes
                if(typeof dockOpen !== 'undefined' && dockOpen) {
                    const dock = document.getElementById('tower-dock');
                    dock.style.transform = "translateX(0)";
                }
                return; 
            }
            const p = document.getElementById('inspect-panel'); 
            p.style.display = 'block';
            
            // Close tower dock when inspect panel shows (but keep track of state)
            const dock = document.getElementById('tower-dock');
            if(typeof dockOpen !== 'undefined' && dockOpen) {
                dock.style.transform = "translateX(310px)";
            }
            
            const t = selectedTower;
            
            // Basic Info
            let nameText = t.name;
            if(t.level === 5 && t.branch && TOWER_UPGRADES[t.type]) {
                nameText += " (" + (t.branch === 'A' ? TOWER_UPGRADES[t.type].A.name : TOWER_UPGRADES[t.type].B.name) + ")";
            }
            document.getElementById('ins-name').innerText = nameText;
            document.getElementById('ins-lvl').innerText = t.level + (t.level>=MAX_LEVEL ? " (MAX)" : "");
            
            // Owner Label
            const ownerLbl = document.getElementById('ins-owner');
            if (socket && myRoomId && t.ownerIndex !== undefined && allPlayers[t.ownerIndex]) {
                ownerLbl.style.display = 'block';
                const ownerName = allPlayers[t.ownerIndex].name.toUpperCase();
                ownerLbl.innerText = "OWNER: " + ownerName;
                ownerLbl.style.color = PLAYER_COLORS[t.ownerIndex];
            } else {
                ownerLbl.style.display = 'none';
            }

            // Stats
            const standardRows = ['ins-dmg','ins-range','ins-rate'].map(id => document.getElementById(id).parentNode);
            const s1 = document.getElementById('row-special-1');
            const s2 = document.getElementById('row-special-2');
            s1.style.display='none'; s2.style.display='none';

            if(t.type === 'farm') {
                standardRows.forEach(r => r.style.display = 'none');
                // Show total generated next to level like other towers show destroys
                document.getElementById('ins-type').innerHTML = `Level <span id="ins-lvl">${t.level}</span> | Total: <span style="color:#2ecc71">$${t.totalGenerated||0}</span>`;
                
                s1.style.display = 'flex';
                document.getElementById('lbl-special-1').innerText = "Income";
                document.getElementById('val-special-1').innerText = "$" + t.income;
                
                s2.style.display = 'flex';
                document.getElementById('lbl-special-2').innerText = "Rate";
                document.getElementById('val-special-2').innerText = t.rate.toFixed(1) + "s";
            } 
            else {
                standardRows.forEach(r => r.style.display = 'flex');
		document.getElementById('ins-type').innerHTML = `Level <span id="ins-lvl">${t.level}</span> | Destroyed: <span style="color:#e74c3c">${t.destroys||0}</span>`;
                document.getElementById('ins-dmg').innerText = Math.floor(t.dmg);
                document.getElementById('ins-range').innerText = t.range.toFixed(1);
                document.getElementById('ins-rate').innerText = t.rate.toFixed(2) + "s";
                
                if(t.type === 'ice') {
                    s1.style.display = 'flex'; s2.style.display = 'flex';
                    document.getElementById('lbl-special-1').innerText = "Stun Chance";
                    document.getElementById('val-special-1').innerText = Math.floor(t.stunChance*100) + "%";
                    document.getElementById('lbl-special-2').innerText = "Slow Dur";
                    document.getElementById('val-special-2').innerText = t.slow.toFixed(1) + "s";
                }
                if(t.type === 'tesla') {
                    s1.style.display = 'flex';
                    document.getElementById('lbl-special-1').innerText = "Chain Limit";
                    document.getElementById('val-special-1').innerText = t.chain + " Targets";
                }
            }

            // --- BRANCHING LOGIC (FIXED) ---
            const btnUp = document.getElementById('btn-upgrade');
            const actionGroup = document.querySelector('.action-group');
            let branchContainer = document.getElementById('branch-container');

            if (t.level === 4) {
                btnUp.style.display = 'none'; 
                
                // BUG FIX: If we switched from Gunner to Cryo, we must clear the old Gunner buttons!
                if (branchContainer && branchContainer.dataset.towerType !== t.type) {
                    branchContainer.remove();
                    branchContainer = null;
                }
                
                // Only create if it doesn't exist (Prevents Spam Click Bug)
                if(!branchContainer) {
                    const upData = TOWER_UPGRADES[t.type];
                    branchContainer = document.createElement('div');
                    branchContainer.id = 'branch-container';
                    branchContainer.dataset.towerType = t.type; // Mark this container as belonging to this tower type
                    branchContainer.style.display = 'flex';
                    branchContainer.style.gap = '5px';
                    branchContainer.style.marginBottom = '10px';

                    const createChoiceBtn = (data, branchCode, color) => {
                        const branchCost = Math.floor(data.cost * GAME_CONFIG.costMult);
                        const b = document.createElement('button');
                        b.className = 'action-btn branch-btn-' + branchCode; 
                        b.style.background = color;
                        b.style.border = '1px solid #fff';
                        
                        // Check if branch upgrade is unlocked (tier 5)
                        const branchKey = branchCode === 'A' ? 'branch1' : 'branch2';
                        const isUnlocked = !window.unlockedUpgrades || 
                                         checkIsMultiplayerMode() || 
                                         (window.unlockedUpgrades[t.type] && window.unlockedUpgrades[t.type][branchKey] >= 5);
                        
                        if (!isUnlocked) {
                            // Get required level from branchUnlockLevels
                            const requiredLevel = window.branchUnlockLevels && window.branchUnlockLevels[t.type] 
                                ? window.branchUnlockLevels[t.type][branchKey]
                                : 21;
                            
                            b.innerHTML = `<b>${data.name}</b><br><span style="font-size:10px">🔒 Level ${requiredLevel}</span><br><span style="font-size:9px; opacity:0.7;">Unlock via leveling</span>`;
                            b.style.opacity = 0.5;
                            b.style.cursor = 'not-allowed';
                            b.onclick = null; // No action when locked (no annoying popup)
                        } else {
                            b.innerHTML = `<b>${data.name}</b><br><span style="font-size:10px">${data.desc}</span><br>$${branchCost}`;
                            b.onclick = () => upgradeTower(branchCode);
                        }
                        
                        return b;
                    };

                    branchContainer.appendChild(createChoiceBtn(upData.A, 'A', '#e67e22'));
                    branchContainer.appendChild(createChoiceBtn(upData.B, 'B', '#8e44ad'));
                    // Insert before the Sell/Close buttons
                    document.getElementById('inspect-panel').insertBefore(branchContainer, actionGroup);
                }

                // Update Button States (Disable if poor)
                const myGold = (currentGamemode === 'separate') ? playerWallets[myPlayerIndex] : gold;
                const upData = TOWER_UPGRADES[t.type];

                ['A', 'B'].forEach(code => {
                    const btn = branchContainer.querySelector('.branch-btn-' + code);
                    if(btn) {
                        const cost = Math.floor(upData[code].cost * GAME_CONFIG.costMult);
                        if(myGold < cost) {
                            btn.style.opacity = 0.5;
                            btn.style.cursor = 'not-allowed';
                        } else {
                            btn.style.opacity = 1;
                            btn.style.cursor = 'pointer';
                        }
                    }
                });

            } else {
                // Not level 4: Hide/Remove branch container
                if(branchContainer) branchContainer.remove();
                
                if (t.level >= MAX_LEVEL) {
                    btnUp.style.display = 'none';
                } else {
                    btnUp.style.display = 'block';
                    const cost = Math.floor((t.cost * GAME_CONFIG.costMult) * (t.level + 0.5));
                    
                    // Tiers 1-4 are always unlocked - no level requirement
                    // Only tier 5 branch paths (A/B) require unlocking
                    btnUp.innerText = `UPGRADE ($${cost})`;
                    const myGold = (currentGamemode === 'separate') ? playerWallets[myPlayerIndex] : gold;
                    btnUp.disabled = (myGold < cost);
                    btnUp.style.opacity = btnUp.disabled ? 0.5 : 1;
                }
            }
            
            document.getElementById('val-sell').innerText = Math.floor((t.cost * GAME_CONFIG.costMult * t.level) * 0.6);
        }

        function onResize() { 
            camera.aspect = window.innerWidth/window.innerHeight; 
            camera.updateProjectionMatrix(); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // NEW: Update the Composer size too!
            if(composer) composer.setSize(window.innerWidth, window.innerHeight);
        }

	// --- MOBILE CONTROLS ---
        function initMobileControls() {
            const el = renderer.domElement;
            let touchStartX = 0;
            let touchStartY = 0;
            let initialPinchDist = 0;
            let initialCamY = 0;
            let hasMoved = false;
            let startTime = 0;

            el.addEventListener('touchstart', (e) => {
                // Don't prevent default on UI elements
                if(e.target !== el) return;
                e.preventDefault();
                
                hasMoved = false;
                startTime = Date.now();
                
                if(e.touches.length === 1) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                    
                    // Update mouse position for hover effect
                    mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                    onMM({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
                } 
                else if (e.touches.length === 2) {
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    initialPinchDist = Math.sqrt(dx*dx + dy*dy);
                    initialCamY = camera.position.y;
                }
            }, {passive: false});

            el.addEventListener('touchmove', (e) => {
                if(e.target !== el) return;
                e.preventDefault();
                
                if(e.touches.length === 1) {
                    const dx = e.touches[0].clientX - touchStartX;
                    const dy = e.touches[0].clientY - touchStartY;
                    
                    // Only start panning if moved more than 10 pixels
                    const distance = Math.sqrt(dx*dx + dy*dy);
                    if(distance > 10) {
                        hasMoved = true;
                        
                        // Pan camera
                        camera.position.x -= dx * 0.15;
                        camera.position.z -= dy * 0.15;
                        
                        touchStartX = e.touches[0].clientX;
                        touchStartY = e.touches[0].clientY;
                        
                        // Update hover while panning
                        mouse.x = (e.touches[0].clientX / window.innerWidth) * 2 - 1;
                        mouse.y = -(e.touches[0].clientY / window.innerHeight) * 2 + 1;
                        onMM({ clientX: e.touches[0].clientX, clientY: e.touches[0].clientY });
                    }
                }
                else if (e.touches.length === 2) {
                    hasMoved = true;
                    const dx = e.touches[0].clientX - e.touches[1].clientX;
                    const dy = e.touches[0].clientY - e.touches[1].clientY;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    
                    if(initialPinchDist > 0) {
                        const scale = initialPinchDist / dist;
                        camera.position.y = Math.max(30, Math.min(180, initialCamY * scale));
                    }
                }
            }, {passive: false});

            el.addEventListener('touchend', (e) => {
                if(e.target !== el) return;
                
                const touchDuration = Date.now() - startTime;
                
                // Only click if it was a quick tap and didn't move much
                if(!hasMoved && touchDuration < 300) {
                    onClick({ button: 0 });
                }
                
                hasMoved = false;
            }, {passive: false});
        }

        function initUI() {
	    window.addEventListener('keydown', (e) => {
                if(!gameRunning || isPaused) return;

                // Map numbers 1-9 to tower keys
                const keys = ['gunner','sniper','ice','minigun','mortar','tesla','laser','plasma','farm'];
                const num = parseInt(e.key);
                
                if(num >= 1 && num <= keys.length) {
                    const type = keys[num-1];
                    // Find the button and trigger the click logic
                    // We need to find the DOM element to highlight it
                    const btn = Array.from(document.querySelectorAll('.tower-btn'))[num-1];
                    if(btn) selectTool(type, btn);
                    AudioSys.hover();
                }
                
                // ESC to deselect
                if(e.key === 'Escape') {
                    if(selectedType || selectedTower) deselectAll();
                    else togglePause();
                }
                
                // U to Upgrade (if tower selected)
                if(e.code === 'KeyU' && selectedTower) upgradeTower();
                
                // S to Sell (if tower selected)
                if(e.code === 'KeyS' && selectedTower) sellTower();
            });
            document.getElementById('btn-start-wave').onclick = (e) => { e.stopPropagation(); playClick(); startWave(); };
            document.getElementById('dock-toggle').onclick = (e) => { e.stopPropagation(); playClick(); toggleDock(); };
            document.getElementById('btn-upgrade').onclick = (e) => { e.stopPropagation(); upgradeTower(); };
            document.getElementById('btn-sell').onclick = (e) => { e.stopPropagation(); sellTower(); };
            
            const menuBtn = document.getElementById('menu-btn');
            if(menuBtn) menuBtn.onclick = (e) => { e.stopPropagation(); playClick(); togglePause(); };

            document.getElementById('inspect-panel').onmousedown = (e) => e.stopPropagation();
            document.getElementById('tower-dock').onmousedown = (e) => e.stopPropagation();
            
            // Disable context menu for right click
            document.body.oncontextmenu = (e) => e.preventDefault();
	    
	    let lastHovered = null;
            document.addEventListener('mouseover', (e) => {
                // Check if we touched a Button, Tower Card, or Map Card
                const target = e.target.closest('.btn') || 
                               e.target.closest('.tower-btn') || 
                               e.target.closest('.map-card') ||
                               e.target.closest('.almanac-item');

                // If we found a button AND it's different from the last one we touched...
                if(target && target !== lastHovered) {
                    AudioSys.hover(); // Play the blip!
                    lastHovered = target; // Remember this button so we don't spam sound while moving mouse inside it
                }
                // If we aren't touching a button anymore, reset the memory
                else if (!target) {
                    lastHovered = null;
                }
            });
        }
	
	function initPreviewSystem() {
            previewScene = new THREE.Scene();
            
            // Studio Lights for the Preview
            const amb = new THREE.AmbientLight(0xffffff, 0.6);
            const spot = new THREE.SpotLight(0xffffff, 1.5);
            spot.position.set(5, 10, 8);
            spot.castShadow = false; // No shadows for perf
            
            // Rim light for that "Premium" look
            const rim = new THREE.DirectionalLight(0x3498db, 0.8);
            rim.position.set(-5, 2, -5);
            
            previewScene.add(amb, spot, rim);

            previewCam = new THREE.PerspectiveCamera(45, 1, 0.1, 50);
            
            // Transparent Renderer
            previewRenderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            previewRenderer.setClearColor(0x000000, 0); // Fully transparent
            previewRenderer.setSize(300, 200);
        }

	function checkMultiplayerStats() {
    // Only run if we are actually connected
    if (!socket || !socket.connected) return;

    const locEl = document.getElementById('server-location');
    const pingEl = document.getElementById('ping-display'); // check if ID is 'ping-display' or 'ping-counter'

    // Force them to be visible with !important via JS
    if(locEl) {
        locEl.style.display = 'inline-block';
        locEl.style.zIndex = '9999'; // Force it on top of everything
        locEl.style.position = 'fixed'; // Keep it stuck to the screen
        // Adjust these positions to fit your UI
        locEl.style.botton = '10px'; 
        locEl.style.left = '90px'; 
    }
    
    if(pingEl) {
        pingEl.style.display = 'inline-block';
        pingEl.style.zIndex = '9999';
        pingEl.style.position = 'fixed';
        pingEl.style.botton = '10px';
        pingEl.style.left = '180px';
    }
}

	function initPostProcessing() {
    // Create the Composer (Effect Manager)
    composer = new THREE.EffectComposer(renderer);

    // 1. Base Render Pass
    const renderPass = new THREE.RenderPass(scene, camera);
    composer.addPass(renderPass);

    // 2. SSAO Pass (Screen Space Ambient Occlusion) - Adds depth/shadows
    if (typeof THREE.SSAOPass !== 'undefined') {
        window.ssaoPass = new THREE.SSAOPass(scene, camera, window.innerWidth, window.innerHeight);
        ssaoPass.kernelRadius = 16;
        ssaoPass.minDistance = 0.005;
        ssaoPass.maxDistance = 0.1;
        composer.addPass(ssaoPass);
    }

    // 3. Bloom Pass (Glow Effect)
    bloomPass = new THREE.UnrealBloomPass(
        new THREE.Vector2(window.innerWidth, window.innerHeight), 
        1.5,  // Strength
        0.4,  // Radius
        0.85  // Threshold
    );
    composer.addPass(bloomPass);

    // 4. SMAA Pass (Anti-Aliasing) - Smooth edges
    if (typeof THREE.SMAAPass !== 'undefined') {
        window.smaaPass = new THREE.SMAAPass(window.innerWidth, window.innerHeight);
        composer.addPass(smaaPass);
    }

    // 5. Color Correction Pass
    if (typeof THREE.ShaderPass !== 'undefined' && THREE.ColorCorrectionShader) {
        window.colorCorrectionPass = new THREE.ShaderPass(THREE.ColorCorrectionShader);
        colorCorrectionPass.uniforms.powRGB.value.set(1.2, 1.2, 1.2);
        colorCorrectionPass.uniforms.mulRGB.value.set(1.1, 1.1, 1.1);
        composer.addPass(colorCorrectionPass);
    }

    console.log('✅ Post-processing initialized');
}
	
        let dockOpen = true;
        function toggleDock() {
            dockOpen = !dockOpen;
            const dock = document.getElementById('tower-dock');
            const btn = document.getElementById('dock-toggle');
            
            if(dockOpen) {
                // OPEN: Reset to position (Button visible, Panel visible)
                dock.style.transform = "translateX(0)";
                btn.innerHTML = "CLOSE"; // Text
            } else {
                // CLOSED: Slide Right by the width of the panel (280px + padding)
                // This leaves ONLY the button visible on the right edge
                dock.style.transform = "translateX(310px)"; 
                btn.innerHTML = "BUILD"; // Text
            }
        }
        init();
        
        // ========================================================================
        // INITIALIZE CRAZYGAMES SDK ON PAGE LOAD
        // ========================================================================
        window.addEventListener('load', () => {
            initCrazyGamesSDK();
            
            // Check for invite link room parameter
            checkInviteLink();
            
            // Start live player counter
            initLivePlayerCounter();
        });
        
        /**
         * Live Player Counter System
         * Fetches total player count from Render.com tracking server
         * Also sends heartbeat to register this player as active
         */
        let playerHeartbeatInterval = null;
        let playerSessionId = null;
        
        // ⚠️ CHANGE THIS TO YOUR RENDER.COM URL! ⚠️
        const TRACKING_SERVER = 'https://karlostdplayercounter.onrender.com';
        
        function initLivePlayerCounter() {
            const counterElement = document.getElementById('live-player-count');
            if (!counterElement) return;
            
            // Generate unique session ID for this player
            playerSessionId = 'player_' + Date.now() + '_' + Math.random().toString(36).substring(7);
            
            // Start sending heartbeat to register as active player
            startPlayerHeartbeat();
            
            // Update counter immediately
            updateLivePlayerCount();
            
            // Update every 30 seconds
            setInterval(updateLivePlayerCount, 30000);
        }
        
        /**
         * Send heartbeat to servers to register this player as active
         * Heartbeats are sent every 25 seconds (servers expire after 60s of no heartbeat)
         */
        function startPlayerHeartbeat() {
            // Send initial heartbeat
            sendHeartbeat();
            
            // Send heartbeat every 25 seconds
            playerHeartbeatInterval = setInterval(sendHeartbeat, 25000);
            
            // Stop heartbeat when page unloads
            window.addEventListener('beforeunload', stopPlayerHeartbeat);
        }
        
        function stopPlayerHeartbeat() {
            if (playerHeartbeatInterval) {
                clearInterval(playerHeartbeatInterval);
                playerHeartbeatInterval = null;
            }
        }
        
        async function sendHeartbeat() {
            if (!playerSessionId) return;
            
            try {
                await fetch(TRACKING_SERVER + '/heartbeat', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        sessionId: playerSessionId,
                        platform: window.location.hostname.includes('itch') ? 'itch.io' : 
                                 window.location.hostname.includes('crazygames') ? 'crazygames' : 'web',
                        timestamp: Date.now()
                    }),
                    cache: 'no-cache'
                });
            } catch (err) {
                // Heartbeat failed - server might be offline or sleeping
                console.log('Heartbeat failed:', err.message);
            }
        }
        
        async function updateLivePlayerCount() {
            const counterElement = document.getElementById('live-player-count');
            if (!counterElement) return;
            
            try {
                const controller = new AbortController();
                const timeout = setTimeout(() => controller.abort(), 5000);
                
                const response = await fetch(TRACKING_SERVER + '/player-count', {
                    method: 'GET',
                    signal: controller.signal,
                    cache: 'no-cache'
                });
                
                clearTimeout(timeout);
                
                if (response.ok) {
                    const data = await response.json();
                    const count = data.count || 0;
                    
                    counterElement.textContent = count;
                    counterElement.parentElement.title = `${count} players with game open`;
                    
                    // Add animation when count changes
                    counterElement.style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        counterElement.style.transform = 'scale(1)';
                    }, 200);
                } else {
                    counterElement.textContent = '0';
                    counterElement.parentElement.title = 'Unable to fetch player count';
                }
            } catch (error) {
                console.log('Failed to update player count:', error.message);
                counterElement.textContent = '0';
                counterElement.parentElement.title = 'Checking for active players...';
            }
        }
        
        /**
         * Check URL for room parameter and auto-join
         * Handles CrazyGames invite links
         */
        function checkInviteLink() {
            const urlParams = new URLSearchParams(window.location.search);
            const roomId = urlParams.get('room') || urlParams.get('roomId');
            
            if (roomId) {
                console.log('🔗 Invite link detected! Room:', roomId);
                
                // Show name entry screen for multiplayer
                setTimeout(() => {
                    hideAllScreens();
                    document.getElementById('mp-name-menu').style.display = 'flex';
                    
                    // Pre-fill room code
                    document.getElementById('room-code-input').value = roomId.toUpperCase();
                    
                    // Show join section
                    document.getElementById('join-input-area').style.display = 'flex';
                    
                    // Focus on name input
                    document.getElementById('player-name-input').focus();
                    
                    console.log('✅ Ready to join room:', roomId);
                }, 500); // Small delay to ensure DOM is ready
            }
        }


	// --- MULTIPLAYER LOGIC ---
        let socket;
        let myRole = null; 
        let myRoomId = null;

	const SERVER_REGIONS = [
    {
        region: "🇺🇸 US West (Oregon)",
        code: "us-west",
        location: "West Coast USA, Canada",
        servers: [
            "https://td-game-server-ygr0.onrender.com",
            "https://karlos-td-oregon-2.onrender.com",
            "https://td-game-server-k409.onrender.com"
        ]
    },
    {
        region: "🇺🇸 US East (Ohio)",
        code: "us-east-1",
        location: "Central & East USA",
        servers: [
            "https://karlos-td-ohio-1.onrender.com",
            "https://karlos-td-ohio-2.onrender.com",
            "https://karlos-td-ohio-3.onrender.com"
        ]
    },
    {
        region: "🇺🇸 US East (Virginia)",
        code: "us-east-2",
        location: "East Coast USA, South America",
        servers: [
            "https://karlos-td-virginia-1.onrender.com",
            "https://karlos-td-virginia-2.onrender.com",
            "https://karlos-td-virginia-3.onrender.com"
        ]
    },
    {
        region: "🇪🇺 EU Central (Frankfurt)",
        code: "eu-central",
        location: "Europe, Middle East, Africa",
        servers: [
            "https://karlos-td-frankfurt-1.onrender.com",
            "https://karlos-td-frankfurt-2.onrender.com",
            "https://karlos-td-frankfurt-3.onrender.com"
        ]
    },
    {
        region: "🌏 Asia (Singapore)",
        code: "asia-southeast",
        location: "Asia-Pacific, Oceania",
        servers: [
            "https://karlos-td-singapore-1.onrender.com",
            "https://karlos-td-singapore-2.onrender.com",
            "https://karlos-td-singapore-3.onrender.com"
        ]
    }
];

	let selectedRegion = null;
let pingLoop = null;
let selectedServerIndex = 0;
let regionPings = {};
let isPingingServers = false;
let currentServerURL = null;
let connectionAttempts = 0;
let connectedServerInfo = null; // {region, serverNumber, url}

	async function pingServer(url) {
    const startTime = Date.now();
    try {
        // Try HTTP fetch first
        const controller = new AbortController();
        const timeout = setTimeout(() => controller.abort(), 5000);
        
        await fetch(url + '/ping', { 
            method: 'HEAD',
            mode: 'no-cors',
            cache: 'no-cache',
            signal: controller.signal
        });
        
        clearTimeout(timeout);
        return Date.now() - startTime;
    } catch (error) {
        // Fallback to Socket.io ping
        return await pingViaSocket(url);
    }
}

function pingViaSocket(url) {
    return new Promise((resolve) => {
        const startTime = Date.now();
        const testSocket = io(url, {
            timeout: 5000,
            reconnection: false,
            transports: ['websocket', 'polling']
        });
        
        testSocket.on('connect', () => {
            const latency = Date.now() - startTime;
            testSocket.disconnect();
            resolve(latency);
        });
        
        testSocket.on('connect_error', () => {
            testSocket.disconnect();
            resolve(9999); // Offline marker
        });
        
        setTimeout(() => {
            testSocket.disconnect();
            resolve(9999);
        }, 5000);
    });
}

async function measureAllRegions() {
    if (isPingingServers) return;
    isPingingServers = true;
    
    console.log('🌐 Measuring latency to all regions...');
    updateRegionStatus('🔍 Measuring latency to all regions...');
    
    const pingPromises = SERVER_REGIONS.map(async (region) => {
        const ping = await pingServer(region.servers[0]);
        regionPings[region.code] = ping;
        updateRegionUI(region.code, ping);
        console.log(`📊 ${region.region}: ${ping}ms`);
        return { region, ping };
    });
    
    const results = await Promise.all(pingPromises);
    
    // Auto-select best region (lowest ping)
    const bestRegion = results.reduce((best, current) => {
        return current.ping < best.ping ? current : best;
    });
    
    selectRegion(bestRegion.region.code);
    isPingingServers = false;
    
    console.log(`✅ Auto-selected: ${bestRegion.region.region} (${bestRegion.ping}ms)`);
    updateRegionStatus(`✅ Best region selected: ${bestRegion.region.region}`);
}

function updateRegionUI(regionCode, ping) {
    const regionItem = document.getElementById('region-' + regionCode);
    if (!regionItem) return;
    
    const statusDot = regionItem.querySelector('.region-status-dot');
    const pingDisplay = regionItem.querySelector('.region-ping');
    
    // Update status dot color
    let color, boxShadow;
    if (ping < 100) {
        color = '#00ff00';
        boxShadow = '0 0 10px #00ff00';
    } else if (ping < 200) {
        color = '#ffff00';
        boxShadow = '0 0 10px #ffff00';
    } else if (ping < 9999) {
        color = '#ff6600';
        boxShadow = '0 0 10px #ff6600';
    } else {
        color = '#ff0000';
        boxShadow = '0 0 10px #ff0000';
    }
    
    statusDot.style.background = color;
    statusDot.style.boxShadow = boxShadow;
    
    // Update ping display
    if (ping < 9999) {
        pingDisplay.textContent = ping + 'ms';
        pingDisplay.style.color = ping < 100 ? '#00ff00' : ping < 200 ? '#ffff00' : '#ff6600';
    } else {
        pingDisplay.textContent = 'Offline';
        pingDisplay.style.color = '#ff0000';
    }
}

function selectRegion(regionCode) {
    selectedRegion = SERVER_REGIONS.find(r => r.code === regionCode);
    if (!selectedRegion) return;
    
    // Update UI selection
    document.querySelectorAll('.region-item').forEach(item => {
        item.classList.remove('region-selected');
    });
    
    const regionItem = document.getElementById('region-' + regionCode);
    if (regionItem) {
        regionItem.classList.add('region-selected');
    }
    
    selectedServerIndex = 0;
    updateConnectionDisplay();
    
    console.log(`📍 Region selected: ${selectedRegion.region}`);
}

function updateConnectionDisplay() {
    const display = document.getElementById('selected-region-display');
    if (!display || !selectedRegion) return;
    
    const ping = regionPings[selectedRegion.code] || '...';
    display.innerHTML = `
        <div style="font-size: 16px; color: #00ff88; font-weight: bold; margin-bottom: 5px;">
            ${selectedRegion.region}
        </div>
        <div style="font-size: 14px; color: #aaa;">
            ${ping < 9999 ? 'Ping: ' + ping + 'ms' : 'Status: Checking...'}
        </div>
    `;
}

function updateRegionStatus(message) {
    const statusEl = document.getElementById('region-status-message');
    if (statusEl) {
        statusEl.textContent = message;
    }
}

	async function connectToServerWithFailover() {
    if (!selectedRegion) {
        showToast('⚠️ Please select a region first!', 'warning');
        return false;
    }
    
    connectionAttempts = 0;
    const servers = selectedRegion.servers;
    
    for (let i = 0; i < servers.length; i++) {
        selectedServerIndex = i;
        const serverURL = servers[i];
        currentServerURL = serverURL;
        
        console.log(`🔌 Attempting: ${selectedRegion.region} Server #${i + 1}`);
        showToast(`Connecting to ${selectedRegion.region} Server #${i + 1}...`, 'info');
        
        const connected = await attemptConnection(serverURL, i + 1);
        
        if (connected) {
            connectedServerInfo = {
                region: selectedRegion.region,
                serverNumber: i + 1,
                url: serverURL,
                ping: regionPings[selectedRegion.code]
            };
            console.log('✅ Connected successfully!');
            showToast(`✅ Connected to ${selectedRegion.region} Server #${i + 1}`, 'success');
            updateLobbyServerInfo();
	    document.getElementById('region-selector-screen').style.display = 'none';
            document.getElementById('mp-menu').style.display = 'flex';
            return true;
        }
        
        console.log(`❌ Server #${i + 1} failed, trying next...`);
    }
    
    // All servers failed
    console.error('❌ All servers in region failed!');
    showToast(`❌ All ${selectedRegion.region} servers are offline. Please try another region.`, 'error');
    return false;
}

function attemptConnection(serverURL, serverNumber) {
    return new Promise((resolve) => {
        let wakingUpShown = false;
        
        const tempSocket = io(serverURL, {
            timeout: 60000,
            reconnection: false,
            transports: ['websocket', 'polling']
        });
        
        // Show "waking up" message after 3 seconds
        const wakingTimer = setTimeout(() => {
            wakingUpShown = true;
            showToast(`⏳ Server #${serverNumber} is sleeping... Waking up (may take 30-50 seconds)`, 'warning', 0);
        }, 3000);
        
        // Total timeout (60 seconds for Render wake-up)
        const timeoutTimer = setTimeout(() => {
            clearTimeout(wakingTimer);
            tempSocket.disconnect();
            resolve(false);
        }, 60000);
        
        tempSocket.on('connect', () => {
            clearTimeout(wakingTimer);
            clearTimeout(timeoutTimer);
            socket = tempSocket;
            setupSocketListeners();
            resolve(true);
        });
        
        tempSocket.on('connect_error', (error) => {
            clearTimeout(wakingTimer);
            clearTimeout(timeoutTimer);
            console.error('Connection error:', error);
            tempSocket.disconnect();
            resolve(false);
        });
    });
}

function setupSocketListeners() {
    if (!socket) return;
    
    // Server info
    socket.on('serverInfo', (data) => {
        console.log("📍 Server Location:", data.location);
        const locEl = document.getElementById('server-location');
        if (locEl) locEl.innerText = data.location;
    });
    
    // Ping Heartbeat (Updates every 5 seconds)
        // Ping Heartbeat (Updates every 2 seconds)
        setInterval(() => {
            if (!socket || !socket.connected) return;

            const start = Date.now();
            
            // 1. Send the pulse
            socket.emit('ping');
            
            // 2. Wait for the echo
            socket.once('pong', () => {
                const latency = Date.now() - start;
                
                // Update the global ping tracker
                if (connectedServerInfo) {
                    connectedServerInfo.ping = latency;
                    
                    // Force the HTML to update
                    const infoEl = document.getElementById('server-connection-info');
                    if (infoEl) {
                        // We rebuild just the latency part to prevent flickering
                        const latencyEl = infoEl.querySelector('div[style*="font-size: 12px"]');
                        if (latencyEl) {
                            latencyEl.innerText = `Latency: ${latency}ms`;
                        } else {
                            // Fallback: Rebuild the whole thing
                            updateLobbyServerInfo();
                        }
                    }
                }
            });
        }, 5000);
    
    socket.on('roomCreated', (data) => {
        myRoomId = data.roomId;
        myRole = 'host';
        updateLobbyUI(data.players);
    });

    socket.on('playerJoined', (players) => {
        updateLobbyUI(players);
    });

    socket.on('playerLeft', (id) => {
        const idx = allPlayers.findIndex(p => p.id === id);
        if (idx !== -1) {
            const pName = allPlayers[idx].name;
            showLocalError(`${pName} LEFT THE GAME`, '#f1c40f');
            
            allPlayers.splice(idx, 1);
            playerWallets.splice(idx, 1);
            playerWallets.push(0);

            towers.forEach(t => {
                if (t.ownerIndex === idx) {
                    t.ownerIndex = -1;
                } else if (t.ownerIndex > idx) {
                    t.ownerIndex--;
                }
            });

            myPlayerIndex = allPlayers.findIndex(p => p.id === socket.id);
            updateUI();
        }
    });

    socket.on('hostLeft', () => {
        alert("Host disconnected! Returning to Main Menu.");
        goToMainMenu();
    });

    socket.on('errorMsg', (msg) => { alert(msg); });
    socket.on('forceStartWave', () => { runWaveLogic(); });
    socket.on('forceRestart', () => { location.reload(); });

    socket.on('forceGameState', (data) => {
        isPaused = true;
        gameRunning = false;
        if (data.state === 'loss') {
            wave = data.finalWave;
            document.getElementById('ui-wave').innerText = wave;
            document.getElementById('final-wave-loss').innerText = data.finalWave;
            document.getElementById('game-over-screen').style.display = 'flex';
        } else if (data.state === 'win') {
            document.getElementById('victory-screen').style.display = 'flex';
        }
    });

    socket.on('forcePause', (pauseState) => { runPauseLogic(pauseState); });
    
    // Continue with existing remoteAction handler...
    socket.on('remoteAction', (data) => {
                    
                    // --- 1. MASTER SYNC ---
                    if (data.type === 'master_sync') {
    		    lives = data.lives;
    		    currentGamemode = data.mode;
    		    wave = data.wave;
                    
                    // Update host performance metrics
                    if (data.hostFPS !== undefined && myRole !== 'host') {
                        // Calculate effective ping based on host FPS
                        const effectivePing = data.hostFPS < 30 ? 200 : (data.hostFPS < 50 ? 100 : 50);
                        updateHostPing(effectivePing);
                    }

    		    // Sync Wallets
                    if (currentGamemode === 'shared') {
                        gold = data.gold;
                    } else {
                        const serverWallets = data.wallets;
                        for(let i=0; i<4; i++) {
                            // 1. Always update the array storage
                            playerWallets[i] = serverWallets[i];

                            // 2. If this is ME, update my display
                            if (i === myPlayerIndex) {
                                // If I haven't clicked anything for 500ms, trust the server completely.
                                // This lets income/destroys update your UI, while protecting your clicks.
                                if (Date.now() - lastSpendTime > 500) {
                                    gold = serverWallets[i];
                                }
                            }
                        }
                    }
                    updateUI();
                        
                        // Sync Enemies
                        data.enemies.forEach(syncE => {
                            let localE = enemies.find(e => e.id === syncE.id);
                            
                            // 1. UPDATE EXISTING ENEMY (This handles the turning!)
                            if(localE) {
                                localE.mesh.position.x = syncE.x; 
                                localE.mesh.position.z = syncE.z;
                                
                                // --- THIS IS THE LINE YOU ARE MISSING ---
                                // Without this, they only rotate once when created!
                                if(syncE.rot !== undefined) localE.mesh.rotation.y = syncE.rot; 
                                // ----------------------------------------

                                localE.hp = syncE.hp;
				localE.maxHp = syncE.maxHp;
                                
                                // Health Bar Update
                                const pct = Math.max(0, localE.hp / localE.maxHp);
                                localE.fg.scale.x = pct; 
                                localE.fg.material.color.setHSL(pct * 0.3, 1, 0.5);
                                
                                if(localE.hpGroup) {
                                    localE.hpGroup.position.copy(localE.mesh.position);
                                    localE.hpGroup.position.y += localE.hpHeight; 
                                    localE.hpGroup.quaternion.copy(camera.quaternion); 
                                }
                            } 
                            // 2. CREATE MISSING ENEMY
                            else {
                                spawnEnemy(syncE.type, syncE.id);
                                localE = enemies.find(e => e.id === syncE.id);
                                if(localE) {
                                    localE.mesh.position.set(syncE.x, 0, syncE.z);
                                    // Apply rotation immediately on spawn
                                    if(syncE.rot !== undefined) localE.mesh.rotation.y = syncE.rot;
                                    localE.hp = syncE.hp;
                                }
                            }
                        });
                        // Sync Towers (Rotation + Repair)
                        if(data.towers) {
                            data.towers.forEach(syncT => {
                                let localT = towers.find(t => Math.abs(t.mesh.position.x - syncT.x) < 0.1 && Math.abs(t.mesh.position.z - syncT.z) < 0.1);
                                if(localT) {
                                    if(localT.mesh.children[1]) localT.mesh.children[1].rotation.y = syncT.rotY;
				    localT.destroys = syncT.destroys;
                                } else {
                                    // Create missing tower
                                    const mesh = createTowerModel(syncT.type, syncT.level, syncT.branch);
                                    mesh.position.set(syncT.x, 0, syncT.z);
                                    scene.add(mesh);
                                    const tData = TOWERS[syncT.type];
                                    towers.push({
                                        mesh, 
                                        ...JSON.parse(JSON.stringify(tData)),
                                        type: syncT.type,
                                        level: syncT.level,
                                        branch: syncT.branch,
                                        cooldown: 0,
                                        destroys: syncT.destroys || 0,
                                        ownerRole: syncT.owner
                                    });
                                    
                                    // Track tower for challenges
                                    if (typeof window.trackTowerBuilt === 'function') {
                                        window.trackTowerBuilt();
                                    }
                                }
                            });

                            // Cleanup Ghosts
                            const hostTowerSigs = new Set(data.towers.map(t => `${Math.round(t.x)},${Math.round(t.z)}`));
                            for(let i = towers.length - 1; i >= 0; i--) {
                                const t = towers[i];
                                const sig = `${Math.round(t.mesh.position.x)},${Math.round(t.mesh.position.z)}`;
                                if(!hostTowerSigs.has(sig)) {
                                    scene.remove(t.mesh);
                                    towers.splice(i, 1);
                                }
                            }
                        }

                        // Remove Dead Enemies
                        const hostIds = data.enemies.map(e => e.id);
                        for(let i=enemies.length-1; i>=0; i--) {
                            if(!hostIds.includes(enemies[i].id)) {
                                scene.remove(enemies[i].mesh); if(enemies[i].hpGroup) scene.remove(enemies[i].hpGroup);
                                enemies.splice(i, 1);
                            }
                        }
                    }

                    // --- 2. TOWER STUN ---
                    else if(data.type === 'tower_stun') {
                        const t = towers.find(tow => Math.abs(tow.mesh.position.x - data.tx) < 0.1 && Math.abs(tow.mesh.position.z - data.tz) < 0.1);
                        if(t) {
                            t.stunned = 2.0;
                            createFloatingText("ZAP!", t.mesh.position.clone().add(new THREE.Vector3(0,4,0)), "#3498db");
                            createParticles(t.mesh.position.clone().add(new THREE.Vector3(0,2,0)), 10, 0x00ffff);
                        }
                    }

                    // --- 3. SPAWN MINION ---
                    else if(data.type === 'spawn_minion') {
                        spawnEnemy(data.key, data.id);
                        const minion = enemies[enemies.length-1];
                        minion.pathIdx = data.idx;
                        minion.mesh.position.set(data.x, 0, data.z);
                    }

                    // --- 4. VISUAL EFFECTS (Shooting, Healing, Damage) ---
                    else if(data.type === 'visual_effect') {
                        
                        // A. SHOOTING (This is what was broken!)
                        if(data.effect === 'shoot') {
                            const t = towers.find(tow => Math.abs(tow.mesh.position.x - data.towerX) < 0.1 && Math.abs(tow.mesh.position.z - data.towerZ) < 0.1);
                            const target = enemies.find(en => en.id === data.targetId);
                            
                            if(t && target) {
                                // Rotate Turret
                                if(t.mesh.children[1]) t.mesh.children[1].rotation.y = data.rotY;
                                t.currentRotY = data.rotY; // Save for smoothing

                                // Flash Target
                                triggerFlash(target);
                                AudioSys.shoot(data.towerType);

                                // Create Projectile Visuals
                                const muzzlePos = getMuzzlePosition(t);

                                if(data.towerType === 'laser') {
                                    const line = new THREE.Line(new THREE.BufferGeometry().setFromPoints([muzzlePos, target.mesh.position]), new THREE.LineBasicMaterial({color:0xe74c3c}));
                                    scene.add(line); setTimeout(()=>scene.remove(line), 50);
                                    createImpact(target.mesh.position, 0xe74c3c, 2);
                                } 
                                else if (data.towerType === 'ice') {
                                    createExplosion(t.mesh.position, 0xaaddff, t.range/2);
                                } 
                                else if (data.towerType === 'tesla') {
                                    // Base bolt (Chain is handled by 'tesla_chain' effect below)
                                    const geo = new THREE.BufferGeometry().setFromPoints([muzzlePos, target.mesh.position]);
                                    const bolt = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x5dade2 }));
                                    scene.add(bolt); setTimeout(() => scene.remove(bolt), 100);
                                } 
                                else {
                                    // Standard Projectile (Minigun, Gunner, Sniper, Plasma, Mortar)
                                    createMuzzleFlash(muzzlePos, t.color);
                                    
                                    const pMesh = new THREE.Mesh(new THREE.SphereGeometry(0.4), new THREE.MeshBasicMaterial({color:t.color}));
                                    pMesh.position.copy(muzzlePos);
                                    scene.add(pMesh);
                                    
                                    // Add to local array so client animate() moves it
                                    projectiles.push({ 
                                        mesh: pMesh, 
                                        target: target, 
                                        dmg: 0, splash: t.splash, slow: 0, color: t.color 
                                    });
                                }
                            }
                        }
                        
                        // B. DAMAGE TEXT
                        else if(data.effect === 'dmg_text') {
                            const color = data.crit ? "#e74c3c" : "#fff";
                            const randPos = new THREE.Vector3((Math.random()-0.5)*2, 2, (Math.random()-0.5)*2);
                            createFloatingText("-" + data.val, new THREE.Vector3(data.x, 0, data.z).add(randPos), color);
                        }

                        // C. FARM TEXT
                        else if(data.effect === 'farm_text') {
                            createFloatingText("+$"+data.value, new THREE.Vector3(data.x, 6, data.z), "#2ecc71");
                            AudioSys.shoot('farm');
                        }

                        // D. HEAL EFFECT
                        else if(data.effect === 'heal_area') {
                            createParticles(new THREE.Vector3(data.x, 2, data.z), 10, 0x00ff00);
                        }

                        // E. TESLA CHAIN
                        else if(data.effect === 'tesla_chain') {
                            const points = data.points.map(p => new THREE.Vector3(p.x, p.y, p.z));
                            for(let i=0; i<points.length-1; i++) {
                                const geo = new THREE.BufferGeometry().setFromPoints([points[i], points[i+1]]);
                                const bolt = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x5dade2 }));
                                scene.add(bolt); 
                                setTimeout(() => scene.remove(bolt), 80);
                            }
                            AudioSys.shoot('tesla');
                        }

                        // F. SHATTER
                        else if(data.effect === 'shatter') {
                            createShatter(new THREE.Vector3(data.x, 0, data.z), data.color, data.count);
                            AudioSys.tone(100, 'sawtooth', 0.1, 0.1);
                        }
                    }

                    // --- 5. BUILD ---
                    else if (data.type === 'build') {
                        const tData = TOWERS[data.key];
                        const cost = Math.floor(tData.cost * GAME_CONFIG.costMult);
                        
                        // FIX: Check farm limit in separate mode (prevent joiners from spamming farms)
                        if(data.key === 'farm' && currentGamemode === 'separate') {
                            const MAX_FARMS = 5;
                            const builderFarmCount = towers.filter(t => 
                                t.type === 'farm' && t.ownerIndex === data.pIndex
                            ).length;
                            
                            if(builderFarmCount >= MAX_FARMS) {
                                console.log(`Player ${data.pIndex} tried to exceed farm limit`);
                                return; // Ignore this build
                            }
                        }

                        // HOST LOGIC: Sync wallets for late joiners
                        if (myRole === 'host') {
                            if (currentGamemode === 'shared') {
                                if (data.pIndex !== myPlayerIndex) gold -= cost;
                            } else {
                                if (data.pIndex !== undefined && data.pIndex !== myPlayerIndex) {
                                    playerWallets[data.pIndex] -= cost;
                                }
                            }
                        }

    const mesh = createTowerModel(data.key, 1);
    mesh.position.set(data.x, 0, data.z);
    scene.add(mesh);

    towers.push({
        mesh,
        ...JSON.parse(JSON.stringify(tData)),
        type: data.key,
        level: 1,
        cooldown: 0,
        destroys: 0,
        ownerIndex: data.pIndex
    });
    
    // Track tower for challenges
    if (typeof window.trackTowerBuilt === 'function') {
        window.trackTowerBuilt();
    }
    
    updateUI();
}

                    // --- 6. SPAWN ENEMY ---
                    else if(data.type === 'spawn') {
                        spawnEnemy(data.typeKey, data.enemyId);
                    } 

                    // --- 7. UPGRADE ---
                    else if(data.type === 'upgrade') {
                        const t = towers.find(tow => Math.abs(tow.mesh.position.x - data.x) < 0.1 && Math.abs(tow.mesh.position.z - data.z) < 0.1);
                        if(t) {
                            let cost = 0;
                            if(t.level === 4 && data.branch) {
                                cost = Math.floor(TOWER_UPGRADES[t.type][data.branch].cost * GAME_CONFIG.costMult);
                            } else {
                                cost = Math.floor((t.cost * GAME_CONFIG.costMult) * (t.level + 0.5));
                            }

                            // HOST LOGIC
                            if(myRole === 'host') {
                                if(currentGamemode === 'shared') {
                                    if(data.playerRole !== 'host') gold -= cost; // Only deduct if joiner did it
                                } else {
                                    // Separate: Update the upgrader's wallet
                                    // FIX: Don't deduct from myself twice
                                    const pIdx = (data.pIndex !== undefined) ? data.pIndex : t.ownerIndex;
                                    if(pIdx !== undefined && pIdx !== myPlayerIndex) {
                                        playerWallets[pIdx] -= cost;
                                    }
                                }
                            }

                            t.level++;
                            
                            // Track upgrade for challenges
                            if (typeof window.sessionStats !== 'undefined') {
                                window.sessionStats.upgrades = (window.sessionStats.upgrades || 0) + 1;
                                if (typeof window.updateChallengeProgress === 'function') {
                                    window.updateChallengeProgress('upgrades', window.sessionStats.upgrades);
                                }
                            }
                            
                            // ✅ CRITICAL: Track upgrade for achievements
                            if (typeof window.trackUpgrade === 'function') {
                                window.trackUpgrade();
                            }
                            
                            // ... (Rest of the upgrade logic stays the same from here down) ...
                            if(t.level === 5 && data.branch) {
                                t.branch = data.branch;
                                if(TOWER_UPGRADES[t.type] && TOWER_UPGRADES[t.type][data.branch]) {
                                    const stats = TOWER_UPGRADES[t.type][data.branch];
                                    t.dmg *= stats.dmgMult || 1;
                                    t.range *= stats.rangeMult || 1;
                                    t.rate *= stats.rateMult || 1;
                                    t.color = stats.color;
                                    if(stats.splash) t.splash = stats.splash;
                                    if(stats.special) t.special = stats.special;
                                    if(t.type === 'tesla' && stats.chainAdd) t.chain += stats.chainAdd;
                                    if(t.type === 'tesla' && stats.chainSet) t.chain = stats.chainSet;
                                    if(t.type === 'ice' && stats.slowAdd) t.slow += stats.slowAdd;
                                    if(t.type === 'farm' && stats.incomeAdd) t.income += stats.incomeAdd;
                                }
                            } else {
                                t.dmg *= 1.5; t.range *= 1.1; t.rate *= 0.9;
                                if(t.type === 'ice') { t.slow += 0.1; t.stunChance += 0.05; t.stunDur += 0.2; }
                                if(t.type === 'farm') { t.income += 30; }
                                if(t.type === 'tesla' && t.level % 2 === 0) { t.chain += 1; }
                            }

                            const oldPos = t.mesh.position.clone();
                            const oldRot = t.mesh.children[1].rotation.clone();
                            scene.remove(t.mesh);
                            
                            t.mesh = createTowerModel(t.type, t.level, t.branch);
                            
                            t.mesh.position.copy(oldPos);
                            t.mesh.children[1].rotation.copy(oldRot);
                            scene.add(t.mesh);
                            updateUI();
                        }
                    }

                    // --- NEW: 9. WALLET UPDATE (Real-time Money Sync) ---
                    else if(data.type === 'wallet_update') {
                        if(data.mode === 'shared') {
                            gold = data.gold;
                        } else {
                            playerWallets = data.wallets;
                            gold = playerWallets[myPlayerIndex];
                        }
                        updateUI();
                    }

                    // --- 8. SELL ---
                    else if(data.type === 'sell') {
                        const t = towers.find(tow => Math.abs(tow.mesh.position.x - data.x) < 0.1 && Math.abs(tow.mesh.position.z - data.z) < 0.1);
                        if(t) {
                            if(myRole === 'host') {
                                const refund = Math.floor((t.cost * GAME_CONFIG.costMult * t.level) * 0.6);
                                if(currentGamemode === 'shared') gold += refund;
                                else {
                                    // Refund to Owner
                                    if(t.ownerIndex !== undefined) playerWallets[t.ownerIndex] += refund;
                                }
                            }
                            createParticles(t.mesh.position, 10, 0xcccccc); 
                            scene.remove(t.mesh);
                            towers = towers.filter(x => x !== t);
                            updateUI();
                        }
                    }
                });
		socket.on('gameStart', (config) => {
                    hideAllScreens();
                    
                    // Hide invite button when leaving lobby to start game
                    hideInviteButton();
                    
                    selectedMapIndex = config.mapIndex;
                    mapSeed = config.seed; 
                    currentGamemode = config.mode;

		    // --- NEW: Set Info Panel Text (MP) ---
            	    document.getElementById('info-map-name').innerText = MAPS[selectedMapIndex].name;
            	    document.getElementById('info-diff').innerText = config.diff.toUpperCase();
            
            	    const diffColor = (config.diff==='easy'?'#2ecc71':(config.diff==='medium'?'#f1c40f':'#e74c3c'));
            	    document.getElementById('info-diff').style.color = diffColor;
            
            	    document.getElementById('info-mode').innerText = (config.mode === 'shared' ? "SHARED" : "SEPARATE");
            	    // -------------------------------------

                    // Apply same difficulty config here as single-player (original values)
                    if(config.diff === 'easy') { GAME_CONFIG = { maxWaves:20, hpMult:0.7, costMult:0.85, gold:800 }; }
                    else if(config.diff === 'medium') { GAME_CONFIG = { maxWaves:40, hpMult:0.9, costMult:1.0, gold:650 }; }
                    else { GAME_CONFIG = { maxWaves:60, hpMult:1.1, costMult:1.2, gold:500 }; }

                    document.getElementById('ui-max-wave').innerText = GAME_CONFIG.maxWaves;
                    resetGame(); 
                    
                    gold = GAME_CONFIG.gold;
                    goldHost = gold;
                    goldJoiner = gold; 

                    loadMap(selectedMapIndex); 
                    AudioSys.playMusic(MAPS[selectedMapIndex].track);
                    camera.position.set(0, 110, 50);
                    camera.lookAt(0, 0, 0);
                    
                    if(myRole !== 'host') {
                        const btn = document.getElementById('btn-start-wave');
                        btn.disabled = true; 
                        btn.innerText = "WAITING FOR HOST"; 
                        btn.style.backgroundColor = "#333";
                    }

                    // Populate tower grid with new UI
                    populateTowerGrid();

                    setGameUIVisible(true); 
                    gameRunning = true; 
                    isPaused = false; 
                    updateUI();
                    
                    // Show performance stats in multiplayer
                    showPerformanceStats();
                });
            }
        

	function setServerLocation(name) {
    const el = document.getElementById('server-location');
    if(el) {
        el.style.display = 'inline-block'; // Make it visible
        el.innerText = "📍 " + name;
    }
}


function updateLobbyServerInfo() {
    const infoEl = document.getElementById('server-connection-info');
    if (!infoEl || !connectedServerInfo) return;
    
    infoEl.innerHTML = `
        <div style="display: flex; align-items: center; gap: 10px; justify-content: center;">
            <div class="server-status-dot-connected"></div>
            <div>
                <div style="font-size: 14px; color: #00ff88; font-weight: bold;">
                    Connected: ${connectedServerInfo.region} #${connectedServerInfo.serverNumber}
                </div>
                <div style="font-size: 12px; color: #aaa;">
                    Latency: ${connectedServerInfo.ping}ms
                </div>
            </div>
        </div>
    `;
}

	function showToast(message, type = 'info', duration = 3000) {
    let toast = document.getElementById('connection-toast');
    if (!toast) {
        toast = document.createElement('div');
        toast.id = 'connection-toast';
        toast.style.cssText = `
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 15px 30px;
            border-radius: 10px;
            font-size: 14px;
            font-weight: bold;
            z-index: 999999;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
            animation: slideDown 0.3s ease;
            max-width: 500px;
            text-align: center;
        `;
        document.body.appendChild(toast);
    }
    
    const colors = {
        info: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
        success: 'linear-gradient(135deg, #11998e 0%, #38ef7d 100%)',
        warning: 'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
        error: 'linear-gradient(135deg, #ff6b6b 0%, #ee5a6f 100%)'
    };
    
    toast.textContent = message;
    toast.style.background = colors[type] || colors.info;
    toast.style.color = 'white';
    toast.style.display = 'block';
    
    if (duration > 0) {
        setTimeout(() => {
            toast.style.display = 'none';
        }, duration);
    }
}

	function initSocket() {
    if (!socket) {
        if (typeof io === 'undefined') {
            console.error('Socket.IO library not loaded.');
            alert('Multiplayer features unavailable. Please reload the page.');
            return;
        }
        
        if (!selectedRegion) {
            showToast('⚠️ Please select a region first!', 'warning');
            return;
        }
        
        connectToServerWithFailover();
    }
}

        // --- MP UI Functions ---
        function showMpName() { 
            hideAllScreens(); 
            if (!mpWarningShown) {
                document.getElementById('mp-warning-modal').style.display = 'flex';
            } else {
                document.getElementById('mp-name-menu').style.display = 'flex';
            }
	setTimeout(() => { if (document.getElementById('mp-name-menu').style.display === 'flex') measureAllRegions(); }, 500);
        }
        
        function enterMpMenu() {
    const name = document.getElementById('player-name-input').value;
    if (!name) return alert("Enter a name!");
    
    // Show region selector instead of immediately connecting
    hideAllScreens();
    document.getElementById('region-selector-screen').style.display = 'flex';
    
    measureAllRegions();

    if (pingLoop) clearInterval(pingLoop); // clear any old ones
    pingLoop = setInterval(() => {
        if (document.getElementById('region-selector-screen').style.display === 'flex') {
            measureAllRegions();
        } else {
            // Safety: Stop if we aren't on the screen anymore
            clearInterval(pingLoop);
        }
    }, 5000);
}

	function proceedToMultiplayer() {
    // Stop pinging so we don't lag the game
    if (pingLoop) clearInterval(pingLoop);

    if (!selectedRegion) {
        showToast('⚠️ Please select a region first!', 'warning');
        return;
    }
    
    initSocket();
}

        function hostGame() {
            const name = document.getElementById('player-name-input').value;
            socket.emit('createRoom', name);
        }

        function showJoinInput() { document.getElementById('join-input-area').style.display = 'flex'; }
        
        function joinGame() {
            const code = document.getElementById('room-code-input').value.toUpperCase();
            const name = document.getElementById('player-name-input').value;
            socket.emit('joinRoom', { roomId: code, playerName: name });
            
            // --- FIX: Save these so we can send updates later ---
            myRoomId = code;
            myRole = 'joiner'; 
        }
        
        function leaveLobby() { location.reload(); }

        function updateLobbyUI(players) {
    allPlayers = players; // SAVE THE PLAYERS GLOBALLY
    
    // Find my own index
    const mySock = socket.id;
    myPlayerIndex = allPlayers.findIndex(p => p.id === mySock);
    if(myPlayerIndex === -1) myPlayerIndex = 0; // Fallback

    hideAllScreens();
    checkMultiplayerStats();
    document.getElementById('lobby-screen').style.display = 'flex';
    document.getElementById('lobby-room-code').innerText = "CODE: " + myRoomId;
    
    // SHOW INVITE BUTTON (CrazyGames requirement)
    showInviteButton();
    
    const list = document.getElementById('lobby-player-list');
    list.innerHTML = players.map((p, i) => {
        // Show level for current player, "?" for others (since we don't have their levels)
        const level = (i === myPlayerIndex && window.playerLevel) ? window.playerLevel : '?';
        const levelBadge = `<span style="background: linear-gradient(135deg, #e67e22, #e74c3c); padding: 2px 8px; border-radius: 5px; font-size: 14px; margin-right: 8px;">LVL ${level}</span>`;
        return `<div style="color:${PLAYER_COLORS[i]}">${levelBadge}${p.name} ${p.role==='host'?'(HOST)':''}</div>`;
    }).join('');

    if (myRole === 'host') {
        document.getElementById('lobby-start-btn').style.display = 'block';
        document.getElementById('lobby-status').style.display = 'none';
    } else {
        document.getElementById('lobby-start-btn').style.display = 'none';
        document.getElementById('lobby-status').innerText = "Waiting for host to select map...";
        document.getElementById('lobby-status').style.display = 'block';
    }
}

        function setGamemode(mode) {
    currentGamemode = mode;
    isMultiplayerMode = true; // Set multiplayer flag
    hideAllScreens();
    document.getElementById('level-select').style.display = 'flex';
    
    // Override Map Selection for Multiplayer
    window.selectMap = function(idx) {
        selectedMapIndex = idx;
        hideAllScreens();
        document.getElementById('diff-select').style.display = 'flex';
	balanceMapGrid();
        
        // Override Start Game for Multiplayer
        window.startGame = function(diff) {
            console.log("Requesting start:", diff); // Debug check
            if(!socket || !myRoomId) {
                alert("Connection lost!");
                return;
            }
            socket.emit('requestStart', { 
                roomId: myRoomId, 
                mapIndex: selectedMapIndex, 
                diff: diff,
                mode: currentGamemode 
            });
        }
    }
}

	function showLevelSelectMP() {
            hideAllScreens();
            document.getElementById('mode-select').style.display = 'flex';
        }

    </script>
    
    <!-- PROGRESSION SYSTEM - EXTERNAL FILE -->
    <!-- Load the corrected progression system that fixes skill bonuses for single-player -->
    <script src="progression-FINAL-v5.js"></script>
    
    <!-- PROGRESSION SYSTEM - FULLY EMBEDDED (COMMENTED OUT - USING EXTERNAL FILE INSTEAD) -->
    <!--
    <script>
/**
 * KARLO'S TD - PROGRESSION SYSTEM V5.5 - GAME JOLT EDITION
 * 
 * NEW IN V5.5:
 * - 30+ Achievements with Game Jolt sync
 * - "Kill" → "Destroy" terminology throughout
 * - Fixed tracking for towers, upgrades, waves, gold
 * - Creative achievements (AFK, Close Call, Speedrunner, etc.)
 * - Trophy bridge to Game Jolt API
 */

(function() {
    'use strict';

    function waitForGame() {
        if (typeof scene === 'undefined' || typeof TOWERS === 'undefined') {
            setTimeout(waitForGame, 100);
            return;
        }
        initProgression();
    }

    function initProgression() {
        console.log('🚀 Initializing Progression V5.5 - Game Jolt Edition...');

        // ============================================
        // GLOBAL STATE
        // ============================================
        if (!window.playerLevel) window.playerLevel = 1;
        if (!window.playerXP) window.playerXP = 0;
        if (!window.skillPoints) window.skillPoints = 0;
        
        if (!window.unlockedTowers) {
            window.unlockedTowers = ['gunner', 'sniper', 'ice'];
        }

        window.allTowers = ['gunner', 'sniper', 'ice', 'minigun', 'cannon', 'flamethrower', 'mortar', 'tesla', 'laser', 'plasma', 'farm'];
        
        // Tower unlock levels (10 towers)
        window.towerUnlockLevels = {
            'gunner': 1,   // Starter
            'sniper': 1,   // Starter  
            'ice': 1,      // Starter
            'minigun': 3,  // Level 3
            'cannon': 5,   // Level 5
	    'flamethrower': 7,   // Level 7
            'mortar': 10,   // Level 10
            'tesla': 13,   // Level 13
            'laser': 16,   // Level 16
            'plasma': 19,  // Level 19
            'farm': 22     // Level 22
        };

        // Branch upgrade unlock system
        if (!window.unlockedUpgrades) {
            window.unlockedUpgrades = {};
            allTowers.forEach(tower => {
                window.unlockedUpgrades[tower] = {
                    branch1: 0,
                    branch2: 0
                };
            });
        }

        // Calculate which level unlocks which branch for which tower
        window.branchUnlockLevels = {};
        allTowers.forEach((tower, index) => {
            window.branchUnlockLevels[tower] = {
                branch1: 21 + (index * 2),
                branch2: 21 + (index * 2) + 1
            };
        });

        // FIXED: Enhanced lifetime stats tracking
        if (!window.lifetimeStats) {
            window.lifetimeStats = {
                gamesPlayed: 0,
                gamesWon: 0,
                totalDestroys: 0,        // Changed from totalKills
                totalDamage: 0,
                totalGoldEarned: 0,
                highestWave: 0,
                towersBuilt: 0,          // NEW: Track towers built
                upgradesPurchased: 0,    // NEW: Track upgrades
                totalWavesCompleted: 0   // NEW: Track total waves across all games
            };
        }

        if (!window.sessionStats) {
            window.sessionStats = {
                destroys: 0,           // Changed from kills
                damage: 0,
                wavesCompleted: 0,
                towersBuilt: 0,
                upgrades: 0
            };
        }

        if (!window.skills) {
            window.skills = {
                economy: {
                    interest: { level: 0, max: 5, cost: 1, name: 'Interest Rate', desc: '+2% gold interest per wave' },
                    startGold: { level: 0, max: 5, cost: 1, name: 'Starting Capital', desc: '+100 starting gold' },
                    farmBoost: { level: 0, max: 5, cost: 1, name: 'Farm Efficiency', desc: '+20% farm income' }
                },
                combat: {
                    damage: { level: 0, max: 5, cost: 1, name: 'Power Boost', desc: '+5% tower damage' },
                    range: { level: 0, max: 5, cost: 1, name: 'Extended Range', desc: '+10% tower range' },
                    attackSpeed: { level: 0, max: 5, cost: 1, name: 'Rapid Fire', desc: '+10% attack speed' }
                },
                special: {
                    lives: { level: 0, max: 3, cost: 2, name: 'Extra Lives', desc: '+5 starting lives' },
                    crit: { level: 0, max: 5, cost: 2, name: 'Critical Strike', desc: '+5% crit chance' },
                    multishot: { level: 0, max: 3, cost: 3, name: 'Multishot', desc: '+10% multishot chance' }
                }
            };
        }

        // ============================================
        // MASSIVE ACHIEVEMENT EXPANSION (30+ ACHIEVEMENTS)
        // ============================================
        if (!window.achievements) {
            window.achievements = [
                // === DESTRUCTION CATEGORY ===
                { 
                    id: 'first_blood', 
                    name: 'First Blood', 
                    desc: 'Destroy your first enemy', 
                    icon: '🩸', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDestroys >= 1
                },
                { 
                    id: 'destroy_100', 
                    name: 'Destroyer', 
                    desc: 'Destroy 100 enemies', 
                    icon: '💀', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDestroys >= 100
                },
                { 
                    id: 'destroy_1k', 
                    name: 'Annihilator', 
                    desc: 'Destroy 1,000 enemies', 
                    icon: '☠️', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDestroys >= 1000
                },
                { 
                    id: 'destroy_10k', 
                    name: 'Executioner', 
                    desc: 'Destroy 10,000 enemies', 
                    icon: '💀', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDestroys >= 10000
                },
                { 
                    id: 'destroy_50k', 
                    name: 'Obliterator', 
                    desc: 'Destroy 50,000 enemies', 
                    icon: '👹', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDestroys >= 50000
                },
                { 
                    id: 'destroy_100k', 
                    name: 'Genocide', 
                    desc: 'Destroy 100,000 enemies', 
                    icon: '💀', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDestroys >= 100000
                },
                { 
                    id: 'destroy_500k', 
                    name: 'Apocalypse', 
                    desc: 'Destroy 500,000 enemies', 
                    icon: '🔥', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDestroys >= 500000
                },

                // === WEALTH CATEGORY ===
                { 
                    id: 'gold_10k', 
                    name: 'Entrepreneur', 
                    desc: 'Earn 10,000 gold', 
                    icon: '💰', 
                    unlocked: false,
                    check: () => lifetimeStats.totalGoldEarned >= 10000
                },
                { 
                    id: 'gold_50k', 
                    name: 'Tycoon', 
                    desc: 'Earn 50,000 gold', 
                    icon: '💵', 
                    unlocked: false,
                    check: () => lifetimeStats.totalGoldEarned >= 50000
                },
                { 
                    id: 'gold_100k', 
                    name: 'Millionaire', 
                    desc: 'Earn 100,000 gold', 
                    icon: '💎', 
                    unlocked: false,
                    check: () => lifetimeStats.totalGoldEarned >= 100000
                },
                { 
                    id: 'gold_1m', 
                    name: 'Richie Rich', 
                    desc: 'Earn 1,000,000 gold', 
                    icon: '👑', 
                    unlocked: false,
                    check: () => lifetimeStats.totalGoldEarned >= 1000000
                },
                { 
                    id: 'gold_10m', 
                    name: 'Fort Knox', 
                    desc: 'Earn 10,000,000 gold', 
                    icon: '🏦', 
                    unlocked: false,
                    check: () => lifetimeStats.totalGoldEarned >= 10000000
                },

                // === SURVIVAL CATEGORY ===
                { 
                    id: 'wave_10', 
                    name: 'Survivor', 
                    desc: 'Reach Wave 10', 
                    icon: '🌊', 
                    unlocked: false,
                    check: () => lifetimeStats.highestWave >= 10
                },
                { 
                    id: 'wave_20', 
                    name: 'Veteran', 
                    desc: 'Reach Wave 20', 
                    icon: '🎖️', 
                    unlocked: false,
                    check: () => lifetimeStats.highestWave >= 20
                },
                { 
                    id: 'wave_30', 
                    name: 'Elite', 
                    desc: 'Reach Wave 30', 
                    icon: '⭐', 
                    unlocked: false,
                    check: () => lifetimeStats.highestWave >= 30
                },
                { 
                    id: 'wave_40', 
                    name: 'Master', 
                    desc: 'Reach Wave 40', 
                    icon: '🏆', 
                    unlocked: false,
                    check: () => lifetimeStats.highestWave >= 40
                },
                { 
                    id: 'wave_50', 
                    name: 'Legend', 
                    desc: 'Reach Wave 50', 
                    icon: '👑', 
                    unlocked: false,
                    check: () => lifetimeStats.highestWave >= 50
                },
                { 
                    id: 'wave_60', 
                    name: 'Immortal', 
                    desc: 'Reach Wave 60', 
                    icon: '💫', 
                    unlocked: false,
                    check: () => lifetimeStats.highestWave >= 60
                },
                { 
                    id: 'wave_100', 
                    name: 'Unstoppable', 
                    desc: 'Reach Wave 100', 
                    icon: '🌟', 
                    unlocked: false,
                    check: () => lifetimeStats.highestWave >= 100
                },

                // === BUILDER CATEGORY ===
                { 
                    id: 'towers_50', 
                    name: 'Architect', 
                    desc: 'Build 50 towers', 
                    icon: '🏗️', 
                    unlocked: false,
                    check: () => lifetimeStats.towersBuilt >= 50
                },
                { 
                    id: 'towers_100', 
                    name: 'Constructor', 
                    desc: 'Build 100 towers', 
                    icon: '🏢', 
                    unlocked: false,
                    check: () => lifetimeStats.towersBuilt >= 100
                },
                { 
                    id: 'towers_500', 
                    name: 'City Planner', 
                    desc: 'Build 500 towers', 
                    icon: '🏙️', 
                    unlocked: false,
                    check: () => lifetimeStats.towersBuilt >= 500
                },
                { 
                    id: 'towers_1000', 
                    name: 'Mega Builder', 
                    desc: 'Build 1,000 towers', 
                    icon: '🗼', 
                    unlocked: false,
                    check: () => lifetimeStats.towersBuilt >= 1000
                },

                // === UPGRADES CATEGORY ===
                { 
                    id: 'upgrades_50', 
                    name: 'Enhancer', 
                    desc: 'Perform 50 upgrades', 
                    icon: '⚡', 
                    unlocked: false,
                    check: () => lifetimeStats.upgradesPurchased >= 50
                },
                { 
                    id: 'upgrades_200', 
                    name: 'Power Player', 
                    desc: 'Perform 200 upgrades', 
                    icon: '🔋', 
                    unlocked: false,
                    check: () => lifetimeStats.upgradesPurchased >= 200
                },
                { 
                    id: 'upgrades_1000', 
                    name: 'Perfectionist', 
                    desc: 'Perform 1,000 upgrades', 
                    icon: '✨', 
                    unlocked: false,
                    check: () => lifetimeStats.upgradesPurchased >= 1000
                },

                // === CREATIVE/FUN ACHIEVEMENTS ===
                { 
                    id: 'first_win', 
                    name: 'First Victory', 
                    desc: 'Win your first game', 
                    icon: '🎉', 
                    unlocked: false,
                    check: () => lifetimeStats.gamesWon >= 1
                },
                { 
                    id: 'win_10', 
                    name: 'Champion', 
                    desc: 'Win 10 games', 
                    icon: '🏅', 
                    unlocked: false,
                    check: () => lifetimeStats.gamesWon >= 10
                },
                { 
                    id: 'close_call', 
                    name: 'Close Call', 
                    desc: 'Win with only 1 life remaining', 
                    icon: '😰', 
                    unlocked: false,
                    tracked: true,
                    check: () => false // Checked manually in win condition
                },
                { 
                    id: 'speedrunner', 
                    name: 'Speedrunner', 
                    desc: 'Beat Wave 20 in under 10 minutes', 
                    icon: '⏱️', 
                    unlocked: false,
                    tracked: true,
                    check: () => false // Checked manually with timer
                },
                { 
                    id: 'afk_master', 
                    name: 'AFK Master', 
                    desc: 'Win a game without pausing', 
                    icon: '😴', 
                    unlocked: false,
                    tracked: true,
                    check: () => false // Tracked during gameplay
                },
                { 
                    id: 'minimalist', 
                    name: 'Minimalist', 
                    desc: 'Win with less than 10 towers', 
                    icon: '🎯', 
                    unlocked: false,
                    tracked: true,
                    check: () => false // Checked at win
                },
                { 
                    id: 'big_spender', 
                    name: 'Big Spender', 
                    desc: 'Spend 50,000 gold in one game', 
                    icon: '💸', 
                    unlocked: false,
                    tracked: true,
                    check: () => false // Session tracking
                },
                { 
                    id: 'damage_dealer', 
                    name: 'Damage Dealer', 
                    desc: 'Deal 1,000,000 total damage', 
                    icon: '💥', 
                    unlocked: false,
                    check: () => lifetimeStats.totalDamage >= 1000000
                },
                { 
                    id: 'dedicated', 
                    name: 'Dedicated Player', 
                    desc: 'Play 100 games', 
                    icon: '🎮', 
                    unlocked: false,
                    check: () => lifetimeStats.gamesPlayed >= 100
                },
                { 
                    id: 'maxed_out', 
                    name: 'Maxed Out', 
                    desc: 'Reach level 50', 
                    icon: '🌟', 
                    unlocked: false,
                    check: () => playerLevel >= 50
                }
            ];
        }

        if (!window.unlockedAchievements) {
            window.unlockedAchievements = [];
        }

        // ============================================
        // XP & LEVELING
        // ============================================
        window.xpForLevel = function(level) {
            return Math.floor(100 * Math.pow(1.15, level - 1));
        };

        // ============================================
        // TRACKING HOOKS - CRITICAL FOR ACHIEVEMENTS
        // ============================================
        
        // Hook into tower building
        window.trackTowerBuilt = function() {
            lifetimeStats.towersBuilt++;
            sessionStats.towersBuilt++;
            saveProgress();
            checkAchievements();
            
            // Update daily challenges
            if (typeof updateDailyChallenges === 'function') {
                updateDailyChallenges();
            }
        };

        // Hook into tower upgrades
        window.trackUpgrade = function() {
            lifetimeStats.upgradesPurchased++;
            sessionStats.upgrades++;
            saveProgress();
            checkAchievements();
            
            // Update daily challenges
            if (typeof updateDailyChallenges === 'function') {
                updateDailyChallenges();
            }
        };

        // Hook into enemy destruction
        window.trackEnemyDestroyed = function(goldValue = 0) {
            lifetimeStats.totalDestroys++;
            sessionStats.destroys++;
            
            if (goldValue > 0) {
                lifetimeStats.totalGoldEarned += goldValue;
            }
            
            saveProgress();
            checkAchievements();
            
            // Update daily challenges
            if (typeof updateDailyChallenges === 'function') {
                updateDailyChallenges();
            }
        };

        // Hook into wave completion
        window.trackWaveCompleted = function(waveNumber) {
            lifetimeStats.totalWavesCompleted++;
            sessionStats.wavesCompleted++;
            
            if (waveNumber > lifetimeStats.highestWave) {
                lifetimeStats.highestWave = waveNumber;
            }
            
            saveProgress();
            checkAchievements();
            
            // Update daily challenges
            if (typeof updateDailyChallenges === 'function') {
                updateDailyChallenges();
            }
        };

        // Hook into game completion
        window.trackGameWon = function(finalLives, totalTowers) {
            lifetimeStats.gamesWon++;
            
            // Check special achievements
            if (finalLives === 1) {
                unlockAchievement('close_call');
            }
            
            if (totalTowers < 10) {
                unlockAchievement('minimalist');
            }
            
            saveProgress();
            checkAchievements();
        };

        // ============================================
        // ACHIEVEMENT SYSTEM WITH GAME JOLT SYNC
        // ============================================
        window.checkAchievements = function() {
            achievements.forEach(ach => {
                if (!ach.unlocked && !ach.tracked) {
                    if (ach.check()) {
                        unlockAchievement(ach.id);
                    }
                }
            });
        };

        window.unlockAchievement = function(achId) {
            const ach = achievements.find(a => a.id === achId);
            if (!ach || ach.unlocked) return;

            ach.unlocked = true;
            unlockedAchievements.push(achId);

            console.log(`🏆 Achievement Unlocked: ${ach.name}`);
            
            // Show local popup
            showAchievementPopup(ach);

            // CRITICAL: Sync to Game Jolt
            if (typeof window.unlockTrophy === 'function') {
                window.unlockTrophy(achId);
            }

            saveProgress();
        };

        window.showAchievementPopup = function(ach) {
            const popup = document.createElement('div');
            popup.id = 'achievement-popup';
            popup.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: linear-gradient(135deg, #27ae60, #229954);
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 8px 25px rgba(0,0,0,0.5);
                z-index: 1000000;
                animation: slideIn 0.5s ease-out;
                max-width: 350px;
            `;
            popup.innerHTML = `
                <div style="display: flex; align-items: center; gap: 15px;">
                    <div style="font-size: 48px;">${ach.icon}</div>
                    <div>
                        <div style="font-size: 14px; opacity: 0.9;">Achievement Unlocked!</div>
                        <div style="font-size: 20px; margin-top: 5px;">${ach.name}</div>
                        <div style="font-size: 14px; opacity: 0.8; margin-top: 3px;">${ach.desc}</div>
                    </div>
                </div>
            `;
            document.body.appendChild(popup);

            setTimeout(() => {
                popup.style.animation = 'slideOut 0.5s ease-in';
                setTimeout(() => popup.remove(), 500);
            }, 4000);
        };

        // ============================================
        // SKILL TREE
        // ============================================
        window.unlockSkill = function(category, skill) {
            const s = skills[category][skill];
            if (s.level >= s.max) return alert('Max level!');
            if (skillPoints < s.cost) return alert('Not enough skill points!');

            skillPoints -= s.cost;
            s.level++;

            console.log(`✨ Unlocked ${s.name} Level ${s.level}`);
            updateSkillTree();
            saveProgress();
            
            // Apply bonuses immediately
            if (typeof applySkillBonuses === 'function') {
                applySkillBonuses();
            }
        };
        
        // ✅ APPLY SKILL BONUSES - Called when game starts
        window.applySkillBonuses = function() {
            console.log('⚡ Applying skill bonuses...');
            
            // This function is called by the game engine
            // The bonuses are already applied via getSkillMultipliers()
            // which is called throughout the game code
            
            // Economy bonuses
            if (skills.economy.startGold.level > 0) {
                console.log(`💰 Starting gold bonus: +${skills.economy.startGold.level * 100}`);
            }
            
            // Special bonuses
            if (skills.special.lives.level > 0) {
                console.log(`❤️ Extra lives: +${skills.special.lives.level * 5}`);
            }
            
            console.log('✅ Skill bonuses active');
        };
        
        // Get skill multipliers for game mechanics
        window.getSkillMultipliers = function() {
            // CRITICAL: Disable skill bonuses in multiplayer mode
            if (isMultiplayerMode) {
                console.log('⚠️ Skill bonuses DISABLED in multiplayer mode');
                return {
                    damage: 1,
                    range: 1,
                    attackSpeed: 1,
                    startGold: 0,
                    extraLives: 0,
                    interest: 0,
                    farmBoost: 1,
                    critChance: 0,
                    multishotChance: 0
                };
            }
            
            // Normal skill bonuses for single player
            return {
                damage: 1 + (skills.combat.damage.level * 0.05),
                range: 1 + (skills.combat.range.level * 0.1),
                attackSpeed: 1 + (skills.combat.attackSpeed.level * 0.1),
                startGold: skills.economy.startGold.level * 100,
                extraLives: skills.special.lives.level * 5,
                interest: skills.economy.interest.level * 0.02,
                farmBoost: 1 + (skills.economy.farmBoost.level * 0.2),
                critChance: skills.special.crit.level * 0.05,
                multishotChance: skills.special.multishot.level * 0.1
            };
        };

        // ============================================
        // UI UPDATES
        // ============================================
        window.updateXPBar = function() {
            console.log('🔄 updateXPBar called');
            const badge = document.getElementById('player-level-badge');
            const fill = document.getElementById('xp-bar-fill');
            const text = document.getElementById('xp-bar-text');

            if (badge) {
                badge.innerText = `LVL ${window.playerLevel}`;
                console.log(`📊 Badge updated to Level ${window.playerLevel}`);
            } else {
                console.warn('⚠️ player-level-badge element not found!');
            }
            
            const needed = window.xpForLevel(window.playerLevel + 1);
            const percent = (window.playerXP / needed) * 100;
            
            if (fill) {
                fill.style.width = `${percent}%`;
                console.log(`📊 Fill bar updated to ${percent.toFixed(1)}%`);
            } else {
                console.warn('⚠️ xp-bar-fill element not found!');
            }
            
            if (text) {
                text.innerText = `${window.playerXP} / ${needed} XP`;
                console.log(`📊 Text updated to ${window.playerXP}/${needed}`);
            } else {
                console.warn('⚠️ xp-bar-text element not found!');
            }
        };

        window.showLevelUpPopup = function() {
            console.log('🎉 showLevelUpPopup called for level', window.playerLevel);
            const earnedSP = (window.playerLevel % 5 === 0);
            
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%) scale(0);
                background: linear-gradient(135deg, #9b59b6, #8e44ad);
                color: white;
                padding: 40px 60px;
                border-radius: 20px;
                font-size: 32px;
                font-weight: 900;
                text-align: center;
                box-shadow: 0 15px 40px rgba(0,0,0,0.7);
                z-index: 2000000;
                animation: popIn 0.6s ease-out forwards;
            `;
            popup.innerHTML = `
                <div style="font-size: 72px; margin-bottom: 15px;">🎉</div>
                <div>LEVEL UP!</div>
                <div style="font-size: 48px; margin-top: 10px;">Level ${window.playerLevel}</div>
                ${earnedSP ? '<div style="font-size: 18px; margin-top: 15px; opacity: 0.9; color: #f1c40f;">⭐ +1 Skill Point ⭐</div>' : ''}
            `;
            document.body.appendChild(popup);
            console.log('✅ Level up popup added to DOM');

            setTimeout(() => {
                popup.style.animation = 'popOut 0.4s ease-in forwards';
                setTimeout(() => popup.remove(), 400);
            }, 2500);
        };

        window.showUnlockNotif = function(message) {
            const notif = document.createElement('div');
            notif.style.cssText = `
                position: fixed;
                top: 180px;
                right: 20px;
                background: linear-gradient(135deg, #3498db, #2980b9);
                color: white;
                padding: 15px 25px;
                border-radius: 12px;
                font-size: 16px;
                font-weight: bold;
                box-shadow: 0 6px 20px rgba(0,0,0,0.4);
                z-index: 1000000;
                animation: slideIn 0.4s ease-out;
            `;
            notif.innerText = message;
            document.body.appendChild(notif);

            setTimeout(() => {
                notif.style.animation = 'slideOut 0.4s ease-in';
                setTimeout(() => notif.remove(), 400);
            }, 3000);
        };

        // Show achievement/challenge completion popup
        window.showAchievement = function(title, desc, reward) {
            const popup = document.createElement('div');
            popup.style.cssText = `
                position: fixed;
                top: 100px;
                right: 20px;
                background: linear-gradient(135deg, #f39c12, #e67e22);
                color: white;
                padding: 20px 30px;
                border-radius: 15px;
                font-size: 18px;
                font-weight: bold;
                box-shadow: 0 8px 25px rgba(0,0,0,0.5);
                z-index: 1000000;
                animation: slideIn 0.5s ease-out;
                max-width: 350px;
            `;
            popup.innerHTML = `
                <div style="font-size: 14px; opacity: 0.9;">Challenge Complete!</div>
                <div style="font-size: 20px; margin-top: 5px;">${title}</div>
                <div style="font-size: 14px; opacity: 0.8; margin-top: 3px;">${desc}</div>
                <div style="font-size: 16px; margin-top: 8px; color: #2ecc71;">✅ ${reward}</div>
            `;
            document.body.appendChild(popup);

            setTimeout(() => {
                popup.style.animation = 'slideOut 0.5s ease-in';
                setTimeout(() => popup.remove(), 500);
            }, 4000);
        };

        // ============================================
        // SAVE/LOAD
        // ============================================
        window.saveProgress = function() {
            const data = {
                playerLevel, playerXP, skillPoints,
                unlockedTowers, unlockedUpgrades, lifetimeStats,
                skills, unlockedAchievements, dailyChallenges
            };
            localStorage.setItem('karlotd_progress_v5_5', JSON.stringify(data));
        };

        window.loadProgress = function() {
            const saved = localStorage.getItem('karlotd_progress_v5_5');
            if (!saved) return;

            try {
                const data = JSON.parse(saved);
                window.playerLevel = data.playerLevel || 1;
                window.playerXP = data.playerXP || 0;
                window.skillPoints = data.skillPoints || 0;
                window.unlockedTowers = data.unlockedTowers || ['gunner', 'sniper', 'ice'];
                window.unlockedUpgrades = data.unlockedUpgrades || {};
                window.dailyChallenges = data.dailyChallenges || [];
                window.lifetimeStats = data.lifetimeStats || {
                    gamesPlayed: 0, gamesWon: 0, totalDestroys: 0,
                    totalDamage: 0, totalGoldEarned: 0, highestWave: 0,
                    towersBuilt: 0, upgradesPurchased: 0, totalWavesCompleted: 0
                };
                window.skills = data.skills || skills;
                window.unlockedAchievements = data.unlockedAchievements || [];

                // Mark achievements as unlocked
                unlockedAchievements.forEach(achId => {
                    const ach = achievements.find(a => a.id === achId);
                    if (ach) ach.unlocked = true;
                });

                console.log('✅ Progress loaded');
            } catch (e) {
                console.error('Failed to load progress:', e);
            }
        };

        // ============================================
        // INITIALIZE
        // ============================================
        loadProgress();
        updateXPBar();
        checkAchievements();
        
        // Delayed XP bar update to ensure it shows after all scripts load
        setTimeout(() => {
            if (typeof window.updateXPBar === 'function') {
                window.updateXPBar();
                console.log('🔄 XP bar updated after delayed init');
            }
        }, 500);

        // Add CSS animations
        if (!document.getElementById('achievement-animations')) {
            const style = document.createElement('style');
            style.id = 'achievement-animations';
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(400px); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(400px); opacity: 0; }
                }
                @keyframes popIn {
                    0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
                    50% { transform: translate(-50%, -50%) scale(1.1); }
                    100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                }
                @keyframes popOut {
                    0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
                    100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
                }
            `;
            document.head.appendChild(style);
        }

        console.log('✅ Progression V5.5 initialized with 30+ achievements');
        
        // ============================================
        // DAILY CHALLENGES SYSTEM
        // ============================================
        
        if (!window.dailyChallenges) {
            window.dailyChallenges = [];
        }
        
        // All possible challenges (20+)
        window.challengePool = [
            // KILL CHALLENGES (5)
            { name: 'Rookie Hunter', desc: 'Kill 100 enemies', progress: 0, target: 100, reward: '150 XP', completed: false, track: 'kills' },
            { name: 'Sharpshooter', desc: 'Kill 200 enemies', progress: 0, target: 200, reward: '300 XP', completed: false, track: 'kills' },
            { name: 'Mass Destruction', desc: 'Kill 300 enemies', progress: 0, target: 300, reward: '500 XP + 1 SP', completed: false, track: 'kills' },
            { name: 'Exterminator', desc: 'Kill 150 enemies', progress: 0, target: 150, reward: '250 XP', completed: false, track: 'kills' },
            { name: 'Elite Slayer', desc: 'Kill 250 enemies', progress: 0, target: 250, reward: '400 XP + 1 SP', completed: false, track: 'kills' },
            
            // TOWER CHALLENGES (5)
            { name: 'Builder Apprentice', desc: 'Build 10 towers', progress: 0, target: 10, reward: '150 XP', completed: false, track: 'towers' },
            { name: 'Tower Master', desc: 'Build 15 towers', progress: 0, target: 15, reward: '200 XP', completed: false, track: 'towers' },
            { name: 'Defense Architect', desc: 'Build 20 towers', progress: 0, target: 20, reward: '300 XP + 1 SP', completed: false, track: 'towers' },
            { name: 'Fortress Builder', desc: 'Build 12 towers', progress: 0, target: 12, reward: '175 XP', completed: false, track: 'towers' },
            { name: 'Strategic Placer', desc: 'Build 18 towers', progress: 0, target: 18, reward: '250 XP', completed: false, track: 'towers' },
            
            // WAVE CHALLENGES (5)
            { name: 'Wave Warrior', desc: 'Complete 10 waves', progress: 0, target: 10, reward: '150 XP', completed: false, track: 'waves' },
            { name: 'Survivor', desc: 'Complete 15 waves', progress: 0, target: 15, reward: '200 XP', completed: false, track: 'waves' },
            { name: 'Marathon Runner', desc: 'Complete 20 waves', progress: 0, target: 20, reward: '300 XP + 1 SP', completed: false, track: 'waves' },
            { name: 'Endurance Test', desc: 'Complete 25 waves', progress: 0, target: 25, reward: '400 XP + 1 SP', completed: false, track: 'waves' },
            { name: 'Wave Master', desc: 'Complete 12 waves', progress: 0, target: 12, reward: '175 XP', completed: false, track: 'waves' },
            
            // DAMAGE CHALLENGES (5)
            { name: 'Damage Dealer', desc: 'Deal 50,000 damage', progress: 0, target: 50000, reward: '200 XP', completed: false, track: 'damage' },
            { name: 'Heavy Artillery', desc: 'Deal 100,000 damage', progress: 0, target: 100000, reward: '300 XP + 1 SP', completed: false, track: 'damage' },
            { name: 'Destruction Expert', desc: 'Deal 75,000 damage', progress: 0, target: 75000, reward: '250 XP', completed: false, track: 'damage' },
            { name: 'Overwhelming Force', desc: 'Deal 150,000 damage', progress: 0, target: 150000, reward: '500 XP + 2 SP', completed: false, track: 'damage' },
            { name: 'Power House', desc: 'Deal 60,000 damage', progress: 0, target: 60000, reward: '225 XP', completed: false, track: 'damage' },
            
            // UPGRADE CHALLENGES (3)
            { name: 'Upgrade Novice', desc: 'Upgrade 5 towers', progress: 0, target: 5, reward: '150 XP', completed: false, track: 'upgrades' },
            { name: 'Power Up', desc: 'Upgrade 10 towers', progress: 0, target: 10, reward: '250 XP', completed: false, track: 'upgrades' },
            { name: 'Max Power', desc: 'Upgrade 15 towers', progress: 0, target: 15, reward: '350 XP + 1 SP', completed: false, track: 'upgrades' }
        ];
        
        // Get today's date string
        window.getTodayDateString = function() {
            const now = new Date();
            const cetOffset = 1;
            const cetTime = new Date(now.getTime() + (cetOffset * 60 * 60 * 1000));
            
            const year = cetTime.getUTCFullYear();
            const month = cetTime.getUTCMonth();
            const day = cetTime.getUTCDate();
            const hour = cetTime.getUTCHours();
            
            const adjustedDate = new Date(Date.UTC(year, month, day));
            if (hour < 11) {
                adjustedDate.setUTCDate(adjustedDate.getUTCDate() - 1);
            }
            
            return adjustedDate.toISOString().split('T')[0];
        };
        
        // Generate 3 random challenges for today
        window.generateDailyChallenges = function() {
            const dateString = getTodayDateString();
            
            let seed = 0;
            for (let i = 0; i < dateString.length; i++) {
                seed = ((seed << 5) - seed) + dateString.charCodeAt(i);
                seed = seed & seed;
            }
            
            const seededRandom = function() {
                seed = (seed * 9301 + 49297) % 233280;
                return seed / 233280;
            };
            
            const shuffled = [...challengePool];
            for (let i = shuffled.length - 1; i > 0; i--) {
                const j = Math.floor(seededRandom() * (i + 1));
                [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]];
            }
            
            const selected = [];
            const usedTracks = new Set();
            
            for (const challenge of shuffled) {
                if (selected.length >= 3) break;
                
                if (selected.length < 2 || !usedTracks.has(challenge.track)) {
                    selected.push({...challenge});
                    usedTracks.add(challenge.track);
                }
            }
            
            while (selected.length < 3 && selected.length < shuffled.length) {
                const next = shuffled.find(c => !selected.includes(c));
                if (next) selected.push({...next});
            }
            
            return selected;
        };
        
        // Initialize or refresh daily challenges
        window.initDailyChallenges = function() {
            const today = getTodayDateString();
            const lastRefresh = localStorage.getItem('karlos_td_challenge_date');
            
            if (lastRefresh !== today || !window.dailyChallenges || window.dailyChallenges.length === 0) {
                console.log(`📅 New day detected! Generating fresh challenges for ${today}`);
                window.dailyChallenges = generateDailyChallenges();
                localStorage.setItem('karlos_td_challenge_date', today);
                saveProgress();
            } else {
                console.log(`✅ Challenges already set for today (${today})`);
            }
        };
        
        // Update challenge progress
        window.updateDailyChallenges = function() {
            if (!window.dailyChallenges || window.dailyChallenges.length === 0) return;
            
            dailyChallenges.forEach(challenge => {
                if (challenge.completed) return;
                
                let current = 0;
                switch(challenge.track) {
                    case 'kills':
                        current = sessionStats.destroys || 0;
                        break;
                    case 'towers':
                        current = sessionStats.towersBuilt || 0;
                        break;
                    case 'waves':
                        current = sessionStats.wavesCompleted || 0;
                        break;
                    case 'damage':
                        current = sessionStats.damage || 0;
                        break;
                    case 'upgrades':
                        current = sessionStats.upgrades || 0;
                        break;
                }
                
                challenge.progress = Math.min(current, challenge.target);
                
                if (challenge.progress >= challenge.target && !challenge.completed) {
                    challenge.completed = true;
                    
                    // Parse reward
                    const rewardMatch = challenge.reward.match(/(\d+)\s*XP/);
                    const spMatch = challenge.reward.match(/(\d+)\s*SP/);
                    
                    if (rewardMatch) {
                        const xp = parseInt(rewardMatch[1]);
                        addXP(xp);
                        showFloatingText(`+${xp} XP`, 'xp');
                    }
                    
                    if (spMatch) {
                        const sp = parseInt(spMatch[1]);
                        skillPoints += sp;
                        showFloatingText(`+${sp} SP`, 'sp');
                    }
                    
                    console.log(`🎉 Daily Challenge Complete: ${challenge.name}`);
                    saveProgress();
                }
            });
        };
        
        // Initialize challenges on game load
        initDailyChallenges();
        
        console.log('✅ Daily Challenges system initialized');
    }

    // Start initialization
    waitForGame();
})();
</script>
-->
<!-- END OF COMMENTED EMBEDDED PROGRESSION -->

<script>
// ============================================
// MISSING FUNCTIONS - ADD THEM GLOBALLY
// ============================================

/**
 * Update Skill Tree Display
 * Called when skill tree modal opens
 */
window.updateSkillTree = function() {
    console.log('🌳 Updating skill tree display...');
    const container = document.getElementById('skill-tree-container');
    if (!container) {
        console.error('❌ skill-tree-container not found');
        return;
    }
    
    // Update skill points display
    const spCount = document.getElementById('skill-points-count');
    if (spCount) spCount.innerText = window.skillPoints || 0;
    
    container.innerHTML = `
        <div style="text-align: center; margin-bottom: 20px;">
            <h3 style="color: #f39c12;">Skill Points: ${window.skillPoints || 0}</h3>
        </div>
    `;
    
    if (!window.skills) {
        container.innerHTML += '<p style="color: #e74c3c;">Skills not loaded yet. Please restart the game.</p>';
        return;
    }
    
    Object.keys(window.skills).forEach(category => {
        const catDiv = document.createElement('div');
        catDiv.style.cssText = 'background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; margin-bottom: 15px;';
        
        const categoryIcons = {
            economy: '💰',
            combat: '⚔️',
            special: '⭐'
        };
        
        catDiv.innerHTML = `<h4 style="color: #3498db; text-transform: uppercase;">${categoryIcons[category] || ''} ${category}</h4>`;
        
        Object.keys(window.skills[category]).forEach(skillKey => {
            const skill = window.skills[category][skillKey];
            const skillDiv = document.createElement('div');
            skillDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; padding: 10px; background: rgba(0,0,0,0.3); border-radius: 5px; margin-top: 10px;';
            skillDiv.innerHTML = `
                <div>
                    <strong style="color: white;">${skill.name}</strong><br>
                    <small style="color: #aaa;">${skill.desc}</small><br>
                    <small style="color: #f39c12;">Level: ${skill.level}/${skill.max}</small>
                </div>
                <button class="btn" style="padding: 8px 15px; ${skill.level >= skill.max || (window.skillPoints || 0) < skill.cost ? 'opacity: 0.5; cursor: not-allowed;' : ''}" 
                    ${skill.level >= skill.max || (window.skillPoints || 0) < skill.cost ? 'disabled' : ''}
                    onclick="upgradeSkill('${category}', '${skillKey}')">
                    ${skill.level >= skill.max ? 'MAXED' : `Upgrade (${skill.cost} SP)`}
                </button>
            `;
            catDiv.appendChild(skillDiv);
        });
        
        container.appendChild(catDiv);
    });
};

/**
 * Upgrade a skill
 */
window.upgradeSkill = function(category, skillKey) {
    if (!window.skills || !window.skills[category] || !window.skills[category][skillKey]) return;
    
    const skill = window.skills[category][skillKey];
    if (skill.level >= skill.max || (window.skillPoints || 0) < skill.cost) return;
    
    window.skillPoints -= skill.cost;
    skill.level++;
    
    if (typeof window.saveProgress === 'function') {
        window.saveProgress();
    }
    
    updateSkillTree();
    if (typeof window.updateXPBar === 'function') {
        window.updateXPBar();
    }
    
    console.log(`✅ Upgraded ${skill.name} to level ${skill.level}`);
};

/**
 * Generate Daily Challenge
 */
window.generateDailyChallenge = function() {
    console.log('📅 Generating daily challenge...');
    const today = new Date().toDateString();
    
    if (window.dailyChallenges && window.dailyChallenges.length > 0 && window.dailyChallenges[0].date === today) {
        return window.dailyChallenges[0];
    }
    
    const challenges = [
        { type: 'destroys', target: 50, desc: 'Destroy 50 enemies', reward: '100 XP', icon: '💀' },
        { type: 'waves', target: 10, desc: 'Survive 10 waves', reward: '150 XP', icon: '🌊' },
        { type: 'noLoss', target: 1, desc: 'Complete a game without losing lives', reward: '200 XP', icon: '❤️' },
        { type: 'gold', target: 5000, desc: 'Earn 5,000 gold in one game', reward: '120 XP', icon: '💰' },
        { type: 'towers', target: 20, desc: 'Build 20 towers in one game', reward: '100 XP', icon: '🗼' }
    ];
    
    const challenge = challenges[Math.floor(Math.random() * challenges.length)];
    challenge.date = today;
    challenge.progress = 0;
    challenge.completed = false;
    
    if (!window.dailyChallenges) window.dailyChallenges = [];
    window.dailyChallenges = [challenge];
    
    if (typeof window.saveProgress === 'function') {
        window.saveProgress();
    }
    
    return challenge;
};

/**
 * Update Daily Challenge Display
 */
window.updateDailyChallenges = function() {
    const container = document.getElementById('challenges-container');
    if (!container) return;
    
    const challenge = generateDailyChallenge();
    const progressPct = Math.min((challenge.progress / challenge.target * 100), 100);
    
    container.innerHTML = `
        <div style="background: rgba(255,255,255,0.1); padding: 20px; border-radius: 10px; margin: 20px 0;">
            <div style="font-size: 48px; text-align: center; margin-bottom: 10px;">${challenge.icon || '📋'}</div>
            <h3 style="color: #f39c12; margin: 0 0 10px 0; text-align: center;">📅 Daily Challenge</h3>
            <p style="font-size: 18px; margin: 0 0 15px 0; text-align: center;">${challenge.desc}</p>
            <div style="background: rgba(0,0,0,0.3); padding: 3px; border-radius: 10px; margin-bottom: 10px;">
                <div style="
                    background: linear-gradient(90deg, #2ecc71, #27ae60);
                    height: 30px;
                    border-radius: 8px;
                    width: ${progressPct}%;
                    transition: width 0.3s ease;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                ">
                    <span style="color: white; font-weight: bold; text-shadow: 0 2px 4px rgba(0,0,0,0.5);">
                        ${challenge.progress} / ${challenge.target}
                    </span>
                </div>
            </div>
            <p style="color: #2ecc71; margin: 10px 0 0 0; text-align: center; font-size: 16px;">
                ${challenge.completed ? '✅ COMPLETED!' : `Reward: ${challenge.reward}`}
            </p>
        </div>
    `;
};
</script>

<script>
    // Map category filtering
    let currentMapCategory = 'all';

    function filterMapCategory(category) {
        currentMapCategory = category;
        
        // Update tab styles
        document.querySelectorAll('.category-tab').forEach(tab => {
            tab.classList.remove('active');
            if (tab.dataset.category === category) {
                tab.classList.add('active');
            }
        });
        
        // FIX: Only target map cards inside the 'map-container' ID
        // This prevents it from hiding the Difficulty or Gamemode buttons!
        const cards = document.querySelectorAll('#map-container .map-card');
        
        cards.forEach(card => {
            const difficulty = card.dataset.difficulty;
            if (category === 'all' || difficulty === category) {
                card.style.display = 'flex';
                card.style.flexDirection = 'column';
            } else {
                card.style.display = 'none';
            }
        });
    }

    // --- OFFLINE PROTECTION SYSTEM ---
    
    // 1. Check internet before opening Multiplayer Menu
    // Wait for DOM to be fully loaded just in case
    document.addEventListener('DOMContentLoaded', () => {
        console.log('🎮 DOM loaded, initializing UI updates...');
        
        // Initial XP bar update after a short delay to ensure progression is loaded
        setTimeout(() => {
            if (typeof window.updateXPBar === 'function') {
                window.updateXPBar();
                console.log('✅ Initial XP bar update completed');
            }
        }, 1000);
        
        // Update XP bar every 2 seconds (backup in case event updates fail)
        setInterval(() => {
            if (typeof window.updateXPBar === 'function' && window.playerLevel) {
                window.updateXPBar();
            }
        }, 2000);
        
        const multiBtn = document.getElementById('btn-multiplayer');
        
        if(multiBtn) {
            console.log("✅ Offline Protection Active: Multiplayer button found.");
            // Save the original onclick function
            const originalOnClick = multiBtn.onclick; 
            
            multiBtn.onclick = function(e) {
                if (!navigator.onLine) {
                    // Player is Offline
                    alert("⚠️ OFFLINE MODE\n\nYou are not connected to the internet.\nMultiplayer features are disabled.");
                    e.preventDefault();
                    e.stopPropagation();
                    return; // Stop here! Don't run the multiplayer code.
                }
                
                // If Online, run the original code
                if(originalOnClick) originalOnClick.call(this, e);
            };
        } else {
            console.warn("⚠️ Offline Protection: 'btn-multiplayer' not found!");
        }
    });

    // 2. Handle Server Connection Failures
    const checkSocketInterval = setInterval(() => {
        if (typeof socket !== 'undefined') {
            clearInterval(checkSocketInterval);
            
            socket.on('connect_error', () => {
                // Only alert if we are actually in a multiplayer screen
                const lobby = document.getElementById('lobby-screen');
                const mpMenu = document.getElementById('mp-menu');
                
                if((lobby && lobby.style.display === 'flex') || (mpMenu && mpMenu.style.display === 'flex')) {
                    alert("❌ SERVER ERROR\n\nCould not connect to the game server.\nIt might be down for maintenance.");
                    // Force them back to main menu
                    if(typeof goToMainMenu === 'function') goToMainMenu();
                }
            });
        }
    }, 1000);


</script>
</body>
</html
    
    <!-- Advanced Graphics Modal -->
    <div id="advanced-graphics-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); backdrop-filter: blur(8px); z-index: 2000000; justify-content: center; align-items: center; pointer-events: auto;" onclick="event.target === this && closeAdvancedGraphics()">
        <div class="advanced-graphics-content" style="width: 600px; max-width: 90%; background: #1e293b; border: 4px solid #3498db; border-radius: 20px; overflow: hidden; display: flex; flex-direction: column; max-height: 90vh; position: relative; z-index: 2000001;" onclick="event.stopPropagation()">
            <div class="advanced-header" style="background: #0f172a; padding: 20px; text-align: center; border-bottom: 2px solid #3498db;">
                <h2 style="margin: 0; font-size: 28px; color: #3498db;">⚙️ ADVANCED GRAPHICS</h2>
            </div>
            <div style="padding: 20px; overflow-y: auto; flex: 1;">
                <div style="display: flex; flex-direction: column; gap: 15px;">
                    <!-- Shadows -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px; font-weight: bold;">Shadows</label>
                        <input type="checkbox" id="adv-shadows" onchange="updateAdvancedSetting('shadowsEnabled', this.checked)" style="width: 24px; height: 24px;">
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px;">Shadow Resolution</label>
                        <select id="adv-shadow-res" onchange="updateAdvancedSetting('shadowResolution', parseInt(this.value))" style="padding: 5px; font-size: 14px;">
                            <option value="512">512px - Fast</option>
                            <option value="1024">1024px - Balanced</option>
                            <option value="2048" selected>2048px - High</option>
                            <option value="4096">4096px - Ultra</option>
                        </select>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px;">Shadow Softness</label>
                        <select id="adv-shadow-soft" onchange="updateAdvancedSetting('shadowSoftness', parseInt(this.value))" style="padding: 5px; font-size: 14px;">
                            <option value="0">Hard</option>
                            <option value="1">PCF</option>
                            <option value="2" selected>PCF Soft</option>
                        </select>
                    </div>
                    
                    <!-- Lighting -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px;">Lighting Quality</label>
                        <div style="flex: 1; margin-left: 15px; display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="adv-lighting" min="0" max="1" step="0.1" value="1" onchange="updateAdvancedSetting('lightingQuality', parseFloat(this.value)); document.getElementById('lighting-val').innerText = this.value" style="flex: 1;">
                            <span id="lighting-val" style="min-width: 30px; text-align: right;">1.0</span>
                        </div>
                    </div>
                    
                    <!-- Bloom -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px; font-weight: bold;">Bloom</label>
                        <input type="checkbox" id="adv-bloom" onchange="updateAdvancedSetting('bloomEnabled', this.checked)" style="width: 24px; height: 24px;" checked>
                    </div>
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px;">Bloom Intensity</label>
                        <div style="flex: 1; margin-left: 15px; display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="adv-bloom-int" min="0" max="3" step="0.1" value="1.5" onchange="updateAdvancedSetting('bloomIntensity', parseFloat(this.value)); document.getElementById('bloom-val').innerText = this.value" style="flex: 1;">
                            <span id="bloom-val" style="min-width: 30px; text-align: right;">1.5</span>
                        </div>
                    </div>
                    
                    <!-- Post Processing -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px; font-weight: bold;">Post Processing</label>
                        <input type="checkbox" id="adv-post" onchange="updateAdvancedSetting('postProcessingEnabled', this.checked)" style="width: 24px; height: 24px;" checked>
                    </div>
                    
                    <!-- Render Distance -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px;">Render Distance</label>
                        <div style="flex: 1; margin-left: 15px; display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="adv-render-dist" min="0.5" max="1.5" step="0.1" value="1" onchange="updateAdvancedSetting('renderDistance', parseFloat(this.value)); document.getElementById('render-val').innerText = this.value + 'x'" style="flex: 1;">
                            <span id="render-val" style="min-width: 40px; text-align: right;">1.0x</span>
                        </div>
                    </div>
                    
                    <!-- Pixel Ratio -->
                    <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px; background: #0f172a; border-radius: 8px;">
                        <label style="font-size: 16px;">Pixel Ratio</label>
                        <div style="flex: 1; margin-left: 15px; display: flex; align-items: center; gap: 10px;">
                            <input type="range" id="adv-pixel" min="0.5" max="2" step="0.25" value="1" onchange="updateAdvancedSetting('pixelRatio', parseFloat(this.value)); document.getElementById('pixel-val').innerText = this.value + 'x'" style="flex: 1;">
                            <span id="pixel-val" style="min-width: 40px; text-align: right;">1.0x</span>
                        </div>
                    </div>
                </div>
            </div>
            <div style="padding: 20px; background: #0f172a; border-top: 2px solid #3498db;">
                <button class="btn" onclick="closeAdvancedGraphics()" style="width: 100%; background: #e74c3c; font-size: 18px;">CLOSE</button>
            </div>
        </div>
    </div>
    <!-- End Advanced Graphics Modal -->>